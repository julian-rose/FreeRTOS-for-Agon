; Zilog eZ80 ANSI C Compiler Release 3.4
; -noglobalopt -nolocalcse -optsize -nomodsect -reduceopt
; -nopadbranch -debug -peephole -const=ROM 
	FILE	"..\..\..\Source\queue.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "NONAME0",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME1"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME2"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME2",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME2"
.BEGREC "HeapRegion",6
.DEFINE "pucStartAddress"
.VALUE 0
.CLASS 8
.TYPE 44
.ENDEF
.DEFINE "xSizeInBytes"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "HeapRegion"
.BEGREC "xHeapStats",21
.DEFINE "xAvailableHeapSpaceInBytes"
.VALUE 0
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "xSizeOfLargestFreeBlockInBytes"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "xSizeOfSmallestFreeBlockInBytes"
.VALUE 6
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "xNumberOfFreeBlocks"
.VALUE 9
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "xMinimumEverFreeBytesRemaining"
.VALUE 12
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "xNumberOfSuccessfulAllocations"
.VALUE 15
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "xNumberOfSuccessfulFrees"
.VALUE 18
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "xHeapStats"
.BEGREC "xSTATIC_LIST_ITEM",16
.DEFINE "xDummy2"
.VALUE 0
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "pvDummy3"
.VALUE 4
.CLASS 8
.DIM 4
.TYPE 353
.ENDEF
.ENDREC "xSTATIC_LIST_ITEM"
.BEGREC "xSTATIC_MINI_LIST_ITEM",10
.DEFINE "xDummy2"
.VALUE 0
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "pvDummy3"
.VALUE 4
.CLASS 8
.DIM 2
.TYPE 353
.ENDEF
.ENDREC "xSTATIC_MINI_LIST_ITEM"
.BEGREC "xSTATIC_LIST",16
.DEFINE "uxDummy2"
.VALUE 0
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "pvDummy3"
.VALUE 3
.CLASS 8
.TYPE 33
.ENDEF
.DEFINE "xDummy4"
.VALUE 6
.CLASS 8
.TAG "xSTATIC_MINI_LIST_ITEM"
.TYPE 8
.ENDEF
.ENDREC "xSTATIC_LIST"
.BEGREC "xSTATIC_TCB",69
.DEFINE "pxDummy1"
.VALUE 0
.CLASS 8
.TYPE 33
.ENDEF
.DEFINE "xDummy3"
.VALUE 3
.CLASS 8
.DIM 2
.TAG "xSTATIC_LIST_ITEM"
.TYPE 104
.ENDEF
.DEFINE "uxDummy5"
.VALUE 35
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "pxDummy6"
.VALUE 38
.CLASS 8
.TYPE 33
.ENDEF
.DEFINE "ucDummy7"
.VALUE 41
.CLASS 8
.DIM 16
.TYPE 108
.ENDEF
.DEFINE "uxDummy12"
.VALUE 57
.CLASS 8
.DIM 2
.TYPE 110
.ENDEF
.DEFINE "ulDummy18"
.VALUE 63
.CLASS 8
.DIM 1
.TYPE 111
.ENDEF
.DEFINE "ucDummy19"
.VALUE 67
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.DEFINE "ucDummy21"
.VALUE 68
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "xSTATIC_TCB"
.BEGREC "xSTATIC_QUEUE",55
.DEFINE "pvDummy1"
.VALUE 0
.CLASS 8
.DIM 3
.TYPE 353
.ENDEF
.DEFINE "u"
.VALUE 9
.CLASS 8
.TAG "NONAME3"
.TYPE 8
.ENDEF
.DEFINE "xDummy3"
.VALUE 12
.CLASS 8
.DIM 2
.TAG "xSTATIC_LIST"
.TYPE 104
.ENDEF
.DEFINE "uxDummy4"
.VALUE 44
.CLASS 8
.DIM 3
.TYPE 110
.ENDEF
.DEFINE "ucDummy5"
.VALUE 53
.CLASS 8
.DIM 2
.TYPE 108
.ENDEF
.ENDREC "xSTATIC_QUEUE"
.BEGREC "NONAME3",3
.DEFINE "pvDummy2"
.VALUE 0
.CLASS 11
.TYPE 33
.ENDEF
.DEFINE "uxDummy2"
.VALUE 0
.CLASS 11
.TYPE 14
.ENDEF
.ENDREC "NONAME3"
.BEGREC "xSTATIC_EVENT_GROUP",20
.DEFINE "xDummy1"
.VALUE 0
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "xDummy2"
.VALUE 4
.CLASS 8
.TAG "xSTATIC_LIST"
.TYPE 8
.ENDEF
.ENDREC "xSTATIC_EVENT_GROUP"
.BEGREC "xSTATIC_TIMER",30
.DEFINE "pvDummy1"
.VALUE 0
.CLASS 8
.TYPE 33
.ENDEF
.DEFINE "xDummy2"
.VALUE 3
.CLASS 8
.TAG "xSTATIC_LIST_ITEM"
.TYPE 8
.ENDEF
.DEFINE "xDummy3"
.VALUE 19
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "pvDummy5"
.VALUE 23
.CLASS 8
.TYPE 33
.ENDEF
.DEFINE "pvDummy6"
.VALUE 26
.CLASS 8
.TYPE 545
.ENDEF
.DEFINE "ucDummy8"
.VALUE 29
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "xSTATIC_TIMER"
.BEGREC "xSTATIC_STREAM_BUFFER",22
.DEFINE "uxDummy1"
.VALUE 0
.CLASS 8
.DIM 4
.TYPE 110
.ENDEF
.DEFINE "pvDummy2"
.VALUE 12
.CLASS 8
.DIM 3
.TYPE 353
.ENDEF
.DEFINE "ucDummy3"
.VALUE 21
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "xSTATIC_STREAM_BUFFER"
.BEGREC "xLIST_ITEM",16
.DEFINE "xItemValue"
.VALUE 0
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "pxNext"
.VALUE 4
.CLASS 8
.TAG "xLIST_ITEM"
.TYPE 40
.ENDEF
.DEFINE "pxPrevious"
.VALUE 7
.CLASS 8
.TAG "xLIST_ITEM"
.TYPE 40
.ENDEF
.DEFINE "pvOwner"
.VALUE 10
.CLASS 8
.TYPE 33
.ENDEF
.DEFINE "pvContainer"
.VALUE 13
.CLASS 8
.TAG "xLIST"
.TYPE 40
.ENDEF
.ENDREC "xLIST_ITEM"
.BEGREC "xMINI_LIST_ITEM",10
.DEFINE "xItemValue"
.VALUE 0
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "pxNext"
.VALUE 4
.CLASS 8
.TAG "xLIST_ITEM"
.TYPE 40
.ENDEF
.DEFINE "pxPrevious"
.VALUE 7
.CLASS 8
.TAG "xLIST_ITEM"
.TYPE 40
.ENDEF
.ENDREC "xMINI_LIST_ITEM"
.BEGREC "xLIST",16
.DEFINE "uxNumberOfItems"
.VALUE 0
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "pxIndex"
.VALUE 3
.CLASS 8
.TAG "xLIST_ITEM"
.TYPE 40
.ENDEF
.DEFINE "xListEnd"
.VALUE 6
.CLASS 8
.TAG "xMINI_LIST_ITEM"
.TYPE 8
.ENDEF
.ENDREC "xLIST"
.BEGREC "xTIME_OUT",7
.DEFINE "xOverflowCount"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "xTimeOnEntering"
.VALUE 3
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "xTIME_OUT"
.BEGREC "xMEMORY_REGION",11
.DEFINE "pvBaseAddress"
.VALUE 0
.CLASS 8
.TYPE 33
.ENDEF
.DEFINE "ulLengthInBytes"
.VALUE 3
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "ulParameters"
.VALUE 7
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "xMEMORY_REGION"
.BEGREC "xTASK_PARAMETERS",29
.DEFINE "pvTaskCode"
.VALUE 0
.CLASS 8
.TYPE 545
.ENDEF
.DEFINE "pcName"
.VALUE 3
.CLASS 8
.TYPE 194
.ENDEF
.DEFINE "usStackDepth"
.VALUE 6
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "pvParameters"
.VALUE 9
.CLASS 8
.TYPE 33
.ENDEF
.DEFINE "uxPriority"
.VALUE 12
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "puxStackBuffer"
.VALUE 15
.CLASS 8
.TYPE 46
.ENDEF
.DEFINE "xRegions"
.VALUE 18
.CLASS 8
.DIM 1
.TAG "xMEMORY_REGION"
.TYPE 104
.ENDEF
.ENDREC "xTASK_PARAMETERS"
.BEGREC "xTASK_STATUS",28
.DEFINE "xHandle"
.VALUE 0
.CLASS 8
.TAG "~tag"
.TYPE 40
.ENDEF
.DEFINE "pcTaskName"
.VALUE 3
.CLASS 8
.TYPE 194
.ENDEF
.DEFINE "xTaskNumber"
.VALUE 6
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "eCurrentState"
.VALUE 9
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "uxCurrentPriority"
.VALUE 12
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "uxBasePriority"
.VALUE 15
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "ulRunTimeCounter"
.VALUE 18
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "pxStackBase"
.VALUE 22
.CLASS 8
.TYPE 46
.ENDEF
.DEFINE "usStackHighWaterMark"
.VALUE 25
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "xTASK_STATUS"
.BEGREC "corCoRoutineControlBlock",43
.DEFINE "pxCoRoutineFunction"
.VALUE 0
.CLASS 8
.TYPE 545
.ENDEF
.DEFINE "xGenericListItem"
.VALUE 3
.CLASS 8
.TAG "xLIST_ITEM"
.TYPE 8
.ENDEF
.DEFINE "xEventListItem"
.VALUE 19
.CLASS 8
.TAG "xLIST_ITEM"
.TYPE 8
.ENDEF
.DEFINE "uxPriority"
.VALUE 35
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "uxIndex"
.VALUE 38
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "uxState"
.VALUE 41
.CLASS 8
.TYPE 13
.ENDEF
.ENDREC "corCoRoutineControlBlock"
;    1	/*
;    2	 * FreeRTOS Kernel V10.5.1
;    3	 * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
;    4	 *
;    5	 * SPDX-License-Identifier: MIT
;    6	 *
;    7	 * Permission is hereby granted, free of charge, to any person obtaining a copy of
;    8	 * this software and associated documentation files (the "Software"), to deal in
;    9	 * the Software without restriction, including without limitation the rights to
;   10	 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
;   11	 * the Software, and to permit persons to whom the Software is furnished to do so,
;   12	 * subject to the following conditions:
;   13	 *
;   14	 * The above copyright notice and this permission notice shall be included in all
;   15	 * copies or substantial portions of the Software.
;   16	 *
;   17	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;   18	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
;   19	 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
;   20	 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
;   21	 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;   22	 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;   23	 *
;   24	 * https://www.FreeRTOS.org
;   25	 * https://github.com/FreeRTOS
;   26	 *
;   27	 */
;   28	
;   29	#include <stdlib.h>
;   30	#include <string.h>
;   31	
;   32	/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
;   33	 * all the API functions to use the MPU wrappers.  That should only be done when
;   34	 * task.h is included from an application file. */
;   35	#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
;   36	
;   37	#include "FreeRTOS.h"
;   38	#include "task.h"
;   39	#include "queue.h"
;   40	
;   41	#if ( configUSE_CO_ROUTINES == 1 )
;   42	    #include "croutine.h"
;   43	#endif
;   44	
;   45	/* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
;   46	 * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
;   47	 * for the header files above, but not in this file, in order to generate the
;   48	 * correct privileged Vs unprivileged linkage and placement. */
;   49	#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
;   50	
;   51	
;   52	/* Constants used with the cRxLock and cTxLock structure members. */
;   53	#define queueUNLOCKED             ( ( int8_t ) -1 )
;   54	#define queueLOCKED_UNMODIFIED    ( ( int8_t ) 0 )
;   55	#define queueINT8_MAX             ( ( int8_t ) 127 )
;   56	
;   57	/* When the Queue_t structure is used to represent a base queue its pcHead and
;   58	 * pcTail members are used as pointers into the queue storage area.  When the
;   59	 * Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
;   60	 * not necessary, and the pcHead pointer is set to NULL to indicate that the
;   61	 * structure instead holds a pointer to the mutex holder (if any).  Map alternative
;   62	 * names to the pcHead and structure member to ensure the readability of the code
;   63	 * is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
;   64	 * a union as their usage is mutually exclusive dependent on what the queue is
;   65	 * being used for. */
;   66	#define uxQueueType               pcHead
;   67	#define queueQUEUE_IS_MUTEX       NULL
;   68	
;   69	typedef struct QueuePointers
;   70	{
;   71	    int8_t * pcTail;     /*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
;   72	    int8_t * pcReadFrom; /*< Points to the last place that a queued item was read from when the structure is used as a queue. */
;   73	} QueuePointers_t;
.BEGREC "QueuePointers",6
.DEFINE "pcTail"
.VALUE 0
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pcReadFrom"
.VALUE 3
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "QueuePointers"
;   74	
;   75	typedef struct SemaphoreData
;   76	{
;   77	    TaskHandle_t xMutexHolder;        /*< The handle of the task that holds the mutex. */
;   78	    UBaseType_t uxRecursiveCallCount; /*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */
;   79	} SemaphoreData_t;
.BEGREC "SemaphoreData",6
.DEFINE "xMutexHolder"
.VALUE 0
.CLASS 8
.TAG "~tag"
.TYPE 40
.ENDEF
.DEFINE "uxRecursiveCallCount"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "SemaphoreData"
;   80	
;   81	/* Semaphores do not actually store or copy data, so have an item size of
;   82	 * zero. */
;   83	#define queueSEMAPHORE_QUEUE_ITEM_LENGTH    ( ( UBaseType_t ) 0 )
;   84	#define queueMUTEX_GIVE_BLOCK_TIME          ( ( TickType_t ) 0U )
;   85	
;   86	#if ( configUSE_PREEMPTION == 0 )
;   87	
;   88	/* If the cooperative scheduler is being used then a yield should not be
;   89	 * performed just because a higher priority task has been woken. */
;   90	    #define queueYIELD_IF_USING_PREEMPTION()
;   91	#else
;   92	    #define queueYIELD_IF_USING_PREEMPTION()    portYIELD_WITHIN_API()
;   93	#endif
;   94	
;   95	/*
;   96	 * Definition of the queue used by the scheduler.
;   97	 * Items are queued by copy, not reference.  See the following link for the
;   98	 * rationale: https://www.FreeRTOS.org/Embedded-RTOS-Queues.html
;   99	 */
;  100	typedef struct QueueDefinition /* The old naming convention is used to prevent breaking kernel aware debuggers. */
;  101	{
;  102	    int8_t * pcHead;           /*< Points to the beginning of the queue storage area. */
;  103	    int8_t * pcWriteTo;        /*< Points to the free next place in the storage area. */
;  104	
;  105	    union
;  106	    {
;  107	        QueuePointers_t xQueue;     /*< Data required exclusively when this structure is used as a queue. */
;  108	        SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaphore. */
;  109	    } u;
;  110	
;  111	    List_t xTasksWaitingToSend;             /*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
;  112	    List_t xTasksWaitingToReceive;          /*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
;  113	
;  114	    volatile UBaseType_t uxMessagesWaiting; /*< The number of items currently in the queue. */
;  115	    UBaseType_t uxLength;                   /*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
;  116	    UBaseType_t uxItemSize;                 /*< The size of each items that the queue will hold. */
;  117	
;  118	    volatile int8_t cRxLock;                /*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
;  119	    volatile int8_t cTxLock;                /*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
;  120	
;  121	    #if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
;  122	        uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */
;  123	    #endif
;  124	
;  125	    #if ( configUSE_QUEUE_SETS == 1 )
;  126	        struct QueueDefinition * pxQueueSetContainer;
;  127	    #endif
;  128	
;  129	    #if ( configUSE_TRACE_FACILITY == 1 )
;  130	        UBaseType_t uxQueueNumber;
;  131	        uint8_t ucQueueType;
;  132	    #endif
;  133	} xQUEUE;
.BEGREC "QueueDefinition",55
.DEFINE "pcHead"
.VALUE 0
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pcWriteTo"
.VALUE 3
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "u"
.VALUE 6
.CLASS 8
.TAG "NONAME4"
.TYPE 8
.ENDEF
.DEFINE "xTasksWaitingToSend"
.VALUE 12
.CLASS 8
.TAG "xLIST"
.TYPE 8
.ENDEF
.DEFINE "xTasksWaitingToReceive"
.VALUE 28
.CLASS 8
.TAG "xLIST"
.TYPE 8
.ENDEF
.DEFINE "uxMessagesWaiting"
.VALUE 44
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "uxLength"
.VALUE 47
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "uxItemSize"
.VALUE 50
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "cRxLock"
.VALUE 53
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "cTxLock"
.VALUE 54
.CLASS 8
.TYPE 2
.ENDEF
.ENDREC "QueueDefinition"
.BEGREC "NONAME4",6
.DEFINE "xQueue"
.VALUE 0
.CLASS 11
.TAG "QueuePointers"
.TYPE 8
.ENDEF
.DEFINE "xSemaphore"
.VALUE 0
.CLASS 11
.TAG "SemaphoreData"
.TYPE 8
.ENDEF
.ENDREC "NONAME4"
;  134	
;  135	/* The old xQUEUE name is maintained above then typedefed to the new Queue_t
;  136	 * name below to enable the use of older kernel aware debuggers. */
;  137	typedef xQUEUE Queue_t;
;  138	
;  139	/*-----------------------------------------------------------*/
;  140	
;  141	/*
;  142	 * The queue registry is just a means for kernel aware debuggers to locate
;  143	 * queue structures.  It has no other purpose so is an optional component.
;  144	 */
;  145	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;  146	
;  147	/* The type stored within the queue registry array.  This allows a name
;  148	 * to be assigned to each queue making kernel aware debugging a little
;  149	 * more user friendly. */
;  150	    typedef struct QUEUE_REGISTRY_ITEM
;  151	    {
;  152	        const char * pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;  153	        QueueHandle_t xHandle;
;  154	    } xQueueRegistryItem;
;  155	
;  156	/* The old xQueueRegistryItem name is maintained above then typedefed to the
;  157	 * new xQueueRegistryItem name below to enable the use of older kernel aware
;  158	 * debuggers. */
;  159	    typedef xQueueRegistryItem QueueRegistryItem_t;
;  160	
;  161	/* The queue registry is simply an array of QueueRegistryItem_t structures.
;  162	 * The pcQueueName member of a structure being NULL is indicative of the
;  163	 * array position being vacant. */
;  164	    PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
;  165	
;  166	#endif /* configQUEUE_REGISTRY_SIZE */
;  167	
;  168	/*
;  169	 * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
;  170	 * prevent an ISR from adding or removing items to the queue, but does prevent
;  171	 * an ISR from removing tasks from the queue event lists.  If an ISR finds a
;  172	 * queue is locked it will instead increment the appropriate queue lock count
;  173	 * to indicate that a task may require unblocking.  When the queue in unlocked
;  174	 * these lock counts are inspected, and the appropriate action taken.
;  175	 */
;  176	static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
;  177	
;  178	/*
;  179	 * Uses a critical section to determine if there is any data in a queue.
;  180	 *
;  181	 * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
;  182	 */
;  183	static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;
;  184	
;  185	/*
;  186	 * Uses a critical section to determine if there is any space in a queue.
;  187	 *
;  188	 * @return pdTRUE if there is no space, otherwise pdFALSE;
;  189	 */
;  190	static BaseType_t prvIsQueueFull( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;
;  191	
;  192	/*
;  193	 * Copies an item into the queue, either at the front of the queue or the
;  194	 * back of the queue.
;  195	 */
;  196	static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
;  197	                                      const void * pvItemToQueue,
;  198	                                      const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
;  199	
;  200	/*
;  201	 * Copies an item out of a queue.
;  202	 */
;  203	static void prvCopyDataFromQueue( Queue_t * const pxQueue,
;  204	                                  void * const pvBuffer ) PRIVILEGED_FUNCTION;
;  205	
;  206	#if ( configUSE_QUEUE_SETS == 1 )
;  207	
;  208	/*
;  209	 * Checks to see if a queue is a member of a queue set, and if so, notifies
;  210	 * the queue set that the queue contains data.
;  211	 */
;  212	    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
;  213	#endif
;  214	
;  215	/*
;  216	 * Called after a Queue_t structure has been allocated either statically or
;  217	 * dynamically to fill in the structure's members.
;  218	 */
;  219	static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
;  220	                                   const UBaseType_t uxItemSize,
;  221	                                   uint8_t * pucQueueStorage,
;  222	                                   const uint8_t ucQueueType,
;  223	                                   Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;
;  224	
;  225	/*
;  226	 * Mutexes are a special type of queue.  When a mutex is created, first the
;  227	 * queue is created, then prvInitialiseMutex() is called to configure the queue
;  228	 * as a mutex.
;  229	 */
;  230	#if ( configUSE_MUTEXES == 1 )
;  231	    static void prvInitialiseMutex( Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;
;  232	#endif
;  233	
;  234	#if ( configUSE_MUTEXES == 1 )
;  235	
;  236	/*
;  237	 * If a task waiting for a mutex causes the mutex holder to inherit a
;  238	 * priority, but the waiting task times out, then the holder should
;  239	 * disinherit the priority - but only down to the highest priority of any
;  240	 * other tasks that are waiting for the same mutex.  This function returns
;  241	 * that priority.
;  242	 */
;  243	    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
;  244	#endif
;  245	/*-----------------------------------------------------------*/
;  246	
;  247	/*
;  248	 * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
;  249	 * accessing the queue event lists.
;  250	 */
;  251	#define prvLockQueue( pxQueue )                            \
;  252	    taskENTER_CRITICAL();                                  \
;  253	    {                                                      \
;  254	        if( ( pxQueue )->cRxLock == queueUNLOCKED )        \
;  255	        {                                                  \
;  256	            ( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED; \
;  257	        }                                                  \
;  258	        if( ( pxQueue )->cTxLock == queueUNLOCKED )        \
;  259	        {                                                  \
;  260	            ( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED; \
;  261	        }                                                  \
;  262	    }                                                      \
;  263	    taskEXIT_CRITICAL()
;  264	
;  265	/*
;  266	 * Macro to increment cTxLock member of the queue data structure. It is
;  267	 * capped at the number of tasks in the system as we cannot unblock more
;  268	 * tasks than the number of tasks in the system.
;  269	 */
;  270	#define prvIncrementQueueTxLock( pxQueue, cTxLock )                           \
;  271	    {                                                                         \
;  272	        const UBaseType_t uxNumberOfTasks = uxTaskGetNumberOfTasks();         \
;  273	        if( ( UBaseType_t ) ( cTxLock ) < uxNumberOfTasks )                   \
;  274	        {                                                                     \
;  275	            configASSERT( ( cTxLock ) != queueINT8_MAX );                     \
;  276	            ( pxQueue )->cTxLock = ( int8_t ) ( ( cTxLock ) + ( int8_t ) 1 ); \
;  277	        }                                                                     \
;  278	    }
;  279	
;  280	/*
;  281	 * Macro to increment cRxLock member of the queue data structure. It is
;  282	 * capped at the number of tasks in the system as we cannot unblock more
;  283	 * tasks than the number of tasks in the system.
;  284	 */
;  285	#define prvIncrementQueueRxLock( pxQueue, cRxLock )                           \
;  286	    {                                                                         \
;  287	        const UBaseType_t uxNumberOfTasks = uxTaskGetNumberOfTasks();         \
;  288	        if( ( UBaseType_t ) ( cRxLock ) < uxNumberOfTasks )                   \
;  289	        {                                                                     \
;  290	            configASSERT( ( cRxLock ) != queueINT8_MAX );                     \
;  291	            ( pxQueue )->cRxLock = ( int8_t ) ( ( cRxLock ) + ( int8_t ) 1 ); \
;  292	        }                                                                     \
;  293	    }
;  294	/*-----------------------------------------------------------*/
;  295	
;  296	BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
;  297	                               BaseType_t xNewQueue )
;  298	{
_xQueueGenericReset:
.DEFINE "_xQueueGenericReset"

.VALUE _xQueueGenericReset

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xQueueGenericReset",298,"_xQueueGenericReset"

.LINE 298

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "xNewQueue"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -3

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
;  299	    BaseType_t xReturn = pdPASS;
.LINE 299

	LD	BC,1
	LD	(IX+%FFFFFFFA),BC
;  300	    Queue_t * const pxQueue = xQueue;
.LINE 300

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
;  301	
;  302	    configASSERT( pxQueue );
;  303	
;  304	    if( ( pxQueue != NULL ) &&
.LINE 304

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	Z,L_14
;  305	        ( pxQueue->uxLength >= 1U ) &&
.LINE 305

	LD	BC,1
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%2F)
	OR	A,A
	SBC	HL,BC
	JR	C,L_14
;  306	        /* Check for multiplication overflow. */
;  307	        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
.LINE 307

	LD	HL,16777215
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%2F)
	CALL	__idivu
	LD	BC,(IY+%32)
	OR	A,A
	SBC	HL,BC
	JR	C,L_14
;  308	    {
;  309	        taskENTER_CRITICAL();
.LINE 309

	 di
;  310	        {
;  311	            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
.LINE 311

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%2F)
	LD	BC,(IY+%32)
	CALL	__imulu
	LD	BC,(IY+%0)
	ADD	HL,BC
	LD	(IY+%6),HL
;  312	            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
.LINE 312

	LD	BC,0
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%2C),BC
;  313	            pxQueue->pcWriteTo = pxQueue->pcHead;
.LINE 313

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%0)
	LD	(IY+%3),BC
;  314	            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
.LINE 314

	LD	IY,(IX+%FFFFFFFD)
	LD	IY,(IY+%2F)
	LEA	HL,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%32)
	CALL	__imulu
	LD	BC,(IY+%0)
	ADD	HL,BC
	LD	(IY+%9),HL
;  315	            pxQueue->cRxLock = queueUNLOCKED;
.LINE 315

	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%35),%FF
;  316	            pxQueue->cTxLock = queueUNLOCKED;
.LINE 316

	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%36),%FF
;  317	
;  318	            if( xNewQueue == pdFALSE )
.LINE 318

	LD	HL,(IX+%9)
	CALL	__icmpzero
	JR	NZ,L_11
;  319	            {
;  320	                /* If there are tasks blocked waiting to read from the queue, then
;  321	                 * the tasks will remain blocked as after this function exits the queue
;  322	                 * will still be empty.  If there are tasks blocked waiting to write to
;  323	                 * the queue, then one should be unblocked as after this function exits
;  324	                 * it will be possible to write to it. */
;  325	                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
.LINE 325

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%C)
	CALL	__icmpzero
	JR	NZ,L_4
	LD	BC,1
	LD	(IX+%FFFFFFF7),BC
	JR	L_5
L_4:
	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
L_5:
	LD	HL,(IX+%FFFFFFF7)
	CALL	__icmpzero
	JR	NZ,L_12
;  326	                {
;  327	                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
.LINE 327

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%C
	CALL	_xTaskRemoveFromEventList
	POP	BC
	CALL	__icmpzero
	JR	Z,L_12
;  328	                    {
;  329	                        queueYIELD_IF_USING_PREEMPTION();
;  330	                    }
;  331	                    else
.LINE 331

	JR	L_12
;  332	                    {
;  333	                        mtCOVERAGE_TEST_MARKER();
;  334	                    }
;  335	                }
;  336	                else
.LINE 336

;  337	                {
;  338	                    mtCOVERAGE_TEST_MARKER();
;  339	                }
;  340	            }
;  341	            else
.LINE 341

	JR	L_12
L_11:
;  342	            {
;  343	                /* Ensure the event queues start in the correct state. */
;  344	                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
.LINE 344

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%C
	CALL	_vListInitialise
	POP	BC
;  345	                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
.LINE 345

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%1C
	CALL	_vListInitialise
	POP	BC
;  346	            }
;  347	        }
L_12:
.LINE 347

;  348	        taskEXIT_CRITICAL();
.LINE 348

	 ei
;  349	    }
;  350	    else
.LINE 350

	JR	L_15
L_14:
;  351	    {
;  352	        xReturn = pdFAIL;
.LINE 352

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
;  353	    }
L_15:
.LINE 353

;  354	
;  355	    configASSERT( xReturn != pdFAIL );
;  356	
;  357	    /* A value is returned for calling semantic consistency with previous
;  358	     * versions. */
;  359	    return xReturn;
.LINE 359

	LD	HL,(IX+%FFFFFFFA)
;  360	}
.LINE 360

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xQueueGenericReset ***************************
;Name                         Addr/Register   Size   Type
;_vListInitialise                    IMPORT  -----   function
;_xTaskRemoveFromEventList           IMPORT  -----   function
;temp2                                 IX-9      3   variable
;xReturn                               IX-6      3   variable
;pxQueue                               IX-3      3   variable
;xNewQueue                             IX+9      3   parameter
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xQueueGenericReset",360,"_xQueueGenericReset"
;  361	/*-----------------------------------------------------------*/
;  362	
;  363	#if ( configSUPPORT_STATIC_ALLOCATION == 1 )
;  364	
;  365	    QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength,
;  366	                                             const UBaseType_t uxItemSize,
;  367	                                             uint8_t * pucQueueStorage,
;  368	                                             StaticQueue_t * pxStaticQueue,
;  369	                                             const uint8_t ucQueueType )
;  370	    {
;  371	        Queue_t * pxNewQueue = NULL;
;  372	
;  373	        /* The StaticQueue_t structure and the queue storage area must be
;  374	         * supplied. */
;  375	        configASSERT( pxStaticQueue );
;  376	
;  377	        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
;  378	            ( pxStaticQueue != NULL ) &&
;  379	
;  380	            /* A queue storage area should be provided if the item size is not 0, and
;  381	             * should not be provided if the item size is 0. */
;  382	            ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) ) &&
;  383	            ( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) ) )
;  384	        {
;  385	            #if ( configASSERT_DEFINED == 1 )
;  386	            {
;  387	                /* Sanity check that the size of the structure used to declare a
;  388	                 * variable of type StaticQueue_t or StaticSemaphore_t equals the size of
;  389	                 * the real queue and semaphore structures. */
;  390	                volatile size_t xSize = sizeof( StaticQueue_t );
;  391	
;  392	                /* This assertion cannot be branch covered in unit tests */
;  393	                configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
;  394	                ( void ) xSize;                             /* Keeps lint quiet when configASSERT() is not defined. */
;  395	            }
;  396	            #endif /* configASSERT_DEFINED */
;  397	
;  398	            /* The address of a statically allocated queue was passed in, use it.
;  399	             * The address of a statically allocated storage area was also passed in
;  400	             * but is already set. */
;  401	            pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
;  402	
;  403	            #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
;  404	            {
;  405	                /* Queues can be allocated wither statically or dynamically, so
;  406	                 * note this queue was allocated statically in case the queue is
;  407	                 * later deleted. */
;  408	                pxNewQueue->ucStaticallyAllocated = pdTRUE;
;  409	            }
;  410	            #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;  411	
;  412	            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
;  413	        }
;  414	        else
;  415	        {
;  416	            configASSERT( pxNewQueue );
;  417	            mtCOVERAGE_TEST_MARKER();
;  418	        }
;  419	
;  420	        return pxNewQueue;
;  421	    }
;  422	
;  423	#endif /* configSUPPORT_STATIC_ALLOCATION */
;  424	/*-----------------------------------------------------------*/
;  425	
;  426	#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
;  427	
;  428	    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
;  429	                                       const UBaseType_t uxItemSize,
;  430	                                       const uint8_t ucQueueType )
;  431	    {
_xQueueGenericCreate:
.DEFINE "_xQueueGenericCreate"

.VALUE _xQueueGenericCreate

.CLASS 2

.TAG "QueueDefinition"

.TYPE 328

.ENDEF

.BEGFUNC "xQueueGenericCreate",431,"_xQueueGenericCreate"

.LINE 431

.DEFINE "uxQueueLength"

.CLASS 65

.VALUE 6

.TYPE 14

.ENDEF

.DEFINE "uxItemSize"

.CLASS 65

.VALUE 9

.TYPE 14

.ENDEF

.DEFINE "ucQueueType"

.CLASS 65

.VALUE 12

.TYPE 12

.ENDEF

.DEFINE "pxNewQueue"

.CLASS 65

.VALUE -3

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "pucQueueStorage"

.CLASS 65

.VALUE -6

.TYPE 44

.ENDEF

.DEFINE "xQueueSizeInBytes"

.CLASS 65

.VALUE -9

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
;  432	        Queue_t * pxNewQueue = NULL;
.LINE 432

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
;  433	        size_t xQueueSizeInBytes;
;  434	        uint8_t * pucQueueStorage;
;  435	
;  436	        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
.LINE 436

	LD	BC,(IX+%6)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_22
;  437	            /* Check for multiplication overflow. */
;  438	            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
.LINE 438

	LD	HL,16777215
	LD	BC,(IX+%6)
	CALL	__idivu
	LD	BC,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JR	C,L_22
;  439	            /* Check for addition overflow. */
;  440	            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
.LINE 440

	LD	HL,(IX+%6)
	LD	BC,(IX+%9)
	CALL	__imulu
	LD	BC,HL
	LD	HL,16777160
	OR	A,A
	SBC	HL,BC
	JR	C,L_22
;  441	        {
;  442	            /* Allocate enough space to hold the maximum number of items that
;  443	             * can be in the queue at any time.  It is valid for uxItemSize to be
;  444	             * zero in the case the queue is used as a semaphore. */
;  445	            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
.LINE 445

	LD	HL,(IX+%6)
	LD	BC,(IX+%9)
	CALL	__imulu
	LD	(IX+%FFFFFFF7),HL
;  446	
;  447	            /* Allocate the queue and storage area.  Justification for MISRA
;  448	             * deviation as follows:  pvPortMalloc() always ensures returned memory
;  449	             * blocks are aligned per the requirements of the MCU stack.  In this case
;  450	             * pvPortMalloc() must return a pointer that is guaranteed to meet the
;  451	             * alignment requirements of the Queue_t structure - which in this case
;  452	             * is an int8_t *.  Therefore, whenever the stack alignment requirements
;  453	             * are greater than or equal to the pointer to char requirements the cast
;  454	             * is safe.  In other cases alignment requirements are not strict (one or
;  455	             * two bytes). */
;  456	            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
.LINE 456

	LD	IY,(IX+%FFFFFFF7)
	LEA	BC,IY+%37
	PUSH	BC
	CALL	_pvPortMalloc
	POP	BC
	LD	(IX+%FFFFFFFD),HL
;  457	
;  458	            if( pxNewQueue != NULL )
.LINE 458

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	Z,L_20
;  459	            {
;  460	                /* Jump past the queue structure to find the location of the queue
;  461	                 * storage area. */
;  462	                pucQueueStorage = ( uint8_t * ) pxNewQueue;
.LINE 462

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFFA),BC
;  463	                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
.LINE 463

	LD	IY,(IX+%FFFFFFFA)
	LEA	IY,IY+%37
	LD	(IX+%FFFFFFFA),IY
;  464	
;  465	                #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
;  466	                {
;  467	                    /* Queues can be created either statically or dynamically, so
;  468	                     * note this task was created dynamically in case it is later
;  469	                     * deleted. */
;  470	                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
;  471	                }
;  472	                #endif /* configSUPPORT_STATIC_ALLOCATION */
;  473	
;  474	                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
.LINE 474

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_prvInitialiseNewQueue
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  475	            }
;  476	            else
L_20:
.LINE 476

;  477	            {
;  478	                traceQUEUE_CREATE_FAILED( ucQueueType );
;  479	                mtCOVERAGE_TEST_MARKER();
;  480	            }
;  481	        }
;  482	        else
L_22:
.LINE 482

;  483	        {
;  484	            configASSERT( pxNewQueue );
;  485	            mtCOVERAGE_TEST_MARKER();
;  486	        }
;  487	
;  488	        return pxNewQueue;
.LINE 488

	LD	HL,(IX+%FFFFFFFD)
;  489	    }
.LINE 489

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xQueueGenericCreate ***************************
;Name                         Addr/Register   Size   Type
;_prvInitialiseNewQueue              STATIC  -----   function
;_pvPortMalloc                       IMPORT  -----   function
;xQueueSizeInBytes                     IX-9      3   variable
;pucQueueStorage                       IX-6      3   variable
;pxNewQueue                            IX-3      3   variable
;ucQueueType                          IX+12      1   parameter
;uxItemSize                            IX+9      3   parameter
;uxQueueLength                         IX+6      3   parameter


; Stack Frame Size: 24 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xQueueGenericCreate",489,"_xQueueGenericCreate"
;  490	
;  491	#endif /* configSUPPORT_STATIC_ALLOCATION */
;  492	/*-----------------------------------------------------------*/
;  493	
;  494	static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
;  495	                                   const UBaseType_t uxItemSize,
;  496	                                   uint8_t * pucQueueStorage,
;  497	                                   const uint8_t ucQueueType,
;  498	                                   Queue_t * pxNewQueue )
;  499	{
_prvInitialiseNewQueue:
.DEFINE "_prvInitialiseNewQueue"

.VALUE _prvInitialiseNewQueue

.CLASS 3

.TYPE 65

.ENDEF

.BEGFUNC "prvInitialiseNewQueue",499,"_prvInitialiseNewQueue"

.LINE 499

.DEFINE "uxQueueLength"

.CLASS 65

.VALUE 6

.TYPE 14

.ENDEF

.DEFINE "uxItemSize"

.CLASS 65

.VALUE 9

.TYPE 14

.ENDEF

.DEFINE "pucQueueStorage"

.CLASS 65

.VALUE 12

.TYPE 44

.ENDEF

.DEFINE "ucQueueType"

.CLASS 65

.VALUE 15

.TYPE 12

.ENDEF

.DEFINE "pxNewQueue"

.CLASS 65

.VALUE 18

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  500	    /* Remove compiler warnings about unused parameters should
;  501	     * configUSE_TRACE_FACILITY not be set to 1. */
;  502	    ( void ) ucQueueType;
;  503	
;  504	    if( uxItemSize == ( UBaseType_t ) 0 )
.LINE 504

	LD	HL,(IX+%9)
	CALL	__icmpzero
	JR	NZ,L_26
;  505	    {
;  506	        /* No RAM was allocated for the queue storage area, but PC head cannot
;  507	         * be set to NULL because NULL is used as a key to say the queue is used as
;  508	         * a mutex.  Therefore just set pcHead to point to the queue as a benign
;  509	         * value that is known to be within the memory map. */
;  510	        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
.LINE 510

	LD	BC,(IX+%12)
	LD	IY,(IX+%12)
	LD	(IY+%0),BC
;  511	    }
;  512	    else
.LINE 512

	JR	L_27
L_26:
;  513	    {
;  514	        /* Set the head to the start of the queue storage area. */
;  515	        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
.LINE 515

	LD	BC,(IX+%C)
	LD	IY,(IX+%12)
	LD	(IY+%0),BC
;  516	    }
L_27:
.LINE 516

;  517	
;  518	    /* Initialise the queue members as described where the queue type is
;  519	     * defined. */
;  520	    pxNewQueue->uxLength = uxQueueLength;
.LINE 520

	LD	BC,(IX+%6)
	LD	IY,(IX+%12)
	LD	(IY+%2F),BC
;  521	    pxNewQueue->uxItemSize = uxItemSize;
.LINE 521

	LD	BC,(IX+%9)
	LD	IY,(IX+%12)
	LD	(IY+%32),BC
;  522	    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
.LINE 522

	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%12)
	PUSH	BC
	CALL	_xQueueGenericReset
	POP	BC
	POP	BC
;  523	
;  524	    #if ( configUSE_TRACE_FACILITY == 1 )
;  525	    {
;  526	        pxNewQueue->ucQueueType = ucQueueType;
;  527	    }
;  528	    #endif /* configUSE_TRACE_FACILITY */
;  529	
;  530	    #if ( configUSE_QUEUE_SETS == 1 )
;  531	    {
;  532	        pxNewQueue->pxQueueSetContainer = NULL;
;  533	    }
;  534	    #endif /* configUSE_QUEUE_SETS */
;  535	
;  536	    traceQUEUE_CREATE( pxNewQueue );
;  537	}
.LINE 537

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvInitialiseNewQueue ***************************
;Name                         Addr/Register   Size   Type
;_xQueueGenericReset                 IMPORT  -----   function
;pxNewQueue                           IX+18      3   parameter
;ucQueueType                          IX+15      1   parameter
;pucQueueStorage                      IX+12      3   parameter
;uxItemSize                            IX+9      3   parameter
;uxQueueLength                         IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvInitialiseNewQueue",537,"_prvInitialiseNewQueue"
;  538	/*-----------------------------------------------------------*/
;  539	
;  540	#if ( configUSE_MUTEXES == 1 )
;  541	
;  542	    static void prvInitialiseMutex( Queue_t * pxNewQueue )
;  543	    {
_prvInitialiseMutex:
.DEFINE "_prvInitialiseMutex"

.VALUE _prvInitialiseMutex

.CLASS 3

.TYPE 65

.ENDEF

.BEGFUNC "prvInitialiseMutex",543,"_prvInitialiseMutex"

.LINE 543

.DEFINE "pxNewQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  544	        if( pxNewQueue != NULL )
.LINE 544

	LD	HL,(IX+%6)
	CALL	__icmpzero
	JR	Z,L_30
;  545	        {
;  546	            /* The queue create function will set all the queue structure members
;  547	            * correctly for a generic queue, but this function is creating a
;  548	            * mutex.  Overwrite those members that need to be set differently -
;  549	            * in particular the information required for priority inheritance. */
;  550	            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
.LINE 550

	LD	BC,0
	LD	IY,(IX+%6)
	LD	(IY+%6),BC
;  551	            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
.LINE 551

	LD	BC,0
	LD	IY,(IX+%6)
	LD	(IY+%0),BC
;  552	
;  553	            /* In case this is a recursive mutex. */
;  554	            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
.LINE 554

	LD	BC,0
	LD	IY,(IX+%6)
	LD	(IY+%9),BC
;  555	
;  556	            traceCREATE_MUTEX( pxNewQueue );
;  557	
;  558	            /* Start with the semaphore in the expected state. */
;  559	            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
.LINE 559

	LD	BC,0
	PUSH	BC
	PUSH	BC
	PUSH	BC
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_xQueueGenericSend
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  560	        }
;  561	        else
L_30:
.LINE 561

;  562	        {
;  563	            traceCREATE_MUTEX_FAILED();
;  564	        }
;  565	    }
.LINE 565

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvInitialiseMutex ***************************
;Name                         Addr/Register   Size   Type
;_xQueueGenericSend                  IMPORT  -----   function
;pxNewQueue                            IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvInitialiseMutex",565,"_prvInitialiseMutex"
;  566	
;  567	#endif /* configUSE_MUTEXES */
;  568	/*-----------------------------------------------------------*/
;  569	
;  570	#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
;  571	
;  572	    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
;  573	    {
_xQueueCreateMutex:
.DEFINE "_xQueueCreateMutex"

.VALUE _xQueueCreateMutex

.CLASS 2

.TAG "QueueDefinition"

.TYPE 328

.ENDEF

.BEGFUNC "xQueueCreateMutex",573,"_xQueueCreateMutex"

.LINE 573

.DEFINE "ucQueueType"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "xNewQueue"

.CLASS 65

.VALUE -3

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "uxMutexLength"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "uxMutexSize"

.CLASS 65

.VALUE -9

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
;  574	        QueueHandle_t xNewQueue;
;  575	        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
.LINE 575

	LD	BC,1
	LD	(IX+%FFFFFFFA),BC
	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
;  576	
;  577	        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
.LINE 577

	LD	C,(IX+%6)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_xQueueGenericCreate
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
;  578	        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
.LINE 578

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvInitialiseMutex
	POP	BC
;  579	
;  580	        return xNewQueue;
.LINE 580

	LD	HL,(IX+%FFFFFFFD)
;  581	    }
.LINE 581

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xQueueCreateMutex ***************************
;Name                         Addr/Register   Size   Type
;_prvInitialiseMutex                 STATIC  -----   function
;_xQueueGenericCreate                IMPORT  -----   function
;uxMutexSize                           IX-9      3   variable
;uxMutexLength                         IX-6      3   variable
;xNewQueue                             IX-3      3   variable
;ucQueueType                           IX+6      1   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xQueueCreateMutex",581,"_xQueueCreateMutex"
;  582	
;  583	#endif /* configUSE_MUTEXES */
;  584	/*-----------------------------------------------------------*/
;  585	
;  586	#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;  587	
;  588	    QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType,
;  589	                                           StaticQueue_t * pxStaticQueue )
;  590	    {
;  591	        QueueHandle_t xNewQueue;
;  592	        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
;  593	
;  594	        /* Prevent compiler warnings about unused parameters if
;  595	         * configUSE_TRACE_FACILITY does not equal 1. */
;  596	        ( void ) ucQueueType;
;  597	
;  598	        xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
;  599	        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
;  600	
;  601	        return xNewQueue;
;  602	    }
;  603	
;  604	#endif /* configUSE_MUTEXES */
;  605	/*-----------------------------------------------------------*/
;  606	
;  607	#if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
;  608	
;  609	    TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
;  610	    {
;  611	        TaskHandle_t pxReturn;
;  612	        Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
;  613	
;  614	        configASSERT( xSemaphore );
;  615	
;  616	        /* This function is called by xSemaphoreGetMutexHolder(), and should not
;  617	         * be called directly.  Note:  This is a good way of determining if the
;  618	         * calling task is the mutex holder, but not a good way of determining the
;  619	         * identity of the mutex holder, as the holder may change between the
;  620	         * following critical section exiting and the function returning. */
;  621	        taskENTER_CRITICAL();
;  622	        {
;  623	            if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
;  624	            {
;  625	                pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
;  626	            }
;  627	            else
;  628	            {
;  629	                pxReturn = NULL;
;  630	            }
;  631	        }
;  632	        taskEXIT_CRITICAL();
;  633	
;  634	        return pxReturn;
;  635	    } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
;  636	
;  637	#endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */
;  638	/*-----------------------------------------------------------*/
;  639	
;  640	#if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
;  641	
;  642	    TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
;  643	    {
;  644	        TaskHandle_t pxReturn;
;  645	
;  646	        configASSERT( xSemaphore );
;  647	
;  648	        /* Mutexes cannot be used in interrupt service routines, so the mutex
;  649	         * holder should not change in an ISR, and therefore a critical section is
;  650	         * not required here. */
;  651	        if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
;  652	        {
;  653	            pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
;  654	        }
;  655	        else
;  656	        {
;  657	            pxReturn = NULL;
;  658	        }
;  659	
;  660	        return pxReturn;
;  661	    } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
;  662	
;  663	#endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */
;  664	/*-----------------------------------------------------------*/
;  665	
;  666	#if ( configUSE_RECURSIVE_MUTEXES == 1 )
;  667	
;  668	    BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
;  669	    {
;  670	        BaseType_t xReturn;
;  671	        Queue_t * const pxMutex = ( Queue_t * ) xMutex;
;  672	
;  673	        configASSERT( pxMutex );
;  674	
;  675	        /* If this is the task that holds the mutex then xMutexHolder will not
;  676	         * change outside of this task.  If this task does not hold the mutex then
;  677	         * pxMutexHolder can never coincidentally equal the tasks handle, and as
;  678	         * this is the only condition we are interested in it does not matter if
;  679	         * pxMutexHolder is accessed simultaneously by another task.  Therefore no
;  680	         * mutual exclusion is required to test the pxMutexHolder variable. */
;  681	        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
;  682	        {
;  683	            traceGIVE_MUTEX_RECURSIVE( pxMutex );
;  684	
;  685	            /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
;  686	             * the task handle, therefore no underflow check is required.  Also,
;  687	             * uxRecursiveCallCount is only modified by the mutex holder, and as
;  688	             * there can only be one, no mutual exclusion is required to modify the
;  689	             * uxRecursiveCallCount member. */
;  690	            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
;  691	
;  692	            /* Has the recursive call count unwound to 0? */
;  693	            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
;  694	            {
;  695	                /* Return the mutex.  This will automatically unblock any other
;  696	                 * task that might be waiting to access the mutex. */
;  697	                ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
;  698	            }
;  699	            else
;  700	            {
;  701	                mtCOVERAGE_TEST_MARKER();
;  702	            }
;  703	
;  704	            xReturn = pdPASS;
;  705	        }
;  706	        else
;  707	        {
;  708	            /* The mutex cannot be given because the calling task is not the
;  709	             * holder. */
;  710	            xReturn = pdFAIL;
;  711	
;  712	            traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
;  713	        }
;  714	
;  715	        return xReturn;
;  716	    }
;  717	
;  718	#endif /* configUSE_RECURSIVE_MUTEXES */
;  719	/*-----------------------------------------------------------*/
;  720	
;  721	#if ( configUSE_RECURSIVE_MUTEXES == 1 )
;  722	
;  723	    BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,
;  724	                                         TickType_t xTicksToWait )
;  725	    {
;  726	        BaseType_t xReturn;
;  727	        Queue_t * const pxMutex = ( Queue_t * ) xMutex;
;  728	
;  729	        configASSERT( pxMutex );
;  730	
;  731	        /* Comments regarding mutual exclusion as per those within
;  732	         * xQueueGiveMutexRecursive(). */
;  733	
;  734	        traceTAKE_MUTEX_RECURSIVE( pxMutex );
;  735	
;  736	        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
;  737	        {
;  738	            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
;  739	            xReturn = pdPASS;
;  740	        }
;  741	        else
;  742	        {
;  743	            xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
;  744	
;  745	            /* pdPASS will only be returned if the mutex was successfully
;  746	             * obtained.  The calling task may have entered the Blocked state
;  747	             * before reaching here. */
;  748	            if( xReturn != pdFAIL )
;  749	            {
;  750	                ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
;  751	            }
;  752	            else
;  753	            {
;  754	                traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
;  755	            }
;  756	        }
;  757	
;  758	        return xReturn;
;  759	    }
;  760	
;  761	#endif /* configUSE_RECURSIVE_MUTEXES */
;  762	/*-----------------------------------------------------------*/
;  763	
;  764	#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;  765	
;  766	    QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount,
;  767	                                                       const UBaseType_t uxInitialCount,
;  768	                                                       StaticQueue_t * pxStaticQueue )
;  769	    {
;  770	        QueueHandle_t xHandle = NULL;
;  771	
;  772	        if( ( uxMaxCount != 0 ) &&
;  773	            ( uxInitialCount <= uxMaxCount ) )
;  774	        {
;  775	            xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
;  776	
;  777	            if( xHandle != NULL )
;  778	            {
;  779	                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
;  780	
;  781	                traceCREATE_COUNTING_SEMAPHORE();
;  782	            }
;  783	            else
;  784	            {
;  785	                traceCREATE_COUNTING_SEMAPHORE_FAILED();
;  786	            }
;  787	        }
;  788	        else
;  789	        {
;  790	            configASSERT( xHandle );
;  791	            mtCOVERAGE_TEST_MARKER();
;  792	        }
;  793	
;  794	        return xHandle;
;  795	    }
;  796	
;  797	#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
;  798	/*-----------------------------------------------------------*/
;  799	
;  800	#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
;  801	
;  802	    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
;  803	                                                 const UBaseType_t uxInitialCount )
;  804	    {
;  805	        QueueHandle_t xHandle = NULL;
;  806	
;  807	        if( ( uxMaxCount != 0 ) &&
;  808	            ( uxInitialCount <= uxMaxCount ) )
;  809	        {
;  810	            xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
;  811	
;  812	            if( xHandle != NULL )
;  813	            {
;  814	                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
;  815	
;  816	                traceCREATE_COUNTING_SEMAPHORE();
;  817	            }
;  818	            else
;  819	            {
;  820	                traceCREATE_COUNTING_SEMAPHORE_FAILED();
;  821	            }
;  822	        }
;  823	        else
;  824	        {
;  825	            configASSERT( xHandle );
;  826	            mtCOVERAGE_TEST_MARKER();
;  827	        }
;  828	
;  829	        return xHandle;
;  830	    }
;  831	
;  832	#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
;  833	/*-----------------------------------------------------------*/
;  834	
;  835	BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
;  836	                              const void * const pvItemToQueue,
;  837	                              TickType_t xTicksToWait,
;  838	                              const BaseType_t xCopyPosition )
;  839	{
_xQueueGenericSend:
.DEFINE "_xQueueGenericSend"

.VALUE _xQueueGenericSend

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xQueueGenericSend",839,"_xQueueGenericSend"

.LINE 839

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "pvItemToQueue"

.CLASS 65

.VALUE 9

.TYPE 193

.ENDEF

.DEFINE "xTicksToWait"

.CLASS 65

.VALUE 12

.TYPE 15

.ENDEF

.DEFINE "xCopyPosition"

.CLASS 65

.VALUE 18

.TYPE 4

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -3

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "xEntryTimeSet"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

.DEFINE "xYieldRequired"

.CLASS 65

.VALUE -12

.TYPE 4

.ENDEF

.DEFINE "xTimeOut"

.CLASS 65

.VALUE -19

.TAG "xTIME_OUT"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFED
	LD	SP,HL
;  840	    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
.LINE 840

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
;  841	    TimeOut_t xTimeOut;
;  842	    Queue_t * const pxQueue = xQueue;
.LINE 842

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
;  843	
;  844	    configASSERT( pxQueue );
;  845	    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;  846	    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
;  847	    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;  848	    {
;  849	        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;  850	    }
;  851	    #endif
;  852	
;  853	    /*lint -save -e904 This function relaxes the coding standard somewhat to
;  854	     * allow return statements within the function itself.  This is done in the
;  855	     * interest of execution time efficiency. */
;  856	    for( ; ; )
L_61:
.LINE 856

;  857	    {
;  858	        taskENTER_CRITICAL();
.LINE 858

	 di
;  859	        {
;  860	            /* Is there room on the queue now?  The running task must be the
;  861	             * highest priority task wanting to access the queue.  If the head item
;  862	             * in the queue is to be overwritten then it does not matter if the
;  863	             * queue is full. */
;  864	            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
.LINE 864

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%2F)
	LD	HL,(IY+%2C)
	OR	A,A
	SBC	HL,BC
	JR	C,L_49
	LD	BC,2
	LD	HL,(IX+%12)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_50
L_49:
;  865	            {
;  866	                traceQUEUE_SEND( pxQueue );
;  867	
;  868	                #if ( configUSE_QUEUE_SETS == 1 )
;  869	                {
;  870	                    const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
;  871	
;  872	                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;  873	
;  874	                    if( pxQueue->pxQueueSetContainer != NULL )
;  875	                    {
;  876	                        if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
;  877	                        {
;  878	                            /* Do not notify the queue set as an existing item
;  879	                             * was overwritten in the queue so the number of items
;  880	                             * in the queue has not changed. */
;  881	                            mtCOVERAGE_TEST_MARKER();
;  882	                        }
;  883	                        else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
;  884	                        {
;  885	                            /* The queue is a member of a queue set, and posting
;  886	                             * to the queue set caused a higher priority task to
;  887	                             * unblock. A context switch is required. */
;  888	                            queueYIELD_IF_USING_PREEMPTION();
;  889	                        }
;  890	                        else
;  891	                        {
;  892	                            mtCOVERAGE_TEST_MARKER();
;  893	                        }
;  894	                    }
;  895	                    else
;  896	                    {
;  897	                        /* If there was a task waiting for data to arrive on the
;  898	                         * queue then unblock it now. */
;  899	                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;  900	                        {
;  901	                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;  902	                            {
;  903	                                /* The unblocked task has a priority higher than
;  904	                                 * our own so yield immediately.  Yes it is ok to
;  905	                                 * do this from within the critical section - the
;  906	                                 * kernel takes care of that. */
;  907	                                queueYIELD_IF_USING_PREEMPTION();
;  908	                            }
;  909	                            else
;  910	                            {
;  911	                                mtCOVERAGE_TEST_MARKER();
;  912	                            }
;  913	                        }
;  914	                        else if( xYieldRequired != pdFALSE )
;  915	                        {
;  916	                            /* This path is a special case that will only get
;  917	                             * executed if the task was holding multiple mutexes
;  918	                             * and the mutexes were given back in an order that is
;  919	                             * different to that in which they were taken. */
;  920	                            queueYIELD_IF_USING_PREEMPTION();
;  921	                        }
;  922	                        else
;  923	                        {
;  924	                            mtCOVERAGE_TEST_MARKER();
;  925	                        }
;  926	                    }
;  927	                }
;  928	                #else /* configUSE_QUEUE_SETS */
;  929	                {
;  930	                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
.LINE 930

	LD	BC,(IX+%12)
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvCopyDataToQueue
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF4),HL
;  931	
;  932	                    /* If there was a task waiting for data to arrive on the
;  933	                     * queue then unblock it now. */
;  934	                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
.LINE 934

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%1C)
	CALL	__icmpzero
	JR	NZ,L_36
	LD	BC,1
	LD	(IX+%FFFFFFF7),BC
	JR	L_37
L_36:
	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
L_37:
	LD	HL,(IX+%FFFFFFF7)
	CALL	__icmpzero
	JR	NZ,L_43
;  935	                    {
;  936	                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
.LINE 936

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%1C
	CALL	_xTaskRemoveFromEventList
	POP	BC
	CALL	__icmpzero
	JR	Z,L_44
;  937	                        {
;  938	                            /* The unblocked task has a priority higher than
;  939	                             * our own so yield immediately.  Yes it is ok to do
;  940	                             * this from within the critical section - the kernel
;  941	                             * takes care of that. */
;  942	                            queueYIELD_IF_USING_PREEMPTION();
;  943	                        }
;  944	                        else
.LINE 944

	JR	L_44
;  945	                        {
;  946	                            mtCOVERAGE_TEST_MARKER();
;  947	                        }
;  948	                    }
;  949	                    else if( xYieldRequired != pdFALSE )
.LINE 949

L_43:
	LD	HL,(IX+%FFFFFFF4)
	CALL	__icmpzero
;  950	                    {
;  951	                        /* This path is a special case that will only get
;  952	                         * executed if the task was holding multiple mutexes and
;  953	                         * the mutexes were given back in an order that is
;  954	                         * different to that in which they were taken. */
;  955	                        queueYIELD_IF_USING_PREEMPTION();
;  956	                    }
;  957	                    else
.LINE 957

;  958	                    {
;  959	                        mtCOVERAGE_TEST_MARKER();
;  960	                    }
;  961	                }
L_44:
.LINE 961

;  962	                #endif /* configUSE_QUEUE_SETS */
;  963	
;  964	                taskEXIT_CRITICAL();
.LINE 964

	 ei
;  965	                return pdPASS;
.LINE 965

	LD	HL,1
	JR	L_63
;  966	            }
;  967	            else
L_50:
.LINE 967

;  968	            {
;  969	                if( xTicksToWait == ( TickType_t ) 0 )
.LINE 969

	LD	HL,(IX+%C)
	LD	E,(IX+%F)
	CALL	__lcmpzero
	JR	NZ,L_48
;  970	                {
;  971	                    /* The queue was full and no block time is specified (or
;  972	                     * the block time has expired) so leave now. */
;  973	                    taskEXIT_CRITICAL();
.LINE 973

	 ei
;  974	
;  975	                    /* Return to the original privilege level before exiting
;  976	                     * the function. */
;  977	                    traceQUEUE_SEND_FAILED( pxQueue );
;  978	                    return errQUEUE_FULL;
.LINE 978

	OR	A,A
	SBC	HL,HL
	JR	L_63
;  979	                }
;  980	                else if( xEntryTimeSet == pdFALSE )
L_48:
.LINE 980

	LD	HL,(IX+%FFFFFFFA)
	CALL	__icmpzero
	JR	NZ,L_46
;  981	                {
;  982	                    /* The queue was full and a block time was specified so
;  983	                     * configure the timeout structure. */
;  984	                    vTaskInternalSetTimeOutState( &xTimeOut );
.LINE 984

	PEA	IX+%FFFFFFED
	CALL	_vTaskInternalSetTimeOutState
	POP	BC
;  985	                    xEntryTimeSet = pdTRUE;
.LINE 985

	LD	BC,1
	LD	(IX+%FFFFFFFA),BC
;  986	                }
;  987	                else
L_46:
.LINE 987

;  988	                {
;  989	                    /* Entry time was already set. */
;  990	                    mtCOVERAGE_TEST_MARKER();
;  991	                }
;  992	            }
;  993	        }
;  994	        taskEXIT_CRITICAL();
.LINE 994

	 ei
;  995	
;  996	        /* Interrupts and other tasks can send to and receive from the queue
;  997	         * now the critical section has been exited. */
;  998	
;  999	        vTaskSuspendAll();
.LINE 999

	CALL	_vTaskSuspendAll
; 1000	        prvLockQueue( pxQueue );
.LINE 1000

	 di
	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%35)
	CP	A,%FFFFFFFF
	JR	NZ,L_54
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%35),%0
L_54:
	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%36)
	CP	A,%FFFFFFFF
	JR	NZ,L_55
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%36),%0
L_55:
	 ei
; 1001	
; 1002	        /* Update the timeout state to see if it has expired yet. */
; 1003	        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
.LINE 1003

	PEA	IX+%C
	PEA	IX+%FFFFFFED
	CALL	_xTaskCheckForTimeOut
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_60
; 1004	        {
; 1005	            if( prvIsQueueFull( pxQueue ) != pdFALSE )
.LINE 1005

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvIsQueueFull
	POP	BC
	CALL	__icmpzero
	JR	Z,L_58
; 1006	            {
; 1007	                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
; 1008	                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
.LINE 1008

	LD	C,(IX+%F)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%C)
	PUSH	BC
	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%C
	CALL	_vTaskPlaceOnEventList
	POP	BC
	POP	BC
	POP	BC
; 1009	
; 1010	                /* Unlocking the queue means queue events can effect the
; 1011	                 * event list. It is possible that interrupts occurring now
; 1012	                 * remove this task from the event list again - but as the
; 1013	                 * scheduler is suspended the task will go onto the pending
; 1014	                 * ready list instead of the actual ready list. */
; 1015	                prvUnlockQueue( pxQueue );
.LINE 1015

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvUnlockQueue
	POP	BC
; 1016	
; 1017	                /* Resuming the scheduler will move tasks from the pending
; 1018	                 * ready list into the ready list - so it is feasible that this
; 1019	                 * task is already in the ready list before it yields - in which
; 1020	                 * case the yield will not cause a context switch unless there
; 1021	                 * is also a higher priority task in the pending ready list. */
; 1022	                if( xTaskResumeAll() == pdFALSE )
.LINE 1022

	CALL	_xTaskResumeAll
	CALL	__icmpzero
	JR	NZ,L_61
; 1023	                {
; 1024	                    portYIELD_WITHIN_API();
.LINE 1024

	CALL	_vPortYield
; 1025	                }
; 1026	            }
; 1027	            else
.LINE 1027

	JR	L_61
L_58:
; 1028	            {
; 1029	                /* Try again. */
; 1030	                prvUnlockQueue( pxQueue );
.LINE 1030

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvUnlockQueue
	POP	BC
; 1031	                ( void ) xTaskResumeAll();
.LINE 1031

	CALL	_xTaskResumeAll
; 1032	            }
; 1033	        }
; 1034	        else
.LINE 1034

	JR	L_61
L_60:
; 1035	        {
; 1036	            /* The timeout has expired. */
; 1037	            prvUnlockQueue( pxQueue );
.LINE 1037

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvUnlockQueue
	POP	BC
; 1038	            ( void ) xTaskResumeAll();
.LINE 1038

	CALL	_xTaskResumeAll
; 1039	
; 1040	            traceQUEUE_SEND_FAILED( pxQueue );
; 1041	            return errQUEUE_FULL;
.LINE 1041

	OR	A,A
	SBC	HL,HL
; 1042	        }
; 1043	    } /*lint -restore */
.LINE 1043

; 1044	}
L_63:
.LINE 1044

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xQueueGenericSend ***************************
;Name                         Addr/Register   Size   Type
;_vPortYield                         IMPORT  -----   function
;_xTaskResumeAll                     IMPORT  -----   function
;_prvUnlockQueue                     STATIC  -----   function
;_vTaskPlaceOnEventList              IMPORT  -----   function
;_prvIsQueueFull                     STATIC  -----   function
;_xTaskCheckForTimeOut               IMPORT  -----   function
;_vTaskSuspendAll                    IMPORT  -----   function
;_vTaskInternalSetTimeOutState       IMPORT  -----   function
;_xTaskRemoveFromEventList           IMPORT  -----   function
;_prvCopyDataToQueue                 STATIC  -----   function
;xTimeOut                             IX-19      7   variable
;xYieldRequired                       IX-12      3   variable
;temp34                                IX-9      3   variable
;xEntryTimeSet                         IX-6      3   variable
;pxQueue                               IX-3      3   variable
;xCopyPosition                        IX+18      3   parameter
;xTicksToWait                         IX+12      4   parameter
;pvItemToQueue                         IX+9      3   parameter
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 40 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xQueueGenericSend",1044,"_xQueueGenericSend"
; 1045	/*-----------------------------------------------------------*/
; 1046	
; 1047	BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
; 1048	                                     const void * const pvItemToQueue,
; 1049	                                     BaseType_t * const pxHigherPriorityTaskWoken,
; 1050	                                     const BaseType_t xCopyPosition )
; 1051	{
_xQueueGenericSendFromISR:
.DEFINE "_xQueueGenericSendFromISR"

.VALUE _xQueueGenericSendFromISR

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xQueueGenericSendFromISR",1051,"_xQueueGenericSendFromISR"

.LINE 1051

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "pvItemToQueue"

.CLASS 65

.VALUE 9

.TYPE 193

.ENDEF

.DEFINE "pxHigherPriorityTaskWoken"

.CLASS 65

.VALUE 12

.TYPE 36

.ENDEF

.DEFINE "xCopyPosition"

.CLASS 65

.VALUE 15

.TYPE 4

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -3

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "cTxLock"

.CLASS 65

.VALUE -4

.TYPE 2

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -7

.TYPE 4

.ENDEF

.DEFINE "uxNumberOfTasks"

.CLASS 65

.VALUE -13

.TYPE 14

.ENDEF

.DEFINE "uxPreviousMessagesWaiting"

.CLASS 65

.VALUE -16

.TYPE 14

.ENDEF

.DEFINE "uxSavedInterruptStatus"

.CLASS 65

.VALUE -19

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFED
	LD	SP,HL
; 1052	    BaseType_t xReturn;
; 1053	    UBaseType_t uxSavedInterruptStatus;
; 1054	    Queue_t * const pxQueue = xQueue;
.LINE 1054

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 1055	
; 1056	    configASSERT( pxQueue );
; 1057	    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
; 1058	    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
; 1059	
; 1060	    /* RTOS ports that support interrupt nesting have the concept of a maximum
; 1061	     * system call (or maximum API call) interrupt priority.  Interrupts that are
; 1062	     * above the maximum system call priority are kept permanently enabled, even
; 1063	     * when the RTOS kernel is in a critical section, but cannot make any calls to
; 1064	     * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
; 1065	     * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
; 1066	     * failure if a FreeRTOS API function is called from an interrupt that has been
; 1067	     * assigned a priority above the configured maximum system call priority.
; 1068	     * Only FreeRTOS functions that end in FromISR can be called from interrupts
; 1069	     * that have been assigned a priority at or (logically) below the maximum
; 1070	     * system call interrupt priority.  FreeRTOS maintains a separate interrupt
; 1071	     * safe API to ensure interrupt entry is as fast and as simple as possible.
; 1072	     * More information (albeit Cortex-M specific) is provided on the following
; 1073	     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
; 1074	    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
; 1075	
; 1076	    /* Similar to xQueueGenericSend, except without blocking if there is no room
; 1077	     * in the queue.  Also don't directly wake a task that was blocked on a queue
; 1078	     * read, instead return a flag to say whether a context switch is required or
; 1079	     * not (i.e. has a task with a higher priority than us been woken by this
; 1080	     * post). */
; 1081	    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
.LINE 1081

	LD	BC,0
	LD	(IX+%FFFFFFED),BC
; 1082	    {
; 1083	        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
.LINE 1083

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%2F)
	LD	HL,(IY+%2C)
	OR	A,A
	SBC	HL,BC
	JR	C,L_81
	LD	BC,2
	LD	HL,(IX+%F)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_82
L_81:
; 1084	        {
; 1085	            const int8_t cTxLock = pxQueue->cTxLock;
.LINE 1085

	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%36)
	LD	(IX+%FFFFFFFC),A
; 1086	            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
.LINE 1086

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%2C)
	LD	(IX+%FFFFFFF0),BC
; 1087	
; 1088	            traceQUEUE_SEND_FROM_ISR( pxQueue );
; 1089	
; 1090	            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
; 1091	             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
; 1092	             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
; 1093	             *  called here even though the disinherit function does not check if
; 1094	             *  the scheduler is suspended before accessing the ready lists. */
; 1095	            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
.LINE 1095

	LD	BC,(IX+%F)
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvCopyDataToQueue
	POP	BC
	POP	BC
	POP	BC
; 1096	
; 1097	            /* The event list is not altered if the queue is locked.  This will
; 1098	             * be done when the queue is unlocked later. */
; 1099	            if( cTxLock == queueUNLOCKED )
.LINE 1099

	LD	A,(IX+%FFFFFFFC)
	CP	A,%FFFFFFFF
	JR	NZ,L_79
; 1100	            {
; 1101	                #if ( configUSE_QUEUE_SETS == 1 )
; 1102	                {
; 1103	                    if( pxQueue->pxQueueSetContainer != NULL )
; 1104	                    {
; 1105	                        if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
; 1106	                        {
; 1107	                            /* Do not notify the queue set as an existing item
; 1108	                             * was overwritten in the queue so the number of items
; 1109	                             * in the queue has not changed. */
; 1110	                            mtCOVERAGE_TEST_MARKER();
; 1111	                        }
; 1112	                        else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
; 1113	                        {
; 1114	                            /* The queue is a member of a queue set, and posting
; 1115	                             * to the queue set caused a higher priority task to
; 1116	                             * unblock.  A context switch is required. */
; 1117	                            if( pxHigherPriorityTaskWoken != NULL )
; 1118	                            {
; 1119	                                *pxHigherPriorityTaskWoken = pdTRUE;
; 1120	                            }
; 1121	                            else
; 1122	                            {
; 1123	                                mtCOVERAGE_TEST_MARKER();
; 1124	                            }
; 1125	                        }
; 1126	                        else
; 1127	                        {
; 1128	                            mtCOVERAGE_TEST_MARKER();
; 1129	                        }
; 1130	                    }
; 1131	                    else
; 1132	                    {
; 1133	                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
; 1134	                        {
; 1135	                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
; 1136	                            {
; 1137	                                /* The task waiting has a higher priority so
; 1138	                                 *  record that a context switch is required. */
; 1139	                                if( pxHigherPriorityTaskWoken != NULL )
; 1140	                                {
; 1141	                                    *pxHigherPriorityTaskWoken = pdTRUE;
; 1142	                                }
; 1143	                                else
; 1144	                                {
; 1145	                                    mtCOVERAGE_TEST_MARKER();
; 1146	                                }
; 1147	                            }
; 1148	                            else
; 1149	                            {
; 1150	                                mtCOVERAGE_TEST_MARKER();
; 1151	                            }
; 1152	                        }
; 1153	                        else
; 1154	                        {
; 1155	                            mtCOVERAGE_TEST_MARKER();
; 1156	                        }
; 1157	                    }
; 1158	                }
; 1159	                #else /* configUSE_QUEUE_SETS */
; 1160	                {
; 1161	                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
.LINE 1161

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%1C)
	CALL	__icmpzero
	JR	NZ,L_67
	LD	BC,1
	LD	(IX+%FFFFFFF6),BC
	JR	L_68
L_67:
	LD	BC,0
	LD	(IX+%FFFFFFF6),BC
L_68:
	LD	HL,(IX+%FFFFFFF6)
	CALL	__icmpzero
	JR	NZ,L_80
; 1162	                    {
; 1163	                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
.LINE 1163

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%1C
	CALL	_xTaskRemoveFromEventList
	POP	BC
	CALL	__icmpzero
	JR	Z,L_80
; 1164	                        {
; 1165	                            /* The task waiting has a higher priority so record that a
; 1166	                             * context switch is required. */
; 1167	                            if( pxHigherPriorityTaskWoken != NULL )
.LINE 1167

	LD	HL,(IX+%C)
	CALL	__icmpzero
	JR	Z,L_80
; 1168	                            {
; 1169	                                *pxHigherPriorityTaskWoken = pdTRUE;
.LINE 1169

	LD	HL,(IX+%C)
	LD	BC,1
	LD	(HL),BC
; 1170	                            }
; 1171	                            else
.LINE 1171

; 1172	                            {
; 1173	                                mtCOVERAGE_TEST_MARKER();
; 1174	                            }
; 1175	                        }
; 1176	                        else
.LINE 1176

; 1177	                        {
; 1178	                            mtCOVERAGE_TEST_MARKER();
; 1179	                        }
; 1180	                    }
; 1181	                    else
.LINE 1181

; 1182	                    {
; 1183	                        mtCOVERAGE_TEST_MARKER();
; 1184	                    }
; 1185	
; 1186	                    /* Not used in this path. */
; 1187	                    ( void ) uxPreviousMessagesWaiting;
; 1188	                }
; 1189	                #endif /* configUSE_QUEUE_SETS */
; 1190	            }
; 1191	            else
.LINE 1191

	JR	L_80
L_79:
; 1192	            {
; 1193	                /* Increment the lock count so the task that unlocks the queue
; 1194	                 * knows that data was posted while it was locked. */
; 1195	                prvIncrementQueueTxLock( pxQueue, cTxLock );
.LINE 1195

	CALL	_uxTaskGetNumberOfTasks
	LD	(IX+%FFFFFFF3),HL
	LD	A,(IX+%FFFFFFFC)
	SEXT	HL
	LD	L,(IX+%FFFFFFFC)
	LD	BC,(IX+%FFFFFFF3)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_80
	LD	A,(IX+%FFFFFFFC)
	INC	A
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%36),A
; 1196	            }
L_80:
.LINE 1196

; 1197	
; 1198	            xReturn = pdPASS;
.LINE 1198

	LD	BC,1
	LD	(IX+%FFFFFFF9),BC
; 1199	        }
; 1200	        else
.LINE 1200

	JR	L_83
L_82:
; 1201	        {
; 1202	            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
; 1203	            xReturn = errQUEUE_FULL;
.LINE 1203

	LD	BC,0
	LD	(IX+%FFFFFFF9),BC
; 1204	        }
; 1205	    }
L_83:
.LINE 1205

; 1206	    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
; 1207	
; 1208	    return xReturn;
.LINE 1208

	LD	HL,(IX+%FFFFFFF9)
; 1209	}
.LINE 1209

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xQueueGenericSendFromISR ***************************
;Name                         Addr/Register   Size   Type
;_uxTaskGetNumberOfTasks             IMPORT  -----   function
;_xTaskRemoveFromEventList           IMPORT  -----   function
;_prvCopyDataToQueue                 STATIC  -----   function
;uxSavedInterruptStatus               IX-19      3   variable
;uxPreviousMessagesWaiting            IX-16      3   variable
;uxNumberOfTasks                      IX-13      3   variable
;temp65                               IX-10      3   variable
;xReturn                               IX-7      3   variable
;cTxLock                               IX-4      1   variable
;pxQueue                               IX-3      3   variable
;xCopyPosition                        IX+15      3   parameter
;pxHigherPriorityTaskWoken            IX+12      3   parameter
;pvItemToQueue                         IX+9      3   parameter
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 37 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xQueueGenericSendFromISR",1209,"_xQueueGenericSendFromISR"
; 1210	/*-----------------------------------------------------------*/
; 1211	
; 1212	BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
; 1213	                              BaseType_t * const pxHigherPriorityTaskWoken )
; 1214	{
_xQueueGiveFromISR:
.DEFINE "_xQueueGiveFromISR"

.VALUE _xQueueGiveFromISR

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xQueueGiveFromISR",1214,"_xQueueGiveFromISR"

.LINE 1214

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "pxHigherPriorityTaskWoken"

.CLASS 65

.VALUE 9

.TYPE 36

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -3

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "cTxLock"

.CLASS 65

.VALUE -4

.TYPE 2

.ENDEF

.DEFINE "uxMessagesWaiting"

.CLASS 65

.VALUE -7

.TYPE 14

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -10

.TYPE 4

.ENDEF

.DEFINE "uxNumberOfTasks"

.CLASS 65

.VALUE -16

.TYPE 14

.ENDEF

.DEFINE "uxSavedInterruptStatus"

.CLASS 65

.VALUE -19

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFED
	LD	SP,HL
; 1215	    BaseType_t xReturn;
; 1216	    UBaseType_t uxSavedInterruptStatus;
; 1217	    Queue_t * const pxQueue = xQueue;
.LINE 1217

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 1218	
; 1219	    /* Similar to xQueueGenericSendFromISR() but used with semaphores where the
; 1220	     * item size is 0.  Don't directly wake a task that was blocked on a queue
; 1221	     * read, instead return a flag to say whether a context switch is required or
; 1222	     * not (i.e. has a task with a higher priority than us been woken by this
; 1223	     * post). */
; 1224	
; 1225	    configASSERT( pxQueue );
; 1226	
; 1227	    /* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
; 1228	     * if the item size is not 0. */
; 1229	    configASSERT( pxQueue->uxItemSize == 0 );
; 1230	
; 1231	    /* Normally a mutex would not be given from an interrupt, especially if
; 1232	     * there is a mutex holder, as priority inheritance makes no sense for an
; 1233	     * interrupts, only tasks. */
; 1234	    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
; 1235	
; 1236	    /* RTOS ports that support interrupt nesting have the concept of a maximum
; 1237	     * system call (or maximum API call) interrupt priority.  Interrupts that are
; 1238	     * above the maximum system call priority are kept permanently enabled, even
; 1239	     * when the RTOS kernel is in a critical section, but cannot make any calls to
; 1240	     * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
; 1241	     * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
; 1242	     * failure if a FreeRTOS API function is called from an interrupt that has been
; 1243	     * assigned a priority above the configured maximum system call priority.
; 1244	     * Only FreeRTOS functions that end in FromISR can be called from interrupts
; 1245	     * that have been assigned a priority at or (logically) below the maximum
; 1246	     * system call interrupt priority.  FreeRTOS maintains a separate interrupt
; 1247	     * safe API to ensure interrupt entry is as fast and as simple as possible.
; 1248	     * More information (albeit Cortex-M specific) is provided on the following
; 1249	     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
; 1250	    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
; 1251	
; 1252	    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
.LINE 1252

	LD	BC,0
	LD	(IX+%FFFFFFED),BC
; 1253	    {
; 1254	        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
.LINE 1254

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%2C)
	LD	(IX+%FFFFFFF9),BC
; 1255	
; 1256	        /* When the queue is used to implement a semaphore no data is ever
; 1257	         * moved through the queue but it is still valid to see if the queue 'has
; 1258	         * space'. */
; 1259	        if( uxMessagesWaiting < pxQueue->uxLength )
.LINE 1259

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%2F)
	LD	HL,(IX+%FFFFFFF9)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_101
; 1260	        {
; 1261	            const int8_t cTxLock = pxQueue->cTxLock;
.LINE 1261

	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%36)
	LD	(IX+%FFFFFFFC),A
; 1262	
; 1263	            traceQUEUE_SEND_FROM_ISR( pxQueue );
; 1264	
; 1265	            /* A task can only have an inherited priority if it is a mutex
; 1266	             * holder - and if there is a mutex holder then the mutex cannot be
; 1267	             * given from an ISR.  As this is the ISR version of the function it
; 1268	             * can be assumed there is no mutex holder and no need to determine if
; 1269	             * priority disinheritance is needed.  Simply increase the count of
; 1270	             * messages (semaphores) available. */
; 1271	            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
.LINE 1271

	LD	BC,(IX+%FFFFFFF9)
	INC	BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%2C),BC
; 1272	
; 1273	            /* The event list is not altered if the queue is locked.  This will
; 1274	             * be done when the queue is unlocked later. */
; 1275	            if( cTxLock == queueUNLOCKED )
.LINE 1275

	LD	A,(IX+%FFFFFFFC)
	CP	A,%FFFFFFFF
	JR	NZ,L_98
; 1276	            {
; 1277	                #if ( configUSE_QUEUE_SETS == 1 )
; 1278	                {
; 1279	                    if( pxQueue->pxQueueSetContainer != NULL )
; 1280	                    {
; 1281	                        if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
; 1282	                        {
; 1283	                            /* The semaphore is a member of a queue set, and
; 1284	                             * posting to the queue set caused a higher priority
; 1285	                             * task to unblock.  A context switch is required. */
; 1286	                            if( pxHigherPriorityTaskWoken != NULL )
; 1287	                            {
; 1288	                                *pxHigherPriorityTaskWoken = pdTRUE;
; 1289	                            }
; 1290	                            else
; 1291	                            {
; 1292	                                mtCOVERAGE_TEST_MARKER();
; 1293	                            }
; 1294	                        }
; 1295	                        else
; 1296	                        {
; 1297	                            mtCOVERAGE_TEST_MARKER();
; 1298	                        }
; 1299	                    }
; 1300	                    else
; 1301	                    {
; 1302	                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
; 1303	                        {
; 1304	                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
; 1305	                            {
; 1306	                                /* The task waiting has a higher priority so
; 1307	                                 *  record that a context switch is required. */
; 1308	                                if( pxHigherPriorityTaskWoken != NULL )
; 1309	                                {
; 1310	                                    *pxHigherPriorityTaskWoken = pdTRUE;
; 1311	                                }
; 1312	                                else
; 1313	                                {
; 1314	                                    mtCOVERAGE_TEST_MARKER();
; 1315	                                }
; 1316	                            }
; 1317	                            else
; 1318	                            {
; 1319	                                mtCOVERAGE_TEST_MARKER();
; 1320	                            }
; 1321	                        }
; 1322	                        else
; 1323	                        {
; 1324	                            mtCOVERAGE_TEST_MARKER();
; 1325	                        }
; 1326	                    }
; 1327	                }
; 1328	                #else /* configUSE_QUEUE_SETS */
; 1329	                {
; 1330	                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
.LINE 1330

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%1C)
	CALL	__icmpzero
	JR	NZ,L_87
	LD	BC,1
	LD	(IX+%FFFFFFF3),BC
	JR	L_88
L_87:
	LD	BC,0
	LD	(IX+%FFFFFFF3),BC
L_88:
	LD	HL,(IX+%FFFFFFF3)
	CALL	__icmpzero
	JR	NZ,L_99
; 1331	                    {
; 1332	                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
.LINE 1332

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%1C
	CALL	_xTaskRemoveFromEventList
	POP	BC
	CALL	__icmpzero
	JR	Z,L_99
; 1333	                        {
; 1334	                            /* The task waiting has a higher priority so record that a
; 1335	                             * context switch is required. */
; 1336	                            if( pxHigherPriorityTaskWoken != NULL )
.LINE 1336

	LD	HL,(IX+%9)
	CALL	__icmpzero
	JR	Z,L_99
; 1337	                            {
; 1338	                                *pxHigherPriorityTaskWoken = pdTRUE;
.LINE 1338

	LD	HL,(IX+%9)
	LD	BC,1
	LD	(HL),BC
; 1339	                            }
; 1340	                            else
.LINE 1340

	JR	L_99
; 1341	                            {
; 1342	                                mtCOVERAGE_TEST_MARKER();
; 1343	                            }
; 1344	                        }
; 1345	                        else
.LINE 1345

; 1346	                        {
; 1347	                            mtCOVERAGE_TEST_MARKER();
; 1348	                        }
; 1349	                    }
; 1350	                    else
.LINE 1350

	JR	L_99
; 1351	                    {
; 1352	                        mtCOVERAGE_TEST_MARKER();
; 1353	                    }
; 1354	                }
; 1355	                #endif /* configUSE_QUEUE_SETS */
; 1356	            }
; 1357	            else
.LINE 1357

L_98:
; 1358	            {
; 1359	                /* Increment the lock count so the task that unlocks the queue
; 1360	                 * knows that data was posted while it was locked. */
; 1361	                prvIncrementQueueTxLock( pxQueue, cTxLock );
.LINE 1361

	CALL	_uxTaskGetNumberOfTasks
	LD	(IX+%FFFFFFF0),HL
	LD	A,(IX+%FFFFFFFC)
	SEXT	HL
	LD	L,(IX+%FFFFFFFC)
	LD	BC,(IX+%FFFFFFF0)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_99
	LD	A,(IX+%FFFFFFFC)
	INC	A
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%36),A
; 1362	            }
L_99:
.LINE 1362

; 1363	
; 1364	            xReturn = pdPASS;
.LINE 1364

	LD	BC,1
	LD	(IX+%FFFFFFF6),BC
; 1365	        }
; 1366	        else
.LINE 1366

	JR	L_102
L_101:
; 1367	        {
; 1368	            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
; 1369	            xReturn = errQUEUE_FULL;
.LINE 1369

	LD	BC,0
	LD	(IX+%FFFFFFF6),BC
; 1370	        }
; 1371	    }
L_102:
.LINE 1371

; 1372	    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
; 1373	
; 1374	    return xReturn;
.LINE 1374

	LD	HL,(IX+%FFFFFFF6)
; 1375	}
.LINE 1375

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xQueueGiveFromISR ***************************
;Name                         Addr/Register   Size   Type
;_uxTaskGetNumberOfTasks             IMPORT  -----   function
;_xTaskRemoveFromEventList           IMPORT  -----   function
;uxSavedInterruptStatus               IX-19      3   variable
;uxNumberOfTasks                      IX-16      3   variable
;temp85                               IX-13      3   variable
;xReturn                              IX-10      3   variable
;uxMessagesWaiting                     IX-7      3   variable
;cTxLock                               IX-4      1   variable
;pxQueue                               IX-3      3   variable
;pxHigherPriorityTaskWoken             IX+9      3   parameter
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 31 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xQueueGiveFromISR",1375,"_xQueueGiveFromISR"
; 1376	/*-----------------------------------------------------------*/
; 1377	
; 1378	BaseType_t xQueueReceive( QueueHandle_t xQueue,
; 1379	                          void * const pvBuffer,
; 1380	                          TickType_t xTicksToWait )
; 1381	{
_xQueueReceive:
.DEFINE "_xQueueReceive"

.VALUE _xQueueReceive

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xQueueReceive",1381,"_xQueueReceive"

.LINE 1381

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "pvBuffer"

.CLASS 65

.VALUE 9

.TYPE 33

.ENDEF

.DEFINE "xTicksToWait"

.CLASS 65

.VALUE 12

.TYPE 15

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -3

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "xEntryTimeSet"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

.DEFINE "uxMessagesWaiting"

.CLASS 65

.VALUE -9

.TYPE 14

.ENDEF

.DEFINE "xTimeOut"

.CLASS 65

.VALUE -19

.TAG "xTIME_OUT"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFED
	LD	SP,HL
; 1382	    BaseType_t xEntryTimeSet = pdFALSE;
.LINE 1382

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
; 1383	    TimeOut_t xTimeOut;
; 1384	    Queue_t * const pxQueue = xQueue;
.LINE 1384

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 1385	
; 1386	    /* Check the pointer is not NULL. */
; 1387	    configASSERT( ( pxQueue ) );
; 1388	
; 1389	    /* The buffer into which data is received can only be NULL if the data size
; 1390	     * is zero (so no data is copied into the buffer). */
; 1391	    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
; 1392	
; 1393	    /* Cannot block if the scheduler is suspended. */
; 1394	    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
; 1395	    {
; 1396	        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
; 1397	    }
; 1398	    #endif
; 1399	
; 1400	    /*lint -save -e904  This function relaxes the coding standard somewhat to
; 1401	     * allow return statements within the function itself.  This is done in the
; 1402	     * interest of execution time efficiency. */
; 1403	    for( ; ; )
L_132:
.LINE 1403

; 1404	    {
; 1405	        taskENTER_CRITICAL();
.LINE 1405

	 di
; 1406	        {
; 1407	            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
.LINE 1407

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%2C)
	LD	(IX+%FFFFFFF7),BC
; 1408	
; 1409	            /* Is there data in the queue now?  To be running the calling task
; 1410	             * must be the highest priority task wanting to access the queue. */
; 1411	            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
.LINE 1411

	LD	BC,(IX+%FFFFFFF7)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_118
; 1412	            {
; 1413	                /* Data available, remove one item. */
; 1414	                prvCopyDataFromQueue( pxQueue, pvBuffer );
.LINE 1414

	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvCopyDataFromQueue
	POP	BC
	POP	BC
; 1415	                traceQUEUE_RECEIVE( pxQueue );
; 1416	                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
.LINE 1416

	LD	IY,(IX+%FFFFFFF7)
	LEA	BC,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%2C),BC
; 1417	
; 1418	                /* There is now space in the queue, were any tasks waiting to
; 1419	                 * post to the queue?  If so, unblock the highest priority waiting
; 1420	                 * task. */
; 1421	                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
.LINE 1421

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%C)
	CALL	__icmpzero
	JR	NZ,L_106
	LD	BC,1
	LD	(IX+%FFFFFFF4),BC
	JR	L_107
L_106:
	LD	BC,0
	LD	(IX+%FFFFFFF4),BC
L_107:
	LD	HL,(IX+%FFFFFFF4)
	CALL	__icmpzero
	JR	NZ,L_111
; 1422	                {
; 1423	                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
.LINE 1423

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%C
	CALL	_xTaskRemoveFromEventList
	POP	BC
	CALL	__icmpzero
; 1424	                    {
; 1425	                        queueYIELD_IF_USING_PREEMPTION();
; 1426	                    }
; 1427	                    else
.LINE 1427

; 1428	                    {
; 1429	                        mtCOVERAGE_TEST_MARKER();
; 1430	                    }
; 1431	                }
; 1432	                else
L_111:
.LINE 1432

; 1433	                {
; 1434	                    mtCOVERAGE_TEST_MARKER();
; 1435	                }
; 1436	
; 1437	                taskEXIT_CRITICAL();
.LINE 1437

	 ei
; 1438	                return pdPASS;
.LINE 1438

	LD	HL,1
	JR	L_134
; 1439	            }
; 1440	            else
L_118:
.LINE 1440

; 1441	            {
; 1442	                if( xTicksToWait == ( TickType_t ) 0 )
.LINE 1442

	LD	HL,(IX+%C)
	LD	E,(IX+%F)
	CALL	__lcmpzero
	JR	NZ,L_116
; 1443	                {
; 1444	                    /* The queue was empty and no block time is specified (or
; 1445	                     * the block time has expired) so leave now. */
; 1446	                    taskEXIT_CRITICAL();
.LINE 1446

	 ei
; 1447	                    traceQUEUE_RECEIVE_FAILED( pxQueue );
; 1448	                    return errQUEUE_EMPTY;
.LINE 1448

	OR	A,A
	SBC	HL,HL
	JR	L_134
; 1449	                }
; 1450	                else if( xEntryTimeSet == pdFALSE )
L_116:
.LINE 1450

	LD	HL,(IX+%FFFFFFFA)
	CALL	__icmpzero
	JR	NZ,L_114
; 1451	                {
; 1452	                    /* The queue was empty and a block time was specified so
; 1453	                     * configure the timeout structure. */
; 1454	                    vTaskInternalSetTimeOutState( &xTimeOut );
.LINE 1454

	PEA	IX+%FFFFFFED
	CALL	_vTaskInternalSetTimeOutState
	POP	BC
; 1455	                    xEntryTimeSet = pdTRUE;
.LINE 1455

	LD	BC,1
	LD	(IX+%FFFFFFFA),BC
; 1456	                }
; 1457	                else
L_114:
.LINE 1457

; 1458	                {
; 1459	                    /* Entry time was already set. */
; 1460	                    mtCOVERAGE_TEST_MARKER();
; 1461	                }
; 1462	            }
; 1463	        }
; 1464	        taskEXIT_CRITICAL();
.LINE 1464

	 ei
; 1465	
; 1466	        /* Interrupts and other tasks can send to and receive from the queue
; 1467	         * now the critical section has been exited. */
; 1468	
; 1469	        vTaskSuspendAll();
.LINE 1469

	CALL	_vTaskSuspendAll
; 1470	        prvLockQueue( pxQueue );
.LINE 1470

	 di
	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%35)
	CP	A,%FFFFFFFF
	JR	NZ,L_122
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%35),%0
L_122:
	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%36)
	CP	A,%FFFFFFFF
	JR	NZ,L_123
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%36),%0
L_123:
	 ei
; 1471	
; 1472	        /* Update the timeout state to see if it has expired yet. */
; 1473	        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
.LINE 1473

	PEA	IX+%C
	PEA	IX+%FFFFFFED
	CALL	_xTaskCheckForTimeOut
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_131
; 1474	        {
; 1475	            /* The timeout has not expired.  If the queue is still empty place
; 1476	             * the task on the list of tasks waiting to receive from the queue. */
; 1477	            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
.LINE 1477

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvIsQueueEmpty
	POP	BC
	CALL	__icmpzero
	JR	Z,L_127
; 1478	            {
; 1479	                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
; 1480	                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
.LINE 1480

	LD	C,(IX+%F)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%C)
	PUSH	BC
	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%1C
	CALL	_vTaskPlaceOnEventList
	POP	BC
	POP	BC
	POP	BC
; 1481	                prvUnlockQueue( pxQueue );
.LINE 1481

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvUnlockQueue
	POP	BC
; 1482	
; 1483	                if( xTaskResumeAll() == pdFALSE )
.LINE 1483

	CALL	_xTaskResumeAll
	CALL	__icmpzero
	JR	NZ,L_132
; 1484	                {
; 1485	                    portYIELD_WITHIN_API();
.LINE 1485

	CALL	_vPortYield
; 1486	                }
; 1487	                else
.LINE 1487

	JR	L_132
; 1488	                {
; 1489	                    mtCOVERAGE_TEST_MARKER();
; 1490	                }
; 1491	            }
; 1492	            else
.LINE 1492

L_127:
; 1493	            {
; 1494	                /* The queue contains data again.  Loop back to try and read the
; 1495	                 * data. */
; 1496	                prvUnlockQueue( pxQueue );
.LINE 1496

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvUnlockQueue
	POP	BC
; 1497	                ( void ) xTaskResumeAll();
.LINE 1497

	CALL	_xTaskResumeAll
; 1498	            }
; 1499	        }
; 1500	        else
.LINE 1500

	JR	L_132
L_131:
; 1501	        {
; 1502	            /* Timed out.  If there is no data in the queue exit, otherwise loop
; 1503	             * back and attempt to read the data. */
; 1504	            prvUnlockQueue( pxQueue );
.LINE 1504

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvUnlockQueue
	POP	BC
; 1505	            ( void ) xTaskResumeAll();
.LINE 1505

	CALL	_xTaskResumeAll
; 1506	
; 1507	            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
.LINE 1507

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvIsQueueEmpty
	POP	BC
	CALL	__icmpzero
	JR	Z,L_129
; 1508	            {
; 1509	                traceQUEUE_RECEIVE_FAILED( pxQueue );
; 1510	                return errQUEUE_EMPTY;
.LINE 1510

	OR	A,A
	SBC	HL,HL
	JR	L_134
; 1511	            }
; 1512	            else
L_129:
.LINE 1512

; 1513	            {
; 1514	                mtCOVERAGE_TEST_MARKER();
; 1515	            }
; 1516	        }
; 1517	    } /*lint -restore */
L_133:
.LINE 1517

	JR	L_132
; 1518	}
L_134:
.LINE 1518

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xQueueReceive ***************************
;Name                         Addr/Register   Size   Type
;_vPortYield                         IMPORT  -----   function
;_xTaskResumeAll                     IMPORT  -----   function
;_prvUnlockQueue                     STATIC  -----   function
;_vTaskPlaceOnEventList              IMPORT  -----   function
;_prvIsQueueEmpty                    STATIC  -----   function
;_xTaskCheckForTimeOut               IMPORT  -----   function
;_vTaskSuspendAll                    IMPORT  -----   function
;_vTaskInternalSetTimeOutState       IMPORT  -----   function
;_xTaskRemoveFromEventList           IMPORT  -----   function
;_prvCopyDataFromQueue               STATIC  -----   function
;xTimeOut                             IX-19      7   variable
;temp104                              IX-12      3   variable
;uxMessagesWaiting                     IX-9      3   variable
;xEntryTimeSet                         IX-6      3   variable
;pxQueue                               IX-3      3   variable
;xTicksToWait                         IX+12      4   parameter
;pvBuffer                              IX+9      3   parameter
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 37 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xQueueReceive",1518,"_xQueueReceive"
; 1519	/*-----------------------------------------------------------*/
; 1520	
; 1521	BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
; 1522	                                TickType_t xTicksToWait )
; 1523	{
_xQueueSemaphoreTake:
.DEFINE "_xQueueSemaphoreTake"

.VALUE _xQueueSemaphoreTake

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xQueueSemaphoreTake",1523,"_xQueueSemaphoreTake"

.LINE 1523

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "xTicksToWait"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -3

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "xEntryTimeSet"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

.DEFINE "xInheritanceOccurred"

.CLASS 65

.VALUE -9

.TYPE 4

.ENDEF

.DEFINE "uxSemaphoreCount"

.CLASS 65

.VALUE -12

.TYPE 14

.ENDEF

.DEFINE "uxHighestWaitingPriority"

.CLASS 65

.VALUE -18

.TYPE 14

.ENDEF

.DEFINE "xTimeOut"

.CLASS 65

.VALUE -25

.TAG "xTIME_OUT"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE7
	LD	SP,HL
; 1524	    BaseType_t xEntryTimeSet = pdFALSE;
.LINE 1524

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
; 1525	    TimeOut_t xTimeOut;
; 1526	    Queue_t * const pxQueue = xQueue;
.LINE 1526

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 1527	
; 1528	    #if ( configUSE_MUTEXES == 1 )
; 1529	        BaseType_t xInheritanceOccurred = pdFALSE;
.LINE 1529

	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
; 1530	    #endif
; 1531	
; 1532	    /* Check the queue pointer is not NULL. */
; 1533	    configASSERT( ( pxQueue ) );
; 1534	
; 1535	    /* Check this really is a semaphore, in which case the item size will be
; 1536	     * 0. */
; 1537	    configASSERT( pxQueue->uxItemSize == 0 );
; 1538	
; 1539	    /* Cannot block if the scheduler is suspended. */
; 1540	    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
; 1541	    {
; 1542	        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
; 1543	    }
; 1544	    #endif
; 1545	
; 1546	    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
; 1547	     * statements within the function itself.  This is done in the interest
; 1548	     * of execution time efficiency. */
; 1549	    for( ; ; )
L_171:
.LINE 1549

; 1550	    {
; 1551	        taskENTER_CRITICAL();
.LINE 1551

	 di
; 1552	        {
; 1553	            /* Semaphores are queues with an item size of 0, and where the
; 1554	             * number of messages in the queue is the semaphore's count value. */
; 1555	            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
.LINE 1555

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%2C)
	LD	(IX+%FFFFFFF4),BC
; 1556	
; 1557	            /* Is there data in the queue now?  To be running the calling task
; 1558	             * must be the highest priority task wanting to access the queue. */
; 1559	            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
.LINE 1559

	LD	BC,(IX+%FFFFFFF4)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_152
; 1560	            {
; 1561	                traceQUEUE_RECEIVE( pxQueue );
; 1562	
; 1563	                /* Semaphores are queues with a data size of zero and where the
; 1564	                 * messages waiting is the semaphore's count.  Reduce the count. */
; 1565	                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
.LINE 1565

	LD	IY,(IX+%FFFFFFF4)
	LEA	BC,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%2C),BC
; 1566	
; 1567	                #if ( configUSE_MUTEXES == 1 )
; 1568	                {
; 1569	                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
.LINE 1569

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%0)
	CALL	__icmpzero
	JR	NZ,L_136
; 1570	                    {
; 1571	                        /* Record the information required to implement
; 1572	                         * priority inheritance should it become necessary. */
; 1573	                        pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
.LINE 1573

	CALL	_pvTaskIncrementMutexHeldCount
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%6),HL
; 1574	                    }
; 1575	                    else
L_136:
.LINE 1575

; 1576	                    {
; 1577	                        mtCOVERAGE_TEST_MARKER();
; 1578	                    }
; 1579	                }
; 1580	                #endif /* configUSE_MUTEXES */
; 1581	
; 1582	                /* Check to see if other tasks are blocked waiting to give the
; 1583	                 * semaphore, and if so, unblock the highest priority such task. */
; 1584	                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
.LINE 1584

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%C)
	CALL	__icmpzero
	JR	NZ,L_139
	LD	BC,1
	LD	(IX+%FFFFFFF1),BC
	JR	L_140
L_139:
	LD	BC,0
	LD	(IX+%FFFFFFF1),BC
L_140:
	LD	HL,(IX+%FFFFFFF1)
	CALL	__icmpzero
	JR	NZ,L_144
; 1585	                {
; 1586	                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
.LINE 1586

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%C
	CALL	_xTaskRemoveFromEventList
	POP	BC
	CALL	__icmpzero
; 1587	                    {
; 1588	                        queueYIELD_IF_USING_PREEMPTION();
; 1589	                    }
; 1590	                    else
.LINE 1590

; 1591	                    {
; 1592	                        mtCOVERAGE_TEST_MARKER();
; 1593	                    }
; 1594	                }
; 1595	                else
L_144:
.LINE 1595

; 1596	                {
; 1597	                    mtCOVERAGE_TEST_MARKER();
; 1598	                }
; 1599	
; 1600	                taskEXIT_CRITICAL();
.LINE 1600

	 ei
; 1601	                return pdPASS;
.LINE 1601

	LD	HL,1
	JR	L_173
; 1602	            }
; 1603	            else
L_152:
.LINE 1603

; 1604	            {
; 1605	                if( xTicksToWait == ( TickType_t ) 0 )
.LINE 1605

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	CALL	__lcmpzero
	JR	NZ,L_150
; 1606	                {
; 1607	                    /* The semaphore count was 0 and no block time is specified
; 1608	                     * (or the block time has expired) so exit now. */
; 1609	                    taskEXIT_CRITICAL();
.LINE 1609

	 ei
; 1610	                    traceQUEUE_RECEIVE_FAILED( pxQueue );
; 1611	                    return errQUEUE_EMPTY;
.LINE 1611

	OR	A,A
	SBC	HL,HL
	JR	L_173
; 1612	                }
; 1613	                else if( xEntryTimeSet == pdFALSE )
L_150:
.LINE 1613

	LD	HL,(IX+%FFFFFFFA)
	CALL	__icmpzero
	JR	NZ,L_148
; 1614	                {
; 1615	                    /* The semaphore count was 0 and a block time was specified
; 1616	                     * so configure the timeout structure ready to block. */
; 1617	                    vTaskInternalSetTimeOutState( &xTimeOut );
.LINE 1617

	PEA	IX+%FFFFFFE7
	CALL	_vTaskInternalSetTimeOutState
	POP	BC
; 1618	                    xEntryTimeSet = pdTRUE;
.LINE 1618

	LD	BC,1
	LD	(IX+%FFFFFFFA),BC
; 1619	                }
; 1620	                else
L_148:
.LINE 1620

; 1621	                {
; 1622	                    /* Entry time was already set. */
; 1623	                    mtCOVERAGE_TEST_MARKER();
; 1624	                }
; 1625	            }
; 1626	        }
; 1627	        taskEXIT_CRITICAL();
.LINE 1627

	 ei
; 1628	
; 1629	        /* Interrupts and other tasks can give to and take from the semaphore
; 1630	         * now the critical section has been exited. */
; 1631	
; 1632	        vTaskSuspendAll();
.LINE 1632

	CALL	_vTaskSuspendAll
; 1633	        prvLockQueue( pxQueue );
.LINE 1633

	 di
	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%35)
	CP	A,%FFFFFFFF
	JR	NZ,L_156
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%35),%0
L_156:
	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%36)
	CP	A,%FFFFFFFF
	JR	NZ,L_157
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%36),%0
L_157:
	 ei
; 1634	
; 1635	        /* Update the timeout state to see if it has expired yet. */
; 1636	        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
.LINE 1636

	PEA	IX+%9
	PEA	IX+%FFFFFFE7
	CALL	_xTaskCheckForTimeOut
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_170
; 1637	        {
; 1638	            /* A block time is specified and not expired.  If the semaphore
; 1639	             * count is 0 then enter the Blocked state to wait for a semaphore to
; 1640	             * become available.  As semaphores are implemented with queues the
; 1641	             * queue being empty is equivalent to the semaphore count being 0. */
; 1642	            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
.LINE 1642

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvIsQueueEmpty
	POP	BC
	CALL	__icmpzero
	JR	Z,L_164
; 1643	            {
; 1644	                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
; 1645	
; 1646	                #if ( configUSE_MUTEXES == 1 )
; 1647	                {
; 1648	                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
.LINE 1648

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%0)
	CALL	__icmpzero
	JR	NZ,L_159
; 1649	                    {
; 1650	                        taskENTER_CRITICAL();
.LINE 1650

	 di
; 1651	                        {
; 1652	                            xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
.LINE 1652

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%6)
	PUSH	BC
	CALL	_xTaskPriorityInherit
	POP	BC
	LD	(IX+%FFFFFFF7),HL
; 1653	                        }
; 1654	                        taskEXIT_CRITICAL();
.LINE 1654

	 ei
; 1655	                    }
; 1656	                    else
L_159:
.LINE 1656

; 1657	                    {
; 1658	                        mtCOVERAGE_TEST_MARKER();
; 1659	                    }
; 1660	                }
; 1661	                #endif /* if ( configUSE_MUTEXES == 1 ) */
; 1662	
; 1663	                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
.LINE 1663

	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%1C
	CALL	_vTaskPlaceOnEventList
	POP	BC
	POP	BC
	POP	BC
; 1664	                prvUnlockQueue( pxQueue );
.LINE 1664

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvUnlockQueue
	POP	BC
; 1665	
; 1666	                if( xTaskResumeAll() == pdFALSE )
.LINE 1666

	CALL	_xTaskResumeAll
	CALL	__icmpzero
	JR	NZ,L_171
; 1667	                {
; 1668	                    portYIELD_WITHIN_API();
.LINE 1668

	CALL	_vPortYield
; 1669	                }
; 1670	                else
.LINE 1670

	JR	L_171
; 1671	                {
; 1672	                    mtCOVERAGE_TEST_MARKER();
; 1673	                }
; 1674	            }
; 1675	            else
.LINE 1675

L_164:
; 1676	            {
; 1677	                /* There was no timeout and the semaphore count was not 0, so
; 1678	                 * attempt to take the semaphore again. */
; 1679	                prvUnlockQueue( pxQueue );
.LINE 1679

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvUnlockQueue
	POP	BC
; 1680	                ( void ) xTaskResumeAll();
.LINE 1680

	CALL	_xTaskResumeAll
; 1681	            }
; 1682	        }
; 1683	        else
.LINE 1683

	JR	L_171
L_170:
; 1684	        {
; 1685	            /* Timed out. */
; 1686	            prvUnlockQueue( pxQueue );
.LINE 1686

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvUnlockQueue
	POP	BC
; 1687	            ( void ) xTaskResumeAll();
.LINE 1687

	CALL	_xTaskResumeAll
; 1688	
; 1689	            /* If the semaphore count is 0 exit now as the timeout has
; 1690	             * expired.  Otherwise return to attempt to take the semaphore that is
; 1691	             * known to be available.  As semaphores are implemented by queues the
; 1692	             * queue being empty is equivalent to the semaphore count being 0. */
; 1693	            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
.LINE 1693

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvIsQueueEmpty
	POP	BC
	CALL	__icmpzero
	JR	Z,L_168
; 1694	            {
; 1695	                #if ( configUSE_MUTEXES == 1 )
; 1696	                {
; 1697	                    /* xInheritanceOccurred could only have be set if
; 1698	                     * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
; 1699	                     * test the mutex type again to check it is actually a mutex. */
; 1700	                    if( xInheritanceOccurred != pdFALSE )
.LINE 1700

	LD	HL,(IX+%FFFFFFF7)
	CALL	__icmpzero
	JR	Z,L_166
; 1701	                    {
; 1702	                        taskENTER_CRITICAL();
.LINE 1702

	 di
; 1703	                        {
; 1704	                            UBaseType_t uxHighestWaitingPriority;
; 1705	
; 1706	                            /* This task blocking on the mutex caused another
; 1707	                             * task to inherit this task's priority.  Now this task
; 1708	                             * has timed out the priority should be disinherited
; 1709	                             * again, but only as low as the next highest priority
; 1710	                             * task that is waiting for the same mutex. */
; 1711	                            uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
.LINE 1711

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvGetDisinheritPriorityAfterTimeout
	POP	BC
	LD	(IX+%FFFFFFEE),HL
; 1712	                            vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
.LINE 1712

	LD	BC,(IX+%FFFFFFEE)
	PUSH	BC
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%6)
	PUSH	BC
	CALL	_vTaskPriorityDisinheritAfterTimeout
	POP	BC
	POP	BC
; 1713	                        }
; 1714	                        taskEXIT_CRITICAL();
.LINE 1714

	 ei
; 1715	                    }
; 1716	                }
L_166:
.LINE 1716

; 1717	                #endif /* configUSE_MUTEXES */
; 1718	
; 1719	                traceQUEUE_RECEIVE_FAILED( pxQueue );
; 1720	                return errQUEUE_EMPTY;
.LINE 1720

	OR	A,A
	SBC	HL,HL
	JR	L_173
; 1721	            }
; 1722	            else
L_168:
.LINE 1722

; 1723	            {
; 1724	                mtCOVERAGE_TEST_MARKER();
; 1725	            }
; 1726	        }
; 1727	    } /*lint -restore */
L_172:
.LINE 1727

	JR	L_171
; 1728	}
L_173:
.LINE 1728

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xQueueSemaphoreTake ***************************
;Name                         Addr/Register   Size   Type
;_vTaskPriorityDisinheritAfterTimeout      IMPORT  -----   function
;_prvGetDisinheritPriorityAfterTimeout      STATIC  -----   function
;_vPortYield                         IMPORT  -----   function
;_xTaskResumeAll                     IMPORT  -----   function
;_prvUnlockQueue                     STATIC  -----   function
;_vTaskPlaceOnEventList              IMPORT  -----   function
;_xTaskPriorityInherit               IMPORT  -----   function
;_prvIsQueueEmpty                    STATIC  -----   function
;_xTaskCheckForTimeOut               IMPORT  -----   function
;_vTaskSuspendAll                    IMPORT  -----   function
;_vTaskInternalSetTimeOutState       IMPORT  -----   function
;_xTaskRemoveFromEventList           IMPORT  -----   function
;_pvTaskIncrementMutexHeldCount      IMPORT  -----   function
;xTimeOut                             IX-25      7   variable
;uxHighestWaitingPriority             IX-18      3   variable
;temp137                              IX-15      3   variable
;uxSemaphoreCount                     IX-12      3   variable
;xInheritanceOccurred                  IX-9      3   variable
;xEntryTimeSet                         IX-6      3   variable
;pxQueue                               IX-3      3   variable
;xTicksToWait                          IX+9      4   parameter
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 40 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xQueueSemaphoreTake",1728,"_xQueueSemaphoreTake"
; 1729	/*-----------------------------------------------------------*/
; 1730	
; 1731	BaseType_t xQueuePeek( QueueHandle_t xQueue,
; 1732	                       void * const pvBuffer,
; 1733	                       TickType_t xTicksToWait )
; 1734	{
_xQueuePeek:
.DEFINE "_xQueuePeek"

.VALUE _xQueuePeek

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xQueuePeek",1734,"_xQueuePeek"

.LINE 1734

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "pvBuffer"

.CLASS 65

.VALUE 9

.TYPE 33

.ENDEF

.DEFINE "xTicksToWait"

.CLASS 65

.VALUE 12

.TYPE 15

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -3

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "xEntryTimeSet"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

.DEFINE "uxMessagesWaiting"

.CLASS 65

.VALUE -12

.TYPE 14

.ENDEF

.DEFINE "pcOriginalReadPosition"

.CLASS 65

.VALUE -15

.TYPE 34

.ENDEF

.DEFINE "xTimeOut"

.CLASS 65

.VALUE -22

.TAG "xTIME_OUT"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEA
	LD	SP,HL
; 1735	    BaseType_t xEntryTimeSet = pdFALSE;
.LINE 1735

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
; 1736	    TimeOut_t xTimeOut;
; 1737	    int8_t * pcOriginalReadPosition;
; 1738	    Queue_t * const pxQueue = xQueue;
.LINE 1738

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 1739	
; 1740	    /* Check the pointer is not NULL. */
; 1741	    configASSERT( ( pxQueue ) );
; 1742	
; 1743	    /* The buffer into which data is received can only be NULL if the data size
; 1744	     * is zero (so no data is copied into the buffer. */
; 1745	    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
; 1746	
; 1747	    /* Cannot block if the scheduler is suspended. */
; 1748	    #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
; 1749	    {
; 1750	        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
; 1751	    }
; 1752	    #endif
; 1753	
; 1754	    /*lint -save -e904  This function relaxes the coding standard somewhat to
; 1755	     * allow return statements within the function itself.  This is done in the
; 1756	     * interest of execution time efficiency. */
; 1757	    for( ; ; )
L_202:
.LINE 1757

; 1758	    {
; 1759	        taskENTER_CRITICAL();
.LINE 1759

	 di
; 1760	        {
; 1761	            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
.LINE 1761

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%2C)
	LD	(IX+%FFFFFFF4),BC
; 1762	
; 1763	            /* Is there data in the queue now?  To be running the calling task
; 1764	             * must be the highest priority task wanting to access the queue. */
; 1765	            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
.LINE 1765

	LD	BC,(IX+%FFFFFFF4)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_188
; 1766	            {
; 1767	                /* Remember the read position so it can be reset after the data
; 1768	                 * is read from the queue as this function is only peeking the
; 1769	                 * data, not removing it. */
; 1770	                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
.LINE 1770

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%9)
	LD	(IX+%FFFFFFF1),BC
; 1771	
; 1772	                prvCopyDataFromQueue( pxQueue, pvBuffer );
.LINE 1772

	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvCopyDataFromQueue
	POP	BC
	POP	BC
; 1773	                traceQUEUE_PEEK( pxQueue );
; 1774	
; 1775	                /* The data is not being removed, so reset the read pointer. */
; 1776	                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
.LINE 1776

	LD	BC,(IX+%FFFFFFF1)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%9),BC
; 1777	
; 1778	                /* The data is being left in the queue, so see if there are
; 1779	                 * any other tasks waiting for the data. */
; 1780	                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
.LINE 1780

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%1C)
	CALL	__icmpzero
	JR	NZ,L_176
	LD	BC,1
	LD	(IX+%FFFFFFF7),BC
	JR	L_177
L_176:
	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
L_177:
	LD	HL,(IX+%FFFFFFF7)
	CALL	__icmpzero
	JR	NZ,L_181
; 1781	                {
; 1782	                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
.LINE 1782

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%1C
	CALL	_xTaskRemoveFromEventList
	POP	BC
	CALL	__icmpzero
; 1783	                    {
; 1784	                        /* The task waiting has a higher priority than this task. */
; 1785	                        queueYIELD_IF_USING_PREEMPTION();
; 1786	                    }
; 1787	                    else
.LINE 1787

; 1788	                    {
; 1789	                        mtCOVERAGE_TEST_MARKER();
; 1790	                    }
; 1791	                }
; 1792	                else
L_181:
.LINE 1792

; 1793	                {
; 1794	                    mtCOVERAGE_TEST_MARKER();
; 1795	                }
; 1796	
; 1797	                taskEXIT_CRITICAL();
.LINE 1797

	 ei
; 1798	                return pdPASS;
.LINE 1798

	LD	HL,1
	JR	L_204
; 1799	            }
; 1800	            else
L_188:
.LINE 1800

; 1801	            {
; 1802	                if( xTicksToWait == ( TickType_t ) 0 )
.LINE 1802

	LD	HL,(IX+%C)
	LD	E,(IX+%F)
	CALL	__lcmpzero
	JR	NZ,L_186
; 1803	                {
; 1804	                    /* The queue was empty and no block time is specified (or
; 1805	                     * the block time has expired) so leave now. */
; 1806	                    taskEXIT_CRITICAL();
.LINE 1806

	 ei
; 1807	                    traceQUEUE_PEEK_FAILED( pxQueue );
; 1808	                    return errQUEUE_EMPTY;
.LINE 1808

	OR	A,A
	SBC	HL,HL
	JR	L_204
; 1809	                }
; 1810	                else if( xEntryTimeSet == pdFALSE )
L_186:
.LINE 1810

	LD	HL,(IX+%FFFFFFFA)
	CALL	__icmpzero
	JR	NZ,L_184
; 1811	                {
; 1812	                    /* The queue was empty and a block time was specified so
; 1813	                     * configure the timeout structure ready to enter the blocked
; 1814	                     * state. */
; 1815	                    vTaskInternalSetTimeOutState( &xTimeOut );
.LINE 1815

	PEA	IX+%FFFFFFEA
	CALL	_vTaskInternalSetTimeOutState
	POP	BC
; 1816	                    xEntryTimeSet = pdTRUE;
.LINE 1816

	LD	BC,1
	LD	(IX+%FFFFFFFA),BC
; 1817	                }
; 1818	                else
L_184:
.LINE 1818

; 1819	                {
; 1820	                    /* Entry time was already set. */
; 1821	                    mtCOVERAGE_TEST_MARKER();
; 1822	                }
; 1823	            }
; 1824	        }
; 1825	        taskEXIT_CRITICAL();
.LINE 1825

	 ei
; 1826	
; 1827	        /* Interrupts and other tasks can send to and receive from the queue
; 1828	         * now that the critical section has been exited. */
; 1829	
; 1830	        vTaskSuspendAll();
.LINE 1830

	CALL	_vTaskSuspendAll
; 1831	        prvLockQueue( pxQueue );
.LINE 1831

	 di
	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%35)
	CP	A,%FFFFFFFF
	JR	NZ,L_192
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%35),%0
L_192:
	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%36)
	CP	A,%FFFFFFFF
	JR	NZ,L_193
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%36),%0
L_193:
	 ei
; 1832	
; 1833	        /* Update the timeout state to see if it has expired yet. */
; 1834	        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
.LINE 1834

	PEA	IX+%C
	PEA	IX+%FFFFFFEA
	CALL	_xTaskCheckForTimeOut
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_201
; 1835	        {
; 1836	            /* Timeout has not expired yet, check to see if there is data in the
; 1837	            * queue now, and if not enter the Blocked state to wait for data. */
; 1838	            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
.LINE 1838

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvIsQueueEmpty
	POP	BC
	CALL	__icmpzero
	JR	Z,L_197
; 1839	            {
; 1840	                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
; 1841	                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
.LINE 1841

	LD	C,(IX+%F)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%C)
	PUSH	BC
	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%1C
	CALL	_vTaskPlaceOnEventList
	POP	BC
	POP	BC
	POP	BC
; 1842	                prvUnlockQueue( pxQueue );
.LINE 1842

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvUnlockQueue
	POP	BC
; 1843	
; 1844	                if( xTaskResumeAll() == pdFALSE )
.LINE 1844

	CALL	_xTaskResumeAll
	CALL	__icmpzero
	JR	NZ,L_202
; 1845	                {
; 1846	                    portYIELD_WITHIN_API();
.LINE 1846

	CALL	_vPortYield
; 1847	                }
; 1848	                else
.LINE 1848

	JR	L_202
; 1849	                {
; 1850	                    mtCOVERAGE_TEST_MARKER();
; 1851	                }
; 1852	            }
; 1853	            else
.LINE 1853

L_197:
; 1854	            {
; 1855	                /* There is data in the queue now, so don't enter the blocked
; 1856	                 * state, instead return to try and obtain the data. */
; 1857	                prvUnlockQueue( pxQueue );
.LINE 1857

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvUnlockQueue
	POP	BC
; 1858	                ( void ) xTaskResumeAll();
.LINE 1858

	CALL	_xTaskResumeAll
; 1859	            }
; 1860	        }
; 1861	        else
.LINE 1861

	JR	L_202
L_201:
; 1862	        {
; 1863	            /* The timeout has expired.  If there is still no data in the queue
; 1864	             * exit, otherwise go back and try to read the data again. */
; 1865	            prvUnlockQueue( pxQueue );
.LINE 1865

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvUnlockQueue
	POP	BC
; 1866	            ( void ) xTaskResumeAll();
.LINE 1866

	CALL	_xTaskResumeAll
; 1867	
; 1868	            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
.LINE 1868

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvIsQueueEmpty
	POP	BC
	CALL	__icmpzero
	JR	Z,L_199
; 1869	            {
; 1870	                traceQUEUE_PEEK_FAILED( pxQueue );
; 1871	                return errQUEUE_EMPTY;
.LINE 1871

	OR	A,A
	SBC	HL,HL
	JR	L_204
; 1872	            }
; 1873	            else
L_199:
.LINE 1873

; 1874	            {
; 1875	                mtCOVERAGE_TEST_MARKER();
; 1876	            }
; 1877	        }
; 1878	    } /*lint -restore */
L_203:
.LINE 1878

	JR	L_202
; 1879	}
L_204:
.LINE 1879

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xQueuePeek ***************************
;Name                         Addr/Register   Size   Type
;_vPortYield                         IMPORT  -----   function
;_xTaskResumeAll                     IMPORT  -----   function
;_prvUnlockQueue                     STATIC  -----   function
;_vTaskPlaceOnEventList              IMPORT  -----   function
;_prvIsQueueEmpty                    STATIC  -----   function
;_xTaskCheckForTimeOut               IMPORT  -----   function
;_vTaskSuspendAll                    IMPORT  -----   function
;_vTaskInternalSetTimeOutState       IMPORT  -----   function
;_xTaskRemoveFromEventList           IMPORT  -----   function
;_prvCopyDataFromQueue               STATIC  -----   function
;xTimeOut                             IX-22      7   variable
;pcOriginalReadPosition               IX-15      3   variable
;uxMessagesWaiting                    IX-12      3   variable
;temp174                               IX-9      3   variable
;xEntryTimeSet                         IX-6      3   variable
;pxQueue                               IX-3      3   variable
;xTicksToWait                         IX+12      4   parameter
;pvBuffer                              IX+9      3   parameter
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 40 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xQueuePeek",1879,"_xQueuePeek"
; 1880	/*-----------------------------------------------------------*/
; 1881	
; 1882	BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
; 1883	                                 void * const pvBuffer,
; 1884	                                 BaseType_t * const pxHigherPriorityTaskWoken )
; 1885	{
_xQueueReceiveFromISR:
.DEFINE "_xQueueReceiveFromISR"

.VALUE _xQueueReceiveFromISR

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xQueueReceiveFromISR",1885,"_xQueueReceiveFromISR"

.LINE 1885

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "pvBuffer"

.CLASS 65

.VALUE 9

.TYPE 33

.ENDEF

.DEFINE "pxHigherPriorityTaskWoken"

.CLASS 65

.VALUE 12

.TYPE 36

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -3

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "cRxLock"

.CLASS 65

.VALUE -4

.TYPE 2

.ENDEF

.DEFINE "uxMessagesWaiting"

.CLASS 65

.VALUE -7

.TYPE 14

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -10

.TYPE 4

.ENDEF

.DEFINE "uxNumberOfTasks"

.CLASS 65

.VALUE -16

.TYPE 14

.ENDEF

.DEFINE "uxSavedInterruptStatus"

.CLASS 65

.VALUE -19

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFED
	LD	SP,HL
; 1886	    BaseType_t xReturn;
; 1887	    UBaseType_t uxSavedInterruptStatus;
; 1888	    Queue_t * const pxQueue = xQueue;
.LINE 1888

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 1889	
; 1890	    configASSERT( pxQueue );
; 1891	    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
; 1892	
; 1893	    /* RTOS ports that support interrupt nesting have the concept of a maximum
; 1894	     * system call (or maximum API call) interrupt priority.  Interrupts that are
; 1895	     * above the maximum system call priority are kept permanently enabled, even
; 1896	     * when the RTOS kernel is in a critical section, but cannot make any calls to
; 1897	     * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
; 1898	     * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
; 1899	     * failure if a FreeRTOS API function is called from an interrupt that has been
; 1900	     * assigned a priority above the configured maximum system call priority.
; 1901	     * Only FreeRTOS functions that end in FromISR can be called from interrupts
; 1902	     * that have been assigned a priority at or (logically) below the maximum
; 1903	     * system call interrupt priority.  FreeRTOS maintains a separate interrupt
; 1904	     * safe API to ensure interrupt entry is as fast and as simple as possible.
; 1905	     * More information (albeit Cortex-M specific) is provided on the following
; 1906	     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
; 1907	    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
; 1908	
; 1909	    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
.LINE 1909

	LD	BC,0
	LD	(IX+%FFFFFFED),BC
; 1910	    {
; 1911	        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
.LINE 1911

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%2C)
	LD	(IX+%FFFFFFF9),BC
; 1912	
; 1913	        /* Cannot block in an ISR, so check there is data available. */
; 1914	        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
.LINE 1914

	LD	BC,(IX+%FFFFFFF9)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_221
; 1915	        {
; 1916	            const int8_t cRxLock = pxQueue->cRxLock;
.LINE 1916

	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%35)
	LD	(IX+%FFFFFFFC),A
; 1917	
; 1918	            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
; 1919	
; 1920	            prvCopyDataFromQueue( pxQueue, pvBuffer );
.LINE 1920

	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvCopyDataFromQueue
	POP	BC
	POP	BC
; 1921	            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
.LINE 1921

	LD	IY,(IX+%FFFFFFF9)
	LEA	BC,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%2C),BC
; 1922	
; 1923	            /* If the queue is locked the event list will not be modified.
; 1924	             * Instead update the lock count so the task that unlocks the queue
; 1925	             * will know that an ISR has removed data while the queue was
; 1926	             * locked. */
; 1927	            if( cRxLock == queueUNLOCKED )
.LINE 1927

	LD	A,(IX+%FFFFFFFC)
	CP	A,%FFFFFFFF
	JR	NZ,L_218
; 1928	            {
; 1929	                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
.LINE 1929

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%C)
	CALL	__icmpzero
	JR	NZ,L_207
	LD	BC,1
	LD	(IX+%FFFFFFF3),BC
	JR	L_208
L_207:
	LD	BC,0
	LD	(IX+%FFFFFFF3),BC
L_208:
	LD	HL,(IX+%FFFFFFF3)
	CALL	__icmpzero
	JR	NZ,L_219
; 1930	                {
; 1931	                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
.LINE 1931

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%C
	CALL	_xTaskRemoveFromEventList
	POP	BC
	CALL	__icmpzero
	JR	Z,L_219
; 1932	                    {
; 1933	                        /* The task waiting has a higher priority than us so
; 1934	                         * force a context switch. */
; 1935	                        if( pxHigherPriorityTaskWoken != NULL )
.LINE 1935

	LD	HL,(IX+%C)
	CALL	__icmpzero
	JR	Z,L_219
; 1936	                        {
; 1937	                            *pxHigherPriorityTaskWoken = pdTRUE;
.LINE 1937

	LD	HL,(IX+%C)
	LD	BC,1
	LD	(HL),BC
; 1938	                        }
; 1939	                        else
.LINE 1939

	JR	L_219
; 1940	                        {
; 1941	                            mtCOVERAGE_TEST_MARKER();
; 1942	                        }
; 1943	                    }
; 1944	                    else
.LINE 1944

; 1945	                    {
; 1946	                        mtCOVERAGE_TEST_MARKER();
; 1947	                    }
; 1948	                }
; 1949	                else
.LINE 1949

	JR	L_219
; 1950	                {
; 1951	                    mtCOVERAGE_TEST_MARKER();
; 1952	                }
; 1953	            }
; 1954	            else
.LINE 1954

L_218:
; 1955	            {
; 1956	                /* Increment the lock count so the task that unlocks the queue
; 1957	                 * knows that data was removed while it was locked. */
; 1958	                prvIncrementQueueRxLock( pxQueue, cRxLock );
.LINE 1958

	CALL	_uxTaskGetNumberOfTasks
	LD	(IX+%FFFFFFF0),HL
	LD	A,(IX+%FFFFFFFC)
	SEXT	HL
	LD	L,(IX+%FFFFFFFC)
	LD	BC,(IX+%FFFFFFF0)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_219
	LD	A,(IX+%FFFFFFFC)
	INC	A
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%35),A
; 1959	            }
L_219:
.LINE 1959

; 1960	
; 1961	            xReturn = pdPASS;
.LINE 1961

	LD	BC,1
	LD	(IX+%FFFFFFF6),BC
; 1962	        }
; 1963	        else
.LINE 1963

	JR	L_222
L_221:
; 1964	        {
; 1965	            xReturn = pdFAIL;
.LINE 1965

	LD	BC,0
	LD	(IX+%FFFFFFF6),BC
; 1966	            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
; 1967	        }
; 1968	    }
L_222:
.LINE 1968

; 1969	    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
; 1970	
; 1971	    return xReturn;
.LINE 1971

	LD	HL,(IX+%FFFFFFF6)
; 1972	}
.LINE 1972

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xQueueReceiveFromISR ***************************
;Name                         Addr/Register   Size   Type
;_uxTaskGetNumberOfTasks             IMPORT  -----   function
;_xTaskRemoveFromEventList           IMPORT  -----   function
;_prvCopyDataFromQueue               STATIC  -----   function
;uxSavedInterruptStatus               IX-19      3   variable
;uxNumberOfTasks                      IX-16      3   variable
;temp205                              IX-13      3   variable
;xReturn                              IX-10      3   variable
;uxMessagesWaiting                     IX-7      3   variable
;cRxLock                               IX-4      1   variable
;pxQueue                               IX-3      3   variable
;pxHigherPriorityTaskWoken            IX+12      3   parameter
;pvBuffer                              IX+9      3   parameter
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 34 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xQueueReceiveFromISR",1972,"_xQueueReceiveFromISR"
; 1973	/*-----------------------------------------------------------*/
; 1974	
; 1975	BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
; 1976	                              void * const pvBuffer )
; 1977	{
_xQueuePeekFromISR:
.DEFINE "_xQueuePeekFromISR"

.VALUE _xQueuePeekFromISR

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xQueuePeekFromISR",1977,"_xQueuePeekFromISR"

.LINE 1977

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "pvBuffer"

.CLASS 65

.VALUE 9

.TYPE 33

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -3

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

.DEFINE "pcOriginalReadPosition"

.CLASS 65

.VALUE -9

.TYPE 34

.ENDEF

.DEFINE "uxSavedInterruptStatus"

.CLASS 65

.VALUE -12

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF4
	LD	SP,HL
; 1978	    BaseType_t xReturn;
; 1979	    UBaseType_t uxSavedInterruptStatus;
; 1980	    int8_t * pcOriginalReadPosition;
; 1981	    Queue_t * const pxQueue = xQueue;
.LINE 1981

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 1982	
; 1983	    configASSERT( pxQueue );
; 1984	    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
; 1985	    configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
; 1986	
; 1987	    /* RTOS ports that support interrupt nesting have the concept of a maximum
; 1988	     * system call (or maximum API call) interrupt priority.  Interrupts that are
; 1989	     * above the maximum system call priority are kept permanently enabled, even
; 1990	     * when the RTOS kernel is in a critical section, but cannot make any calls to
; 1991	     * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
; 1992	     * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
; 1993	     * failure if a FreeRTOS API function is called from an interrupt that has been
; 1994	     * assigned a priority above the configured maximum system call priority.
; 1995	     * Only FreeRTOS functions that end in FromISR can be called from interrupts
; 1996	     * that have been assigned a priority at or (logically) below the maximum
; 1997	     * system call interrupt priority.  FreeRTOS maintains a separate interrupt
; 1998	     * safe API to ensure interrupt entry is as fast and as simple as possible.
; 1999	     * More information (albeit Cortex-M specific) is provided on the following
; 2000	     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
; 2001	    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
; 2002	
; 2003	    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
.LINE 2003

	LD	BC,0
	LD	(IX+%FFFFFFF4),BC
; 2004	    {
; 2005	        /* Cannot block in an ISR, so check there is data available. */
; 2006	        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
.LINE 2006

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%2C)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_225
; 2007	        {
; 2008	            traceQUEUE_PEEK_FROM_ISR( pxQueue );
; 2009	
; 2010	            /* Remember the read position so it can be reset as nothing is
; 2011	             * actually being removed from the queue. */
; 2012	            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
.LINE 2012

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%9)
	LD	(IX+%FFFFFFF7),BC
; 2013	            prvCopyDataFromQueue( pxQueue, pvBuffer );
.LINE 2013

	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvCopyDataFromQueue
	POP	BC
	POP	BC
; 2014	            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
.LINE 2014

	LD	BC,(IX+%FFFFFFF7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%9),BC
; 2015	
; 2016	            xReturn = pdPASS;
.LINE 2016

	LD	BC,1
	LD	(IX+%FFFFFFFA),BC
; 2017	        }
; 2018	        else
.LINE 2018

	JR	L_226
L_225:
; 2019	        {
; 2020	            xReturn = pdFAIL;
.LINE 2020

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
; 2021	            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
; 2022	        }
; 2023	    }
L_226:
.LINE 2023

; 2024	    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
; 2025	
; 2026	    return xReturn;
.LINE 2026

	LD	HL,(IX+%FFFFFFFA)
; 2027	}
.LINE 2027

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xQueuePeekFromISR ***************************
;Name                         Addr/Register   Size   Type
;_prvCopyDataFromQueue               STATIC  -----   function
;uxSavedInterruptStatus               IX-12      3   variable
;pcOriginalReadPosition                IX-9      3   variable
;xReturn                               IX-6      3   variable
;pxQueue                               IX-3      3   variable
;pvBuffer                              IX+9      3   parameter
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 24 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xQueuePeekFromISR",2027,"_xQueuePeekFromISR"
; 2028	/*-----------------------------------------------------------*/
; 2029	
; 2030	UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
; 2031	{
_uxQueueMessagesWaiting:
.DEFINE "_uxQueueMessagesWaiting"

.VALUE _uxQueueMessagesWaiting

.CLASS 2

.TYPE 78

.ENDEF

.BEGFUNC "uxQueueMessagesWaiting",2031,"_uxQueueMessagesWaiting"

.LINE 2031

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "uxReturn"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
; 2032	    UBaseType_t uxReturn;
; 2033	
; 2034	    configASSERT( xQueue );
; 2035	
; 2036	    taskENTER_CRITICAL();
.LINE 2036

	 di
; 2037	    {
; 2038	        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
.LINE 2038

	LD	IY,(IX+%6)
	LD	BC,(IY+%2C)
	LD	(IX+%FFFFFFFD),BC
; 2039	    }
; 2040	    taskEXIT_CRITICAL();
.LINE 2040

	 ei
; 2041	
; 2042	    return uxReturn;
.LINE 2042

	LD	HL,(IX+%FFFFFFFD)
; 2043	} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
.LINE 2043

	LD	SP,IX
	POP	IX
	RET	


;**************************** _uxQueueMessagesWaiting ***************************
;Name                         Addr/Register   Size   Type
;uxReturn                              IX-3      3   variable
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "uxQueueMessagesWaiting",2043,"_uxQueueMessagesWaiting"
; 2044	/*-----------------------------------------------------------*/
; 2045	
; 2046	UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
; 2047	{
_uxQueueSpacesAvailable:
.DEFINE "_uxQueueSpacesAvailable"

.VALUE _uxQueueSpacesAvailable

.CLASS 2

.TYPE 78

.ENDEF

.BEGFUNC "uxQueueSpacesAvailable",2047,"_uxQueueSpacesAvailable"

.LINE 2047

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -3

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "uxReturn"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
; 2048	    UBaseType_t uxReturn;
; 2049	    Queue_t * const pxQueue = xQueue;
.LINE 2049

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 2050	
; 2051	    configASSERT( pxQueue );
; 2052	
; 2053	    taskENTER_CRITICAL();
.LINE 2053

	 di
; 2054	    {
; 2055	        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
.LINE 2055

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%2F)
	LD	BC,(IY+%2C)
	OR	A,A
	SBC	HL,BC
	LD	(IX+%FFFFFFFA),HL
; 2056	    }
; 2057	    taskEXIT_CRITICAL();
.LINE 2057

	 ei
; 2058	
; 2059	    return uxReturn;
.LINE 2059

	LD	HL,(IX+%FFFFFFFA)
; 2060	} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
.LINE 2060

	LD	SP,IX
	POP	IX
	RET	


;**************************** _uxQueueSpacesAvailable ***************************
;Name                         Addr/Register   Size   Type
;uxReturn                              IX-6      3   variable
;pxQueue                               IX-3      3   variable
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "uxQueueSpacesAvailable",2060,"_uxQueueSpacesAvailable"
; 2061	/*-----------------------------------------------------------*/
; 2062	
; 2063	UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
; 2064	{
_uxQueueMessagesWaitingFromISR:
.DEFINE "_uxQueueMessagesWaitingFromISR"

.VALUE _uxQueueMessagesWaitingFromISR

.CLASS 2

.TYPE 78

.ENDEF

.BEGFUNC "uxQueueMessagesWaitingFromISR",2064,"_uxQueueMessagesWaitingFromISR"

.LINE 2064

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "uxReturn"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
; 2065	    UBaseType_t uxReturn;
; 2066	    Queue_t * const pxQueue = xQueue;
.LINE 2066

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFA),BC
; 2067	
; 2068	    configASSERT( pxQueue );
; 2069	    uxReturn = pxQueue->uxMessagesWaiting;
.LINE 2069

	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%2C)
	LD	(IX+%FFFFFFFD),BC
; 2070	
; 2071	    return uxReturn;
.LINE 2071

	LD	HL,(IX+%FFFFFFFD)
; 2072	} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
.LINE 2072

	LD	SP,IX
	POP	IX
	RET	


;**************************** _uxQueueMessagesWaitingFromISR ***************************
;Name                         Addr/Register   Size   Type
;pxQueue                               IX-6      3   variable
;uxReturn                              IX-3      3   variable
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "uxQueueMessagesWaitingFromISR",2072,"_uxQueueMessagesWaitingFromISR"
; 2073	/*-----------------------------------------------------------*/
; 2074	
; 2075	void vQueueDelete( QueueHandle_t xQueue )
; 2076	{
_vQueueDelete:
.DEFINE "_vQueueDelete"

.VALUE _vQueueDelete

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vQueueDelete",2076,"_vQueueDelete"

.LINE 2076

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -3

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
; 2077	    Queue_t * const pxQueue = xQueue;
.LINE 2077

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 2078	
; 2079	    configASSERT( pxQueue );
; 2080	    traceQUEUE_DELETE( pxQueue );
; 2081	
; 2082	    #if ( configQUEUE_REGISTRY_SIZE > 0 )
; 2083	    {
; 2084	        vQueueUnregisterQueue( pxQueue );
; 2085	    }
; 2086	    #endif
; 2087	
; 2088	    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
; 2089	    {
; 2090	        /* The queue can only have been allocated dynamically - free it
; 2091	         * again. */
; 2092	        vPortFree( pxQueue );
.LINE 2092

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_vPortFree
	POP	BC
; 2093	    }
; 2094	    #elif ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
; 2095	    {
; 2096	        /* The queue could have been allocated statically or dynamically, so
; 2097	         * check before attempting to free the memory. */
; 2098	        if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
; 2099	        {
; 2100	            vPortFree( pxQueue );
; 2101	        }
; 2102	        else
; 2103	        {
; 2104	            mtCOVERAGE_TEST_MARKER();
; 2105	        }
; 2106	    }
; 2107	    #else /* if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) ) */
; 2108	    {
; 2109	        /* The queue must have been statically allocated, so is not going to be
; 2110	         * deleted.  Avoid compiler warnings about the unused parameter. */
; 2111	        ( void ) pxQueue;
; 2112	    }
; 2113	    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
; 2114	}
.LINE 2114

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vQueueDelete ***************************
;Name                         Addr/Register   Size   Type
;_vPortFree                          IMPORT  -----   function
;pxQueue                               IX-3      3   variable
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vQueueDelete",2114,"_vQueueDelete"
; 2115	/*-----------------------------------------------------------*/
; 2116	
; 2117	#if ( configUSE_TRACE_FACILITY == 1 )
; 2118	
; 2119	    UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
; 2120	    {
; 2121	        return ( ( Queue_t * ) xQueue )->uxQueueNumber;
; 2122	    }
; 2123	
; 2124	#endif /* configUSE_TRACE_FACILITY */
; 2125	/*-----------------------------------------------------------*/
; 2126	
; 2127	#if ( configUSE_TRACE_FACILITY == 1 )
; 2128	
; 2129	    void vQueueSetQueueNumber( QueueHandle_t xQueue,
; 2130	                               UBaseType_t uxQueueNumber )
; 2131	    {
; 2132	        ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
; 2133	    }
; 2134	
; 2135	#endif /* configUSE_TRACE_FACILITY */
; 2136	/*-----------------------------------------------------------*/
; 2137	
; 2138	#if ( configUSE_TRACE_FACILITY == 1 )
; 2139	
; 2140	    uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
; 2141	    {
; 2142	        return ( ( Queue_t * ) xQueue )->ucQueueType;
; 2143	    }
; 2144	
; 2145	#endif /* configUSE_TRACE_FACILITY */
; 2146	/*-----------------------------------------------------------*/
; 2147	
; 2148	#if ( configUSE_MUTEXES == 1 )
; 2149	
; 2150	    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
; 2151	    {
_prvGetDisinheritPriorityAfterTimeout:
.DEFINE "_prvGetDisinheritPriorityAfterTimeout"

.VALUE _prvGetDisinheritPriorityAfterTimeout

.CLASS 3

.TYPE 78

.ENDEF

.BEGFUNC "prvGetDisinheritPriorityAfterTimeout",2151,"_prvGetDisinheritPriorityAfterTimeout"

.LINE 2151

.DEFINE "pxQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 200

.ENDEF

.DEFINE "uxHighestPriorityOfWaitingTasks"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
; 2152	        UBaseType_t uxHighestPriorityOfWaitingTasks;
; 2153	
; 2154	        /* If a task waiting for a mutex causes the mutex holder to inherit a
; 2155	         * priority, but the waiting task times out, then the holder should
; 2156	         * disinherit the priority - but only down to the highest priority of any
; 2157	         * other tasks that are waiting for the same mutex.  For this purpose,
; 2158	         * return the priority of the highest priority task that is waiting for the
; 2159	         * mutex. */
; 2160	        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
.LINE 2160

	LD	IY,(IX+%6)
	LD	BC,(IY+%1C)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_233
; 2161	        {
; 2162	            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
.LINE 2162

	LD	IY,(IX+%6)
	LD	IY,(IY+%26)
	LD	BC,(IY+%0)
	LD	HL,5
	OR	A,A
	SBC	HL,BC
	LD	(IX+%FFFFFFFD),HL
; 2163	        }
; 2164	        else
.LINE 2164

	JR	L_234
L_233:
; 2165	        {
; 2166	            uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
.LINE 2166

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 2167	        }
L_234:
.LINE 2167

; 2168	
; 2169	        return uxHighestPriorityOfWaitingTasks;
.LINE 2169

	LD	HL,(IX+%FFFFFFFD)
; 2170	    }
.LINE 2170

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvGetDisinheritPriorityAfterTimeout ***************************
;Name                         Addr/Register   Size   Type
;uxHighestPriorityOfWaitingTasks        IX-3      3   variable
;pxQueue                               IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvGetDisinheritPriorityAfterTimeout",2170,"_prvGetDisinheritPriorityAfterTimeout"
; 2171	
; 2172	#endif /* configUSE_MUTEXES */
; 2173	/*-----------------------------------------------------------*/
; 2174	
; 2175	static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
; 2176	                                      const void * pvItemToQueue,
; 2177	                                      const BaseType_t xPosition )
; 2178	{
_prvCopyDataToQueue:
.DEFINE "_prvCopyDataToQueue"

.VALUE _prvCopyDataToQueue

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "prvCopyDataToQueue",2178,"_prvCopyDataToQueue"

.LINE 2178

.DEFINE "pxQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "pvItemToQueue"

.CLASS 65

.VALUE 9

.TYPE 193

.ENDEF

.DEFINE "xPosition"

.CLASS 65

.VALUE 12

.TYPE 4

.ENDEF

.DEFINE "uxMessagesWaiting"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	DEC	SP
; 2179	    BaseType_t xReturn = pdFALSE;
.LINE 2179

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
; 2180	    UBaseType_t uxMessagesWaiting;
; 2181	
; 2182	    /* This function is called from a critical section. */
; 2183	
; 2184	    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
.LINE 2184

	LD	IY,(IX+%6)
	LD	BC,(IY+%2C)
	LD	(IX+%FFFFFFFD),BC
; 2185	
; 2186	    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
.LINE 2186

	LD	IY,(IX+%6)
	LD	HL,(IY+%32)
	CALL	__icmpzero
	JR	NZ,L_250
; 2187	    {
; 2188	        #if ( configUSE_MUTEXES == 1 )
; 2189	        {
; 2190	            if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
.LINE 2190

	LD	IY,(IX+%6)
	LD	HL,(IY+%0)
	CALL	__icmpzero
	JR	NZ,L_251
; 2191	            {
; 2192	                /* The mutex is no longer being held. */
; 2193	                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
.LINE 2193

	LD	IY,(IX+%6)
	LD	BC,(IY+%6)
	PUSH	BC
	CALL	_xTaskPriorityDisinherit
	POP	BC
	LD	(IX+%FFFFFFFA),HL
; 2194	                pxQueue->u.xSemaphore.xMutexHolder = NULL;
.LINE 2194

	LD	BC,0
	LD	IY,(IX+%6)
	LD	(IY+%6),BC
; 2195	            }
; 2196	            else
.LINE 2196

	JR	L_251
; 2197	            {
; 2198	                mtCOVERAGE_TEST_MARKER();
; 2199	            }
; 2200	        }
; 2201	        #endif /* configUSE_MUTEXES */
; 2202	    }
; 2203	    else if( xPosition == queueSEND_TO_BACK )
.LINE 2203

L_250:
	LD	HL,(IX+%C)
	CALL	__icmpzero
	JR	NZ,L_248
; 2204	    {
; 2205	        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
.LINE 2205

	LD	IY,(IX+%6)
	LD	BC,(IY+%32)
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IY+%3)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
; 2206	        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
.LINE 2206

	LD	IY,(IX+%6)
	LD	BC,(IY+%32)
	LD	HL,(IY+%3)
	ADD	HL,BC
	LD	(IY+%3),HL
; 2207	
; 2208	        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
.LINE 2208

	LD	IY,(IX+%6)
	LD	BC,(IY+%6)
	LD	HL,(IY+%3)
	OR	A,A
	SBC	HL,BC
	JR	C,L_251
; 2209	        {
; 2210	            pxQueue->pcWriteTo = pxQueue->pcHead;
.LINE 2210

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IY+%3),BC
; 2211	        }
; 2212	        else
.LINE 2212

	JR	L_251
; 2213	        {
; 2214	            mtCOVERAGE_TEST_MARKER();
; 2215	        }
; 2216	    }
; 2217	    else
.LINE 2217

L_248:
; 2218	    {
; 2219	        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
.LINE 2219

	LD	IY,(IX+%6)
	LD	BC,(IY+%32)
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IY+%9)
	PUSH	BC
	LD	(IX+%FFFFFFF9),A
	CALL	_memcpy
	LD	A,(IX+%FFFFFFF9)
	POP	BC
	POP	BC
	POP	BC
; 2220	        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
.LINE 2220

	LD	IY,(IX+%6)
	LD	HL,(IY+%9)
	LD	BC,(IY+%32)
	OR	A,A
	SBC	HL,BC
	LD	(IY+%9),HL
; 2221	
; 2222	        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
.LINE 2222

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	HL,(IY+%9)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_241
; 2223	        {
; 2224	            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
.LINE 2224

	LD	IY,(IX+%6)
	LD	HL,(IY+%6)
	LD	BC,(IY+%32)
	OR	A,A
	SBC	HL,BC
	LD	(IY+%9),HL
; 2225	        }
; 2226	        else
L_241:
.LINE 2226

; 2227	        {
; 2228	            mtCOVERAGE_TEST_MARKER();
; 2229	        }
; 2230	
; 2231	        if( xPosition == queueOVERWRITE )
.LINE 2231

	LD	BC,2
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_245
; 2232	        {
; 2233	            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
.LINE 2233

	LD	BC,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_243
; 2234	            {
; 2235	                /* An item is not being added but overwritten, so subtract
; 2236	                 * one from the recorded number of items in the queue so when
; 2237	                 * one is added again below the number of recorded items remains
; 2238	                 * correct. */
; 2239	                --uxMessagesWaiting;
.LINE 2239

	LD	IY,(IX+%FFFFFFFD)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFFD),IY
; 2240	            }
; 2241	            else
L_243:
.LINE 2241

; 2242	            {
; 2243	                mtCOVERAGE_TEST_MARKER();
; 2244	            }
; 2245	        }
; 2246	        else
L_245:
.LINE 2246

; 2247	        {
; 2248	            mtCOVERAGE_TEST_MARKER();
; 2249	        }
; 2250	    }
L_251:
.LINE 2250

; 2251	
; 2252	    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
.LINE 2252

	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	IY,(IX+%6)
	LD	(IY+%2C),BC
; 2253	
; 2254	    return xReturn;
.LINE 2254

	LD	HL,(IX+%FFFFFFFA)
; 2255	}
.LINE 2255

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvCopyDataToQueue ***************************
;Name                         Addr/Register   Size   Type
;_memcpy                             IMPORT  -----   function
;_xTaskPriorityDisinherit            IMPORT  -----   function
;xReturn                               IX-6      3   variable
;uxMessagesWaiting                     IX-3      3   variable
;xPosition                            IX+12      3   parameter
;pvItemToQueue                         IX+9      3   parameter
;pxQueue                               IX+6      3   parameter


; Stack Frame Size: 22 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvCopyDataToQueue",2255,"_prvCopyDataToQueue"
; 2256	/*-----------------------------------------------------------*/
; 2257	
; 2258	static void prvCopyDataFromQueue( Queue_t * const pxQueue,
; 2259	                                  void * const pvBuffer )
; 2260	{
_prvCopyDataFromQueue:
.DEFINE "_prvCopyDataFromQueue"

.VALUE _prvCopyDataFromQueue

.CLASS 3

.TYPE 65

.ENDEF

.BEGFUNC "prvCopyDataFromQueue",2260,"_prvCopyDataFromQueue"

.LINE 2260

.DEFINE "pxQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "pvBuffer"

.CLASS 65

.VALUE 9

.TYPE 33

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 2261	    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
.LINE 2261

	LD	IY,(IX+%6)
	LD	HL,(IY+%32)
	CALL	__icmpzero
	JR	Z,L_257
; 2262	    {
; 2263	        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
.LINE 2263

	LD	IY,(IX+%6)
	LD	BC,(IY+%32)
	LD	HL,(IY+%9)
	ADD	HL,BC
	LD	(IY+%9),HL
; 2264	
; 2265	        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
.LINE 2265

	LD	IY,(IX+%6)
	LD	BC,(IY+%6)
	LD	HL,(IY+%9)
	OR	A,A
	SBC	HL,BC
	JR	C,L_254
; 2266	        {
; 2267	            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
.LINE 2267

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IY+%9),BC
; 2268	        }
; 2269	        else
L_254:
.LINE 2269

; 2270	        {
; 2271	            mtCOVERAGE_TEST_MARKER();
; 2272	        }
; 2273	
; 2274	        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
.LINE 2274

	LD	IY,(IX+%6)
	LD	BC,(IY+%32)
	PUSH	BC
	LD	BC,(IY+%9)
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
; 2275	    }
; 2276	}
L_257:
.LINE 2276

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvCopyDataFromQueue ***************************
;Name                         Addr/Register   Size   Type
;_memcpy                             IMPORT  -----   function
;pvBuffer                              IX+9      3   parameter
;pxQueue                               IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvCopyDataFromQueue",2276,"_prvCopyDataFromQueue"
; 2277	/*-----------------------------------------------------------*/
; 2278	
; 2279	static void prvUnlockQueue( Queue_t * const pxQueue )
; 2280	{
_prvUnlockQueue:
.DEFINE "_prvUnlockQueue"

.VALUE _prvUnlockQueue

.CLASS 3

.TYPE 65

.ENDEF

.BEGFUNC "prvUnlockQueue",2280,"_prvUnlockQueue"

.LINE 2280

.DEFINE "pxQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "cTxLock"

.CLASS 65

.VALUE -1

.TYPE 2

.ENDEF

.DEFINE "cRxLock"

.CLASS 65

.VALUE -2

.TYPE 2

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	DEC	SP
	DEC	SP
; 2281	    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
; 2282	
; 2283	    /* The lock counts contains the number of extra data items placed or
; 2284	     * removed from the queue while the queue was locked.  When a queue is
; 2285	     * locked items can be added or removed, but the event lists cannot be
; 2286	     * updated. */
; 2287	    taskENTER_CRITICAL();
.LINE 2287

	 di
; 2288	    {
; 2289	        int8_t cTxLock = pxQueue->cTxLock;
.LINE 2289

	LD	IY,(IX+%6)
	LD	A,(IY+%36)
	LD	(IX+%FFFFFFFF),A
; 2290	
; 2291	        /* See if data was added to the queue while it was locked. */
; 2292	        while( cTxLock > queueLOCKED_UNMODIFIED )
L_267:
.LINE 2292

	XOR	A,A
	CP	A,(IX+%FFFFFFFF)
	CALL	__setflag
	JP	P,L_269
; 2293	        {
; 2294	            /* Data was posted while the queue was locked.  Are any tasks
; 2295	             * blocked waiting for data to become available? */
; 2296	            #if ( configUSE_QUEUE_SETS == 1 )
; 2297	            {
; 2298	                if( pxQueue->pxQueueSetContainer != NULL )
; 2299	                {
; 2300	                    if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
; 2301	                    {
; 2302	                        /* The queue is a member of a queue set, and posting to
; 2303	                         * the queue set caused a higher priority task to unblock.
; 2304	                         * A context switch is required. */
; 2305	                        vTaskMissedYield();
; 2306	                    }
; 2307	                    else
; 2308	                    {
; 2309	                        mtCOVERAGE_TEST_MARKER();
; 2310	                    }
; 2311	                }
; 2312	                else
; 2313	                {
; 2314	                    /* Tasks that are removed from the event list will get
; 2315	                     * added to the pending ready list as the scheduler is still
; 2316	                     * suspended. */
; 2317	                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
; 2318	                    {
; 2319	                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
; 2320	                        {
; 2321	                            /* The task waiting has a higher priority so record that a
; 2322	                             * context switch is required. */
; 2323	                            vTaskMissedYield();
; 2324	                        }
; 2325	                        else
; 2326	                        {
; 2327	                            mtCOVERAGE_TEST_MARKER();
; 2328	                        }
; 2329	                    }
; 2330	                    else
; 2331	                    {
; 2332	                        break;
; 2333	                    }
; 2334	                }
; 2335	            }
; 2336	            #else /* configUSE_QUEUE_SETS */
; 2337	            {
; 2338	                /* Tasks that are removed from the event list will get added to
; 2339	                 * the pending ready list as the scheduler is still suspended. */
; 2340	                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
.LINE 2340

	LD	IY,(IX+%6)
	LD	HL,(IY+%1C)
	CALL	__icmpzero
	JR	NZ,L_260
	LD	BC,1
	LD	(IX+%FFFFFFFB),BC
	JR	L_261
L_260:
	LD	BC,0
	LD	(IX+%FFFFFFFB),BC
L_261:
	LD	HL,(IX+%FFFFFFFB)
	CALL	__icmpzero
	JR	NZ,L_269
; 2341	                {
; 2342	                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
.LINE 2342

	LD	IY,(IX+%6)
	PEA	IY+%1C
	CALL	_xTaskRemoveFromEventList
	POP	BC
	CALL	__icmpzero
	JR	Z,L_266
; 2343	                    {
; 2344	                        /* The task waiting has a higher priority so record that
; 2345	                         * a context switch is required. */
; 2346	                        vTaskMissedYield();
.LINE 2346

	CALL	_vTaskMissedYield
; 2347	                    }
; 2348	                    else
.LINE 2348

	JR	L_266
; 2349	                    {
; 2350	                        mtCOVERAGE_TEST_MARKER();
; 2351	                    }
; 2352	                }
; 2353	                else
.LINE 2353

; 2354	                {
; 2355	                    break;
.LINE 2355

	JR	L_269
; 2356	                }
; 2357	            }
L_266:
.LINE 2357

; 2358	            #endif /* configUSE_QUEUE_SETS */
; 2359	
; 2360	            --cTxLock;
.LINE 2360

	DEC	(IX+%FFFFFFFF)
; 2361	        }
.LINE 2361

	JR	L_267
L_269:
; 2362	
; 2363	        pxQueue->cTxLock = queueUNLOCKED;
.LINE 2363

	LD	IY,(IX+%6)
	LD	(IY+%36),%FF
; 2364	    }
; 2365	    taskEXIT_CRITICAL();
.LINE 2365

	 ei
; 2366	
; 2367	    /* Do the same for the Rx lock. */
; 2368	    taskENTER_CRITICAL();
.LINE 2368

	 di
; 2369	    {
; 2370	        int8_t cRxLock = pxQueue->cRxLock;
.LINE 2370

	LD	IY,(IX+%6)
	LD	A,(IY+%35)
	LD	(IX+%FFFFFFFE),A
; 2371	
; 2372	        while( cRxLock > queueLOCKED_UNMODIFIED )
L_279:
.LINE 2372

	XOR	A,A
	CP	A,(IX+%FFFFFFFE)
	CALL	__setflag
	JP	P,L_281
; 2373	        {
; 2374	            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
.LINE 2374

	LD	IY,(IX+%6)
	LD	HL,(IY+%C)
	CALL	__icmpzero
	JR	NZ,L_272
	LD	BC,1
	LD	(IX+%FFFFFFF8),BC
	JR	L_273
L_272:
	LD	BC,0
	LD	(IX+%FFFFFFF8),BC
L_273:
	LD	HL,(IX+%FFFFFFF8)
	CALL	__icmpzero
	JR	NZ,L_281
; 2375	            {
; 2376	                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
.LINE 2376

	LD	IY,(IX+%6)
	PEA	IY+%C
	CALL	_xTaskRemoveFromEventList
	POP	BC
	CALL	__icmpzero
	JR	Z,L_275
; 2377	                {
; 2378	                    vTaskMissedYield();
.LINE 2378

	CALL	_vTaskMissedYield
; 2379	                }
; 2380	                else
L_275:
.LINE 2380

; 2381	                {
; 2382	                    mtCOVERAGE_TEST_MARKER();
; 2383	                }
; 2384	
; 2385	                --cRxLock;
.LINE 2385

	DEC	(IX+%FFFFFFFE)
; 2386	            }
; 2387	            else
.LINE 2387

	JR	L_279
; 2388	            {
; 2389	                break;
; 2390	            }
; 2391	        }
L_281:
.LINE 2391

; 2392	
; 2393	        pxQueue->cRxLock = queueUNLOCKED;
.LINE 2393

	LD	IY,(IX+%6)
	LD	(IY+%35),%FF
; 2394	    }
; 2395	    taskEXIT_CRITICAL();
.LINE 2395

	 ei
; 2396	}
.LINE 2396

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvUnlockQueue ***************************
;Name                         Addr/Register   Size   Type
;_vTaskMissedYield                   IMPORT  -----   function
;_xTaskRemoveFromEventList           IMPORT  -----   function
;temp270                               IX-8      3   variable
;temp258                               IX-5      3   variable
;cRxLock                               IX-2      1   variable
;cTxLock                               IX-1      1   variable
;pxQueue                               IX+6      3   parameter


; Stack Frame Size: 17 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvUnlockQueue",2396,"_prvUnlockQueue"
; 2397	/*-----------------------------------------------------------*/
; 2398	
; 2399	static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
; 2400	{
_prvIsQueueEmpty:
.DEFINE "_prvIsQueueEmpty"

.VALUE _prvIsQueueEmpty

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "prvIsQueueEmpty",2400,"_prvIsQueueEmpty"

.LINE 2400

.DEFINE "pxQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 200

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
; 2401	    BaseType_t xReturn;
; 2402	
; 2403	    taskENTER_CRITICAL();
.LINE 2403

	 di
; 2404	    {
; 2405	        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
.LINE 2405

	LD	IY,(IX+%6)
	LD	HL,(IY+%2C)
	CALL	__icmpzero
	JR	NZ,L_284
; 2406	        {
; 2407	            xReturn = pdTRUE;
.LINE 2407

	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
; 2408	        }
; 2409	        else
.LINE 2409

	JR	L_285
L_284:
; 2410	        {
; 2411	            xReturn = pdFALSE;
.LINE 2411

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 2412	        }
; 2413	    }
L_285:
.LINE 2413

; 2414	    taskEXIT_CRITICAL();
.LINE 2414

	 ei
; 2415	
; 2416	    return xReturn;
.LINE 2416

	LD	HL,(IX+%FFFFFFFD)
; 2417	}
.LINE 2417

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvIsQueueEmpty ***************************
;Name                         Addr/Register   Size   Type
;xReturn                               IX-3      3   variable
;pxQueue                               IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvIsQueueEmpty",2417,"_prvIsQueueEmpty"
; 2418	/*-----------------------------------------------------------*/
; 2419	
; 2420	BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
; 2421	{
_xQueueIsQueueEmptyFromISR:
.DEFINE "_xQueueIsQueueEmptyFromISR"

.VALUE _xQueueIsQueueEmptyFromISR

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xQueueIsQueueEmptyFromISR",2421,"_xQueueIsQueueEmptyFromISR"

.LINE 2421

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
; 2422	    BaseType_t xReturn;
; 2423	    Queue_t * const pxQueue = xQueue;
.LINE 2423

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFA),BC
; 2424	
; 2425	    configASSERT( pxQueue );
; 2426	
; 2427	    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
.LINE 2427

	LD	IY,(IX+%FFFFFFFA)
	LD	HL,(IY+%2C)
	CALL	__icmpzero
	JR	NZ,L_288
; 2428	    {
; 2429	        xReturn = pdTRUE;
.LINE 2429

	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
; 2430	    }
; 2431	    else
.LINE 2431

	JR	L_289
L_288:
; 2432	    {
; 2433	        xReturn = pdFALSE;
.LINE 2433

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 2434	    }
L_289:
.LINE 2434

; 2435	
; 2436	    return xReturn;
.LINE 2436

	LD	HL,(IX+%FFFFFFFD)
; 2437	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
.LINE 2437

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xQueueIsQueueEmptyFromISR ***************************
;Name                         Addr/Register   Size   Type
;pxQueue                               IX-6      3   variable
;xReturn                               IX-3      3   variable
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xQueueIsQueueEmptyFromISR",2437,"_xQueueIsQueueEmptyFromISR"
; 2438	/*-----------------------------------------------------------*/
; 2439	
; 2440	static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
; 2441	{
_prvIsQueueFull:
.DEFINE "_prvIsQueueFull"

.VALUE _prvIsQueueFull

.CLASS 3

.TYPE 68

.ENDEF

.BEGFUNC "prvIsQueueFull",2441,"_prvIsQueueFull"

.LINE 2441

.DEFINE "pxQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 200

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
; 2442	    BaseType_t xReturn;
; 2443	
; 2444	    taskENTER_CRITICAL();
.LINE 2444

	 di
; 2445	    {
; 2446	        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
.LINE 2446

	LD	IY,(IX+%6)
	LD	BC,(IY+%2F)
	LD	HL,(IY+%2C)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_292
; 2447	        {
; 2448	            xReturn = pdTRUE;
.LINE 2448

	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
; 2449	        }
; 2450	        else
.LINE 2450

	JR	L_293
L_292:
; 2451	        {
; 2452	            xReturn = pdFALSE;
.LINE 2452

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 2453	        }
; 2454	    }
L_293:
.LINE 2454

; 2455	    taskEXIT_CRITICAL();
.LINE 2455

	 ei
; 2456	
; 2457	    return xReturn;
.LINE 2457

	LD	HL,(IX+%FFFFFFFD)
; 2458	}
.LINE 2458

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvIsQueueFull ***************************
;Name                         Addr/Register   Size   Type
;xReturn                               IX-3      3   variable
;pxQueue                               IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvIsQueueFull",2458,"_prvIsQueueFull"
; 2459	/*-----------------------------------------------------------*/
; 2460	
; 2461	BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
; 2462	{
_xQueueIsQueueFullFromISR:
.DEFINE "_xQueueIsQueueFullFromISR"

.VALUE _xQueueIsQueueFullFromISR

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xQueueIsQueueFullFromISR",2462,"_xQueueIsQueueFullFromISR"

.LINE 2462

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
; 2463	    BaseType_t xReturn;
; 2464	    Queue_t * const pxQueue = xQueue;
.LINE 2464

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFA),BC
; 2465	
; 2466	    configASSERT( pxQueue );
; 2467	
; 2468	    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
.LINE 2468

	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%2F)
	LD	HL,(IY+%2C)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_296
; 2469	    {
; 2470	        xReturn = pdTRUE;
.LINE 2470

	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
; 2471	    }
; 2472	    else
.LINE 2472

	JR	L_297
L_296:
; 2473	    {
; 2474	        xReturn = pdFALSE;
.LINE 2474

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 2475	    }
L_297:
.LINE 2475

; 2476	
; 2477	    return xReturn;
.LINE 2477

	LD	HL,(IX+%FFFFFFFD)
; 2478	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
.LINE 2478

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xQueueIsQueueFullFromISR ***************************
;Name                         Addr/Register   Size   Type
;pxQueue                               IX-6      3   variable
;xReturn                               IX-3      3   variable
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xQueueIsQueueFullFromISR",2478,"_xQueueIsQueueFullFromISR"
; 2479	/*-----------------------------------------------------------*/
; 2480	
; 2481	#if ( configUSE_CO_ROUTINES == 1 )
; 2482	
; 2483	    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
; 2484	                             const void * pvItemToQueue,
; 2485	                             TickType_t xTicksToWait )
; 2486	    {
_xQueueCRSend:
.DEFINE "_xQueueCRSend"

.VALUE _xQueueCRSend

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xQueueCRSend",2486,"_xQueueCRSend"

.LINE 2486

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "pvItemToQueue"

.CLASS 65

.VALUE 9

.TYPE 193

.ENDEF

.DEFINE "xTicksToWait"

.CLASS 65

.VALUE 12

.TYPE 15

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -3

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
; 2487	        BaseType_t xReturn;
; 2488	        Queue_t * const pxQueue = xQueue;
.LINE 2488

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 2489	
; 2490	        /* If the queue is already full we may have to block.  A critical section
; 2491	         * is required to prevent an interrupt removing something from the queue
; 2492	         * between the check to see if the queue is full and blocking on the queue. */
; 2493	        portDISABLE_INTERRUPTS();
.LINE 2493

	 di
; 2494	        {
; 2495	            if( prvIsQueueFull( pxQueue ) != pdFALSE )
.LINE 2495

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvIsQueueFull
	POP	BC
	CALL	__icmpzero
	JR	Z,L_302
; 2496	            {
; 2497	                /* The queue is full - do we want to block or just leave without
; 2498	                 * posting? */
; 2499	                if( xTicksToWait > ( TickType_t ) 0 )
.LINE 2499

	OR	A,A
	SBC	HL,HL
	LD	E,%0
	LD	BC,(IX+%C)
	LD	A,(IX+%F)
	CALL	__lcmpu
	JR	NC,L_300
; 2500	                {
; 2501	                    /* As this is called from a coroutine we cannot block directly, but
; 2502	                     * return indicating that we need to block. */
; 2503	                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
.LINE 2503

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%C
	LD	C,(IX+%F)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%C)
	PUSH	BC
	CALL	_vCoRoutineAddToDelayedList
	POP	BC
	POP	BC
	POP	BC
; 2504	                    portENABLE_INTERRUPTS();
.LINE 2504

	 ei
; 2505	                    return errQUEUE_BLOCKED;
.LINE 2505

	LD	HL,16777212
	JR	L_314
; 2506	                }
; 2507	                else
L_300:
.LINE 2507

; 2508	                {
; 2509	                    portENABLE_INTERRUPTS();
.LINE 2509

	 ei
; 2510	                    return errQUEUE_FULL;
.LINE 2510

	OR	A,A
	SBC	HL,HL
	JR	L_314
; 2511	                }
; 2512	            }
; 2513	        }
L_302:
.LINE 2513

; 2514	        portENABLE_INTERRUPTS();
.LINE 2514

	 ei
; 2515	
; 2516	        portDISABLE_INTERRUPTS();
.LINE 2516

	 di
; 2517	        {
; 2518	            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
.LINE 2518

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%2F)
	LD	HL,(IY+%2C)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_312
; 2519	            {
; 2520	                /* There is room in the queue, copy the data into the queue. */
; 2521	                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
.LINE 2521

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvCopyDataToQueue
	POP	BC
	POP	BC
	POP	BC
; 2522	                xReturn = pdPASS;
.LINE 2522

	LD	BC,1
	LD	(IX+%FFFFFFFA),BC
; 2523	
; 2524	                /* Were any co-routines waiting for data to become available? */
; 2525	                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
.LINE 2525

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%1C)
	CALL	__icmpzero
	JR	NZ,L_305
	LD	BC,1
	LD	(IX+%FFFFFFF7),BC
	JR	L_306
L_305:
	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
L_306:
	LD	HL,(IX+%FFFFFFF7)
	CALL	__icmpzero
	JR	NZ,L_313
; 2526	                {
; 2527	                    /* In this instance the co-routine could be placed directly
; 2528	                     * into the ready list as we are within a critical section.
; 2529	                     * Instead the same pending ready list mechanism is used as if
; 2530	                     * the event were caused from within an interrupt. */
; 2531	                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
.LINE 2531

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%1C
	CALL	_xCoRoutineRemoveFromEventList
	POP	BC
	CALL	__icmpzero
	JR	Z,L_313
; 2532	                    {
; 2533	                        /* The co-routine waiting has a higher priority so record
; 2534	                         * that a yield might be appropriate. */
; 2535	                        xReturn = errQUEUE_YIELD;
.LINE 2535

	LD	BC,16777211
	LD	(IX+%FFFFFFFA),BC
; 2536	                    }
; 2537	                    else
.LINE 2537

	JR	L_313
; 2538	                    {
; 2539	                        mtCOVERAGE_TEST_MARKER();
; 2540	                    }
; 2541	                }
; 2542	                else
.LINE 2542

; 2543	                {
; 2544	                    mtCOVERAGE_TEST_MARKER();
; 2545	                }
; 2546	            }
; 2547	            else
.LINE 2547

	JR	L_313
L_312:
; 2548	            {
; 2549	                xReturn = errQUEUE_FULL;
.LINE 2549

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
; 2550	            }
; 2551	        }
L_313:
.LINE 2551

; 2552	        portENABLE_INTERRUPTS();
.LINE 2552

	 ei
; 2553	
; 2554	        return xReturn;
.LINE 2554

	LD	HL,(IX+%FFFFFFFA)
; 2555	    }
L_314:
.LINE 2555

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xQueueCRSend ***************************
;Name                         Addr/Register   Size   Type
;_xCoRoutineRemoveFromEventList      IMPORT  -----   function
;_prvCopyDataToQueue                 STATIC  -----   function
;_vCoRoutineAddToDelayedList         IMPORT  -----   function
;_prvIsQueueFull                     STATIC  -----   function
;temp303                               IX-9      3   variable
;xReturn                               IX-6      3   variable
;pxQueue                               IX-3      3   variable
;xTicksToWait                         IX+12      4   parameter
;pvItemToQueue                         IX+9      3   parameter
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 27 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xQueueCRSend",2555,"_xQueueCRSend"
; 2556	
; 2557	#endif /* configUSE_CO_ROUTINES */
; 2558	/*-----------------------------------------------------------*/
; 2559	
; 2560	#if ( configUSE_CO_ROUTINES == 1 )
; 2561	
; 2562	    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
; 2563	                                void * pvBuffer,
; 2564	                                TickType_t xTicksToWait )
; 2565	    {
_xQueueCRReceive:
.DEFINE "_xQueueCRReceive"

.VALUE _xQueueCRReceive

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xQueueCRReceive",2565,"_xQueueCRReceive"

.LINE 2565

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "pvBuffer"

.CLASS 65

.VALUE 9

.TYPE 33

.ENDEF

.DEFINE "xTicksToWait"

.CLASS 65

.VALUE 12

.TYPE 15

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -3

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
; 2566	        BaseType_t xReturn;
; 2567	        Queue_t * const pxQueue = xQueue;
.LINE 2567

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 2568	
; 2569	        /* If the queue is already empty we may have to block.  A critical section
; 2570	         * is required to prevent an interrupt adding something to the queue
; 2571	         * between the check to see if the queue is empty and blocking on the queue. */
; 2572	        portDISABLE_INTERRUPTS();
.LINE 2572

	 di
; 2573	        {
; 2574	            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
.LINE 2574

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%2C)
	CALL	__icmpzero
	JR	NZ,L_318
; 2575	            {
; 2576	                /* There are no messages in the queue, do we want to block or just
; 2577	                 * leave with nothing? */
; 2578	                if( xTicksToWait > ( TickType_t ) 0 )
.LINE 2578

	OR	A,A
	SBC	HL,HL
	LD	E,%0
	LD	BC,(IX+%C)
	LD	A,(IX+%F)
	CALL	__lcmpu
	JR	NC,L_316
; 2579	                {
; 2580	                    /* As this is a co-routine we cannot block directly, but return
; 2581	                     * indicating that we need to block. */
; 2582	                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
.LINE 2582

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%1C
	LD	C,(IX+%F)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%C)
	PUSH	BC
	CALL	_vCoRoutineAddToDelayedList
	POP	BC
	POP	BC
	POP	BC
; 2583	                    portENABLE_INTERRUPTS();
.LINE 2583

	 ei
; 2584	                    return errQUEUE_BLOCKED;
.LINE 2584

	LD	HL,16777212
	JR	L_334
; 2585	                }
; 2586	                else
L_316:
.LINE 2586

; 2587	                {
; 2588	                    portENABLE_INTERRUPTS();
.LINE 2588

	 ei
; 2589	                    return errQUEUE_FULL;
.LINE 2589

	OR	A,A
	SBC	HL,HL
	JR	L_334
; 2590	                }
; 2591	            }
; 2592	            else
L_318:
.LINE 2592

; 2593	            {
; 2594	                mtCOVERAGE_TEST_MARKER();
; 2595	            }
; 2596	        }
; 2597	        portENABLE_INTERRUPTS();
.LINE 2597

	 ei
; 2598	
; 2599	        portDISABLE_INTERRUPTS();
.LINE 2599

	 di
; 2600	        {
; 2601	            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
.LINE 2601

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%2C)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_332
; 2602	            {
; 2603	                /* Data is available from the queue. */
; 2604	                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
.LINE 2604

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%32)
	LD	HL,(IY+%9)
	ADD	HL,BC
	LD	(IY+%9),HL
; 2605	
; 2606	                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
.LINE 2606

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%6)
	LD	HL,(IY+%9)
	OR	A,A
	SBC	HL,BC
	JR	C,L_321
; 2607	                {
; 2608	                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
.LINE 2608

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%0)
	LD	(IY+%9),BC
; 2609	                }
; 2610	                else
L_321:
.LINE 2610

; 2611	                {
; 2612	                    mtCOVERAGE_TEST_MARKER();
; 2613	                }
; 2614	
; 2615	                --( pxQueue->uxMessagesWaiting );
.LINE 2615

	LD	IY,(IX+%FFFFFFFD)
	LD	IY,(IY+%2C)
	LEA	BC,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%2C),BC
; 2616	                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
.LINE 2616

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%32)
	PUSH	BC
	LD	BC,(IY+%9)
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
; 2617	
; 2618	                xReturn = pdPASS;
.LINE 2618

	LD	BC,1
	LD	(IX+%FFFFFFFA),BC
; 2619	
; 2620	                /* Were any co-routines waiting for space to become available? */
; 2621	                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
.LINE 2621

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%C)
	CALL	__icmpzero
	JR	NZ,L_325
	LD	BC,1
	LD	(IX+%FFFFFFF7),BC
	JR	L_326
L_325:
	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
L_326:
	LD	HL,(IX+%FFFFFFF7)
	CALL	__icmpzero
	JR	NZ,L_333
; 2622	                {
; 2623	                    /* In this instance the co-routine could be placed directly
; 2624	                     * into the ready list as we are within a critical section.
; 2625	                     * Instead the same pending ready list mechanism is used as if
; 2626	                     * the event were caused from within an interrupt. */
; 2627	                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
.LINE 2627

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%C
	CALL	_xCoRoutineRemoveFromEventList
	POP	BC
	CALL	__icmpzero
	JR	Z,L_333
; 2628	                    {
; 2629	                        xReturn = errQUEUE_YIELD;
.LINE 2629

	LD	BC,16777211
	LD	(IX+%FFFFFFFA),BC
; 2630	                    }
; 2631	                    else
.LINE 2631

	JR	L_333
; 2632	                    {
; 2633	                        mtCOVERAGE_TEST_MARKER();
; 2634	                    }
; 2635	                }
; 2636	                else
.LINE 2636

; 2637	                {
; 2638	                    mtCOVERAGE_TEST_MARKER();
; 2639	                }
; 2640	            }
; 2641	            else
.LINE 2641

	JR	L_333
L_332:
; 2642	            {
; 2643	                xReturn = pdFAIL;
.LINE 2643

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
; 2644	            }
; 2645	        }
L_333:
.LINE 2645

; 2646	        portENABLE_INTERRUPTS();
.LINE 2646

	 ei
; 2647	
; 2648	        return xReturn;
.LINE 2648

	LD	HL,(IX+%FFFFFFFA)
; 2649	    }
L_334:
.LINE 2649

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xQueueCRReceive ***************************
;Name                         Addr/Register   Size   Type
;_xCoRoutineRemoveFromEventList      IMPORT  -----   function
;_memcpy                             IMPORT  -----   function
;_vCoRoutineAddToDelayedList         IMPORT  -----   function
;temp323                               IX-9      3   variable
;xReturn                               IX-6      3   variable
;pxQueue                               IX-3      3   variable
;xTicksToWait                         IX+12      4   parameter
;pvBuffer                              IX+9      3   parameter
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 27 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xQueueCRReceive",2649,"_xQueueCRReceive"
; 2650	
; 2651	#endif /* configUSE_CO_ROUTINES */
; 2652	/*-----------------------------------------------------------*/
; 2653	
; 2654	#if ( configUSE_CO_ROUTINES == 1 )
; 2655	
; 2656	    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
; 2657	                                    const void * pvItemToQueue,
; 2658	                                    BaseType_t xCoRoutinePreviouslyWoken )
; 2659	    {
_xQueueCRSendFromISR:
.DEFINE "_xQueueCRSendFromISR"

.VALUE _xQueueCRSendFromISR

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xQueueCRSendFromISR",2659,"_xQueueCRSendFromISR"

.LINE 2659

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "pvItemToQueue"

.CLASS 65

.VALUE 9

.TYPE 193

.ENDEF

.DEFINE "xCoRoutinePreviouslyWoken"

.CLASS 65

.VALUE 12

.TYPE 4

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -3

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
; 2660	        Queue_t * const pxQueue = xQueue;
.LINE 2660

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 2661	
; 2662	        /* Cannot block within an ISR so if there is no space on the queue then
; 2663	         * exit without doing anything. */
; 2664	        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
.LINE 2664

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%2F)
	LD	HL,(IY+%2C)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_346
; 2665	        {
; 2666	            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
.LINE 2666

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvCopyDataToQueue
	POP	BC
	POP	BC
	POP	BC
; 2667	
; 2668	            /* We only want to wake one co-routine per ISR, so check that a
; 2669	             * co-routine has not already been woken. */
; 2670	            if( xCoRoutinePreviouslyWoken == pdFALSE )
.LINE 2670

	LD	HL,(IX+%C)
	CALL	__icmpzero
	JR	NZ,L_344
; 2671	            {
; 2672	                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
.LINE 2672

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%1C)
	CALL	__icmpzero
	JR	NZ,L_337
	LD	BC,1
	LD	(IX+%FFFFFFFA),BC
	JR	L_338
L_337:
	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
L_338:
	LD	HL,(IX+%FFFFFFFA)
	CALL	__icmpzero
	JR	NZ,L_342
; 2673	                {
; 2674	                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
.LINE 2674

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%1C
	CALL	_xCoRoutineRemoveFromEventList
	POP	BC
	CALL	__icmpzero
	JR	Z,L_340
; 2675	                    {
; 2676	                        return pdTRUE;
.LINE 2676

	LD	HL,1
	JR	L_348
; 2677	                    }
; 2678	                    else
L_340:
.LINE 2678

; 2679	                    {
; 2680	                        mtCOVERAGE_TEST_MARKER();
; 2681	                    }
; 2682	                }
; 2683	                else
L_342:
.LINE 2683

; 2684	                {
; 2685	                    mtCOVERAGE_TEST_MARKER();
; 2686	                }
; 2687	            }
; 2688	            else
L_344:
.LINE 2688

; 2689	            {
; 2690	                mtCOVERAGE_TEST_MARKER();
; 2691	            }
; 2692	        }
; 2693	        else
L_346:
.LINE 2693

; 2694	        {
; 2695	            mtCOVERAGE_TEST_MARKER();
; 2696	        }
; 2697	
; 2698	        return xCoRoutinePreviouslyWoken;
.LINE 2698

	LD	HL,(IX+%C)
; 2699	    }
L_348:
.LINE 2699

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xQueueCRSendFromISR ***************************
;Name                         Addr/Register   Size   Type
;_xCoRoutineRemoveFromEventList      IMPORT  -----   function
;_prvCopyDataToQueue                 STATIC  -----   function
;temp335                               IX-6      3   variable
;pxQueue                               IX-3      3   variable
;xCoRoutinePreviouslyWoken            IX+12      3   parameter
;pvItemToQueue                         IX+9      3   parameter
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xQueueCRSendFromISR",2699,"_xQueueCRSendFromISR"
; 2700	
; 2701	#endif /* configUSE_CO_ROUTINES */
; 2702	/*-----------------------------------------------------------*/
; 2703	
; 2704	#if ( configUSE_CO_ROUTINES == 1 )
; 2705	
; 2706	    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
; 2707	                                       void * pvBuffer,
; 2708	                                       BaseType_t * pxCoRoutineWoken )
; 2709	    {
_xQueueCRReceiveFromISR:
.DEFINE "_xQueueCRReceiveFromISR"

.VALUE _xQueueCRReceiveFromISR

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xQueueCRReceiveFromISR",2709,"_xQueueCRReceiveFromISR"

.LINE 2709

.DEFINE "xQueue"

.CLASS 65

.VALUE 6

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "pvBuffer"

.CLASS 65

.VALUE 9

.TYPE 33

.ENDEF

.DEFINE "pxCoRoutineWoken"

.CLASS 65

.VALUE 12

.TYPE 36

.ENDEF

.DEFINE "pxQueue"

.CLASS 65

.VALUE -3

.TAG "QueueDefinition"

.TYPE 40

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
; 2710	        BaseType_t xReturn;
; 2711	        Queue_t * const pxQueue = xQueue;
.LINE 2711

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 2712	
; 2713	        /* We cannot block from an ISR, so check there is data available. If
; 2714	         * not then just leave without doing anything. */
; 2715	        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
.LINE 2715

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%2C)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_364
; 2716	        {
; 2717	            /* Copy the data from the queue. */
; 2718	            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
.LINE 2718

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%32)
	LD	HL,(IY+%9)
	ADD	HL,BC
	LD	(IY+%9),HL
; 2719	
; 2720	            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
.LINE 2720

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%6)
	LD	HL,(IY+%9)
	OR	A,A
	SBC	HL,BC
	JR	C,L_350
; 2721	            {
; 2722	                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
.LINE 2722

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%0)
	LD	(IY+%9),BC
; 2723	            }
; 2724	            else
L_350:
.LINE 2724

; 2725	            {
; 2726	                mtCOVERAGE_TEST_MARKER();
; 2727	            }
; 2728	
; 2729	            --( pxQueue->uxMessagesWaiting );
.LINE 2729

	LD	IY,(IX+%FFFFFFFD)
	LD	IY,(IY+%2C)
	LEA	BC,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%2C),BC
; 2730	            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
.LINE 2730

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%32)
	PUSH	BC
	LD	BC,(IY+%9)
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	_memcpy
	POP	BC
	POP	BC
	POP	BC
; 2731	
; 2732	            if( ( *pxCoRoutineWoken ) == pdFALSE )
.LINE 2732

	LD	HL,(IX+%C)
	LD	HL,(HL)
	CALL	__icmpzero
	JR	NZ,L_361
; 2733	            {
; 2734	                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
.LINE 2734

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%C)
	CALL	__icmpzero
	JR	NZ,L_354
	LD	BC,1
	LD	(IX+%FFFFFFF7),BC
	JR	L_355
L_354:
	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
L_355:
	LD	HL,(IX+%FFFFFFF7)
	CALL	__icmpzero
	JR	NZ,L_359
; 2735	                {
; 2736	                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
.LINE 2736

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%C
	CALL	_xCoRoutineRemoveFromEventList
	POP	BC
	CALL	__icmpzero
	JR	Z,L_357
; 2737	                    {
; 2738	                        *pxCoRoutineWoken = pdTRUE;
.LINE 2738

	LD	HL,(IX+%C)
	LD	BC,1
	LD	(HL),BC
; 2739	                    }
; 2740	                    else
L_357:
.LINE 2740

; 2741	                    {
; 2742	                        mtCOVERAGE_TEST_MARKER();
; 2743	                    }
; 2744	                }
; 2745	                else
L_359:
.LINE 2745

; 2746	                {
; 2747	                    mtCOVERAGE_TEST_MARKER();
; 2748	                }
; 2749	            }
; 2750	            else
L_361:
.LINE 2750

; 2751	            {
; 2752	                mtCOVERAGE_TEST_MARKER();
; 2753	            }
; 2754	
; 2755	            xReturn = pdPASS;
.LINE 2755

	LD	BC,1
	LD	(IX+%FFFFFFFA),BC
; 2756	        }
; 2757	        else
.LINE 2757

	JR	L_365
L_364:
; 2758	        {
; 2759	            xReturn = pdFAIL;
.LINE 2759

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
; 2760	        }
L_365:
.LINE 2760

; 2761	
; 2762	        return xReturn;
.LINE 2762

	LD	HL,(IX+%FFFFFFFA)
; 2763	    }
.LINE 2763

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xQueueCRReceiveFromISR ***************************
;Name                         Addr/Register   Size   Type
;_xCoRoutineRemoveFromEventList      IMPORT  -----   function
;_memcpy                             IMPORT  -----   function
;temp352                               IX-9      3   variable
;xReturn                               IX-6      3   variable
;pxQueue                               IX-3      3   variable
;pxCoRoutineWoken                     IX+12      3   parameter
;pvBuffer                              IX+9      3   parameter
;xQueue                                IX+6      3   parameter


; Stack Frame Size: 24 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xQueueCRReceiveFromISR",2763,"_xQueueCRReceiveFromISR"
	XREF _xCoRoutineRemoveFromEventList:ROM
	XREF _vCoRoutineAddToDelayedList:ROM
	XREF _vTaskInternalSetTimeOutState:ROM
	XREF _pvTaskIncrementMutexHeldCount:ROM
	XREF _vTaskPriorityDisinheritAfterTimeout:ROM
	XREF _xTaskPriorityDisinherit:ROM
	XREF _xTaskPriorityInherit:ROM
	XREF _vTaskMissedYield:ROM
	XREF _xTaskRemoveFromEventList:ROM
	XREF _vTaskPlaceOnEventList:ROM
	XREF _xTaskCheckForTimeOut:ROM
	XREF _uxTaskGetNumberOfTasks:ROM
	XREF _xTaskResumeAll:ROM
	XREF _vTaskSuspendAll:ROM
	XREF _vListInitialise:ROM
	XREF _vPortFree:ROM
	XREF _pvPortMalloc:ROM
	XREF _vPortYield:ROM
	XREF _memcpy:ROM
	XREF __lcmpu:ROM
	XREF __idivu:ROM
	XREF __imulu:ROM
	XREF __setflag:ROM
	XREF __icmpzero:ROM
	XREF __lcmpzero:ROM
	XDEF _xQueueCRReceiveFromISR
	XDEF _xQueueCRSendFromISR
	XDEF _xQueueCRReceive
	XDEF _xQueueCRSend
	XDEF _xQueueIsQueueFullFromISR
	XDEF _xQueueIsQueueEmptyFromISR
	XDEF _vQueueDelete
	XDEF _uxQueueMessagesWaitingFromISR
	XDEF _uxQueueSpacesAvailable
	XDEF _uxQueueMessagesWaiting
	XDEF _xQueuePeekFromISR
	XDEF _xQueueReceiveFromISR
	XDEF _xQueuePeek
	XDEF _xQueueSemaphoreTake
	XDEF _xQueueReceive
	XDEF _xQueueGiveFromISR
	XDEF _xQueueGenericSendFromISR
	XDEF _xQueueGenericSend
	XDEF _xQueueCreateMutex
	XDEF _xQueueGenericCreate
	XDEF _xQueueGenericReset
	END
