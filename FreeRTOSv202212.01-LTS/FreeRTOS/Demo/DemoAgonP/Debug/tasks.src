; Zilog eZ80 ANSI C Compiler Release 3.4
; -noglobalopt -nolocalcse -optsize -nomodsect -reduceopt
; -nopadbranch -debug -peephole -const=ROM 
	FILE	"..\..\..\Source\portable\ThirdParty\Community-Supported-Ports\ZDSII\eZ80AgonLight\tasks.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "NONAME0",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME1"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME2"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME2",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME2"
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "HeapRegion",6
.DEFINE "pucStartAddress"
.VALUE 0
.CLASS 8
.TYPE 44
.ENDEF
.DEFINE "xSizeInBytes"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "HeapRegion"
.BEGREC "xHeapStats",21
.DEFINE "xAvailableHeapSpaceInBytes"
.VALUE 0
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "xSizeOfLargestFreeBlockInBytes"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "xSizeOfSmallestFreeBlockInBytes"
.VALUE 6
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "xNumberOfFreeBlocks"
.VALUE 9
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "xMinimumEverFreeBytesRemaining"
.VALUE 12
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "xNumberOfSuccessfulAllocations"
.VALUE 15
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "xNumberOfSuccessfulFrees"
.VALUE 18
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "xHeapStats"
.BEGREC "xSTATIC_LIST_ITEM",16
.DEFINE "xDummy2"
.VALUE 0
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "pvDummy3"
.VALUE 4
.CLASS 8
.DIM 4
.TYPE 353
.ENDEF
.ENDREC "xSTATIC_LIST_ITEM"
.BEGREC "xSTATIC_MINI_LIST_ITEM",10
.DEFINE "xDummy2"
.VALUE 0
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "pvDummy3"
.VALUE 4
.CLASS 8
.DIM 2
.TYPE 353
.ENDEF
.ENDREC "xSTATIC_MINI_LIST_ITEM"
.BEGREC "xSTATIC_LIST",16
.DEFINE "uxDummy2"
.VALUE 0
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "pvDummy3"
.VALUE 3
.CLASS 8
.TYPE 33
.ENDEF
.DEFINE "xDummy4"
.VALUE 6
.CLASS 8
.TAG "xSTATIC_MINI_LIST_ITEM"
.TYPE 8
.ENDEF
.ENDREC "xSTATIC_LIST"
.BEGREC "xSTATIC_TCB",69
.DEFINE "pxDummy1"
.VALUE 0
.CLASS 8
.TYPE 33
.ENDEF
.DEFINE "xDummy3"
.VALUE 3
.CLASS 8
.DIM 2
.TAG "xSTATIC_LIST_ITEM"
.TYPE 104
.ENDEF
.DEFINE "uxDummy5"
.VALUE 35
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "pxDummy6"
.VALUE 38
.CLASS 8
.TYPE 33
.ENDEF
.DEFINE "ucDummy7"
.VALUE 41
.CLASS 8
.DIM 16
.TYPE 108
.ENDEF
.DEFINE "uxDummy12"
.VALUE 57
.CLASS 8
.DIM 2
.TYPE 110
.ENDEF
.DEFINE "ulDummy18"
.VALUE 63
.CLASS 8
.DIM 1
.TYPE 111
.ENDEF
.DEFINE "ucDummy19"
.VALUE 67
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.DEFINE "ucDummy21"
.VALUE 68
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "xSTATIC_TCB"
.BEGREC "xSTATIC_QUEUE",55
.DEFINE "pvDummy1"
.VALUE 0
.CLASS 8
.DIM 3
.TYPE 353
.ENDEF
.DEFINE "u"
.VALUE 9
.CLASS 8
.TAG "NONAME3"
.TYPE 8
.ENDEF
.DEFINE "xDummy3"
.VALUE 12
.CLASS 8
.DIM 2
.TAG "xSTATIC_LIST"
.TYPE 104
.ENDEF
.DEFINE "uxDummy4"
.VALUE 44
.CLASS 8
.DIM 3
.TYPE 110
.ENDEF
.DEFINE "ucDummy5"
.VALUE 53
.CLASS 8
.DIM 2
.TYPE 108
.ENDEF
.ENDREC "xSTATIC_QUEUE"
.BEGREC "NONAME3",3
.DEFINE "pvDummy2"
.VALUE 0
.CLASS 11
.TYPE 33
.ENDEF
.DEFINE "uxDummy2"
.VALUE 0
.CLASS 11
.TYPE 14
.ENDEF
.ENDREC "NONAME3"
.BEGREC "xSTATIC_EVENT_GROUP",20
.DEFINE "xDummy1"
.VALUE 0
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "xDummy2"
.VALUE 4
.CLASS 8
.TAG "xSTATIC_LIST"
.TYPE 8
.ENDEF
.ENDREC "xSTATIC_EVENT_GROUP"
.BEGREC "xSTATIC_TIMER",30
.DEFINE "pvDummy1"
.VALUE 0
.CLASS 8
.TYPE 33
.ENDEF
.DEFINE "xDummy2"
.VALUE 3
.CLASS 8
.TAG "xSTATIC_LIST_ITEM"
.TYPE 8
.ENDEF
.DEFINE "xDummy3"
.VALUE 19
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "pvDummy5"
.VALUE 23
.CLASS 8
.TYPE 33
.ENDEF
.DEFINE "pvDummy6"
.VALUE 26
.CLASS 8
.TYPE 545
.ENDEF
.DEFINE "ucDummy8"
.VALUE 29
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "xSTATIC_TIMER"
.BEGREC "xSTATIC_STREAM_BUFFER",22
.DEFINE "uxDummy1"
.VALUE 0
.CLASS 8
.DIM 4
.TYPE 110
.ENDEF
.DEFINE "pvDummy2"
.VALUE 12
.CLASS 8
.DIM 3
.TYPE 353
.ENDEF
.DEFINE "ucDummy3"
.VALUE 21
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "xSTATIC_STREAM_BUFFER"
.BEGREC "xLIST_ITEM",16
.DEFINE "xItemValue"
.VALUE 0
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "pxNext"
.VALUE 4
.CLASS 8
.TAG "xLIST_ITEM"
.TYPE 40
.ENDEF
.DEFINE "pxPrevious"
.VALUE 7
.CLASS 8
.TAG "xLIST_ITEM"
.TYPE 40
.ENDEF
.DEFINE "pvOwner"
.VALUE 10
.CLASS 8
.TYPE 33
.ENDEF
.DEFINE "pvContainer"
.VALUE 13
.CLASS 8
.TAG "xLIST"
.TYPE 40
.ENDEF
.ENDREC "xLIST_ITEM"
.BEGREC "xMINI_LIST_ITEM",10
.DEFINE "xItemValue"
.VALUE 0
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "pxNext"
.VALUE 4
.CLASS 8
.TAG "xLIST_ITEM"
.TYPE 40
.ENDEF
.DEFINE "pxPrevious"
.VALUE 7
.CLASS 8
.TAG "xLIST_ITEM"
.TYPE 40
.ENDEF
.ENDREC "xMINI_LIST_ITEM"
.BEGREC "xLIST",16
.DEFINE "uxNumberOfItems"
.VALUE 0
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "pxIndex"
.VALUE 3
.CLASS 8
.TAG "xLIST_ITEM"
.TYPE 40
.ENDEF
.DEFINE "xListEnd"
.VALUE 6
.CLASS 8
.TAG "xMINI_LIST_ITEM"
.TYPE 8
.ENDEF
.ENDREC "xLIST"
.BEGREC "xTIME_OUT",7
.DEFINE "xOverflowCount"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "xTimeOnEntering"
.VALUE 3
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "xTIME_OUT"
.BEGREC "xMEMORY_REGION",11
.DEFINE "pvBaseAddress"
.VALUE 0
.CLASS 8
.TYPE 33
.ENDEF
.DEFINE "ulLengthInBytes"
.VALUE 3
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "ulParameters"
.VALUE 7
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "xMEMORY_REGION"
.BEGREC "xTASK_PARAMETERS",29
.DEFINE "pvTaskCode"
.VALUE 0
.CLASS 8
.TYPE 545
.ENDEF
.DEFINE "pcName"
.VALUE 3
.CLASS 8
.TYPE 194
.ENDEF
.DEFINE "usStackDepth"
.VALUE 6
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "pvParameters"
.VALUE 9
.CLASS 8
.TYPE 33
.ENDEF
.DEFINE "uxPriority"
.VALUE 12
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "puxStackBuffer"
.VALUE 15
.CLASS 8
.TYPE 46
.ENDEF
.DEFINE "xRegions"
.VALUE 18
.CLASS 8
.DIM 1
.TAG "xMEMORY_REGION"
.TYPE 104
.ENDEF
.ENDREC "xTASK_PARAMETERS"
.BEGREC "xTASK_STATUS",28
.DEFINE "xHandle"
.VALUE 0
.CLASS 8
.TAG "tskTaskControlBlock"
.TYPE 40
.ENDEF
.DEFINE "pcTaskName"
.VALUE 3
.CLASS 8
.TYPE 194
.ENDEF
.DEFINE "xTaskNumber"
.VALUE 6
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "eCurrentState"
.VALUE 9
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "uxCurrentPriority"
.VALUE 12
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "uxBasePriority"
.VALUE 15
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "ulRunTimeCounter"
.VALUE 18
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "pxStackBase"
.VALUE 22
.CLASS 8
.TYPE 46
.ENDEF
.DEFINE "usStackHighWaterMark"
.VALUE 25
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "xTASK_STATUS"
;    1	/*
;    2	 * FreeRTOS Kernel V10.5.1
;    3	 * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
;    4	 *
;    5	 * SPDX-License-Identifier: MIT
;    6	 *
;    7	 * Permission is hereby granted, free of charge, to any person obtaining a copy of
;    8	 * this software and associated documentation files (the "Software"), to deal in
;    9	 * the Software without restriction, including without limitation the rights to
;   10	 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
;   11	 * the Software, and to permit persons to whom the Software is furnished to do so,
;   12	 * subject to the following conditions:
;   13	 *
;   14	 * The above copyright notice and this permission notice shall be included in all
;   15	 * copies or substantial portions of the Software.
;   16	 *
;   17	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;   18	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
;   19	 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
;   20	 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
;   21	 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
;   22	 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
;   23	 *
;   24	 * https://www.FreeRTOS.org
;   25	 * https://github.com/FreeRTOS
;   26	 *
;   27	 * Modified for EZ80 Agon Light port
;   28	 *   Bug fix to work around ZDSII compiler internal error when casting away 
;   29	 *   globals in vTaskStartScheduler
;   30	 *
;   31	 */
;   32	
;   33	/* Standard includes. */
;   34	#include <stdlib.h>
;   35	#include <string.h>
;   36	#if defined( _DEBUG )
;   37	#	include <stdio.h>
;   38	#endif
;   39	
;   40	/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
;   41	 * all the API functions to use the MPU wrappers.  That should only be done when
;   42	 * task.h is included from an application file. */
;   43	#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
;   44	
;   45	/* FreeRTOS includes. */
;   46	#include "FreeRTOS.h"
;   47	#include "task.h"
;   48	#include "timers.h"
;   49	#include "stack_macros.h"
;   50	
;   51	/* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
;   52	 * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
;   53	 * for the header files above, but not in this file, in order to generate the
;   54	 * correct privileged Vs unprivileged linkage and placement. */
;   55	#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
;   56	
;   57	/* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
;   58	 * functions but without including stdio.h here. */
;   59	#if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
;   60	
;   61	/* At the bottom of this file are two optional functions that can be used
;   62	 * to generate human readable text from the raw data generated by the
;   63	 * uxTaskGetSystemState() function.  Note the formatting functions are provided
;   64	 * for convenience only, and are NOT considered part of the kernel. */
;   65	    #include <stdio.h>
;   66	#endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
;   67	
;   68	#if ( configUSE_PREEMPTION == 0 )
;   69	
;   70	/* If the cooperative scheduler is being used then a yield should not be
;   71	 * performed just because a higher priority task has been woken. */
;   72	    #define taskYIELD_IF_USING_PREEMPTION()
;   73	#else
;   74	    #define taskYIELD_IF_USING_PREEMPTION()    portYIELD_WITHIN_API()
;   75	#endif
;   76	
;   77	/* Values that can be assigned to the ucNotifyState member of the TCB. */
;   78	#define taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 ) /* Must be zero as it is the initialised value. */
;   79	#define taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )
;   80	#define taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )
;   81	
;   82	/*
;   83	 * The value used to fill the stack of a task when the task is created.  This
;   84	 * is used purely for checking the high water mark for tasks.
;   85	 */
;   86	#define tskSTACK_FILL_BYTE                        ( 0xa5U )
;   87	
;   88	/* Bits used to record how a task's stack and TCB were allocated. */
;   89	#define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB    ( ( uint8_t ) 0 )
;   90	#define tskSTATICALLY_ALLOCATED_STACK_ONLY        ( ( uint8_t ) 1 )
;   91	#define tskSTATICALLY_ALLOCATED_STACK_AND_TCB     ( ( uint8_t ) 2 )
;   92	
;   93	/* If any of the following are set then task stacks are filled with a known
;   94	 * value so the high water mark can be determined.  If none of the following are
;   95	 * set then don't fill the stack so there is no unnecessary dependency on memset. */
;   96	#if ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )
;   97	    #define tskSET_NEW_STACKS_TO_KNOWN_VALUE    1
;   98	#else
;   99	    #define tskSET_NEW_STACKS_TO_KNOWN_VALUE    0
;  100	#endif
;  101	
;  102	/*
;  103	 * Macros used by vListTask to indicate which state a task is in.
;  104	 */
;  105	#define tskRUNNING_CHAR      ( 'X' )
;  106	#define tskBLOCKED_CHAR      ( 'B' )
;  107	#define tskREADY_CHAR        ( 'R' )
;  108	#define tskDELETED_CHAR      ( 'D' )
;  109	#define tskSUSPENDED_CHAR    ( 'S' )
;  110	
;  111	/*
;  112	 * Some kernel aware debuggers require the data the debugger needs access to to
;  113	 * be global, rather than file scope.
;  114	 */
;  115	#ifdef portREMOVE_STATIC_QUALIFIER
;  116	    #define static
;  117	#endif
;  118	
;  119	/* The name allocated to the Idle task.  This can be overridden by defining
;  120	 * configIDLE_TASK_NAME in FreeRTOSConfig.h. */
;  121	#ifndef configIDLE_TASK_NAME
;  122	    #define configIDLE_TASK_NAME    "IDLE"
;  123	#endif
;  124	
;  125	#if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
;  126	
;  127	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
;  128	 * performed in a generic way that is not optimised to any particular
;  129	 * microcontroller architecture. */
;  130	
;  131	/* uxTopReadyPriority holds the priority of the highest priority ready
;  132	 * state task. */
;  133	    #define taskRECORD_READY_PRIORITY( uxPriority ) \
;  134	    {                                               \
;  135	        if( ( uxPriority ) > uxTopReadyPriority )   \
;  136	        {                                           \
;  137	            uxTopReadyPriority = ( uxPriority );    \
;  138	        }                                           \
;  139	    } /* taskRECORD_READY_PRIORITY */
;  140	
;  141	/*-----------------------------------------------------------*/
;  142	
;  143	    #define taskSELECT_HIGHEST_PRIORITY_TASK()                                \
;  144	    {                                                                         \
;  145	        UBaseType_t uxTopPriority = uxTopReadyPriority;                       \
;  146	                                                                              \
;  147	        /* Find the highest priority queue that contains ready tasks. */      \
;  148	        while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) ) \
;  149	        {                                                                     \
;  150	            configASSERT( uxTopPriority );                                    \
;  151	            --uxTopPriority;                                                  \
;  152	        }                                                                     \
;  153	                                                                              \
;  154	        /* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of \
;  155	         * the  same priority get an equal share of the processor time. */                    \
;  156	        listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) ); \
;  157	        uxTopReadyPriority = uxTopPriority;                                                   \
;  158	    } /* taskSELECT_HIGHEST_PRIORITY_TASK */
;  159	
;  160	/*-----------------------------------------------------------*/
;  161	
;  162	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
;  163	 * they are only required when a port optimised method of task selection is
;  164	 * being used. */
;  165	    #define taskRESET_READY_PRIORITY( uxPriority )
;  166	    #define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
;  167	
;  168	#else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
;  169	
;  170	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
;  171	 * performed in a way that is tailored to the particular microcontroller
;  172	 * architecture being used. */
;  173	
;  174	/* A port optimised version is provided.  Call the port defined macros. */
;  175	    #define taskRECORD_READY_PRIORITY( uxPriority )    portRECORD_READY_PRIORITY( ( uxPriority ), uxTopReadyPriority )
;  176	
;  177	/*-----------------------------------------------------------*/
;  178	
;  179	    #define taskSELECT_HIGHEST_PRIORITY_TASK()                                                  \
;  180	    {                                                                                           \
;  181	        UBaseType_t uxTopPriority;                                                              \
;  182	                                                                                                \
;  183	        /* Find the highest priority list that contains ready tasks. */                         \
;  184	        portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );                          \
;  185	        configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 ); \
;  186	        listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );   \
;  187	    } /* taskSELECT_HIGHEST_PRIORITY_TASK() */
;  188	
;  189	/*-----------------------------------------------------------*/
;  190	
;  191	/* A port optimised version is provided, call it only if the TCB being reset
;  192	 * is being referenced from a ready list.  If it is referenced from a delayed
;  193	 * or suspended list then it won't be in a ready list. */
;  194	    #define taskRESET_READY_PRIORITY( uxPriority )                                                     \
;  195	    {                                                                                                  \
;  196	        if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 ) \
;  197	        {                                                                                              \
;  198	            portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );                        \
;  199	        }                                                                                              \
;  200	    }
;  201	
;  202	#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
;  203	
;  204	/*-----------------------------------------------------------*/
;  205	
;  206	/* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
;  207	 * count overflows. */
;  208	#define taskSWITCH_DELAYED_LISTS()                                                \
;  209	    {                                                                             \
;  210	        List_t * pxTemp;                                                          \
;  211	                                                                                  \
;  212	        /* The delayed tasks list should be empty when the lists are switched. */ \
;  213	        configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );               \
;  214	                                                                                  \
;  215	        pxTemp = pxDelayedTaskList;                                               \
;  216	        pxDelayedTaskList = pxOverflowDelayedTaskList;                            \
;  217	        pxOverflowDelayedTaskList = pxTemp;                                       \
;  218	        xNumOfOverflows++;                                                        \
;  219	        prvResetNextTaskUnblockTime();                                            \
;  220	    }
;  221	
;  222	/*-----------------------------------------------------------*/
;  223	
;  224	/*
;  225	 * Place the task represented by pxTCB into the appropriate ready list for
;  226	 * the task.  It is inserted at the end of the list.
;  227	 */
;  228	#define prvAddTaskToReadyList( pxTCB )                                                                 \
;  229	    traceMOVED_TASK_TO_READY_STATE( pxTCB );                                                           \
;  230	    taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );                                                \
;  231	    listINSERT_END( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
;  232	    tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
;  233	/*-----------------------------------------------------------*/
;  234	
;  235	/*
;  236	 * Several functions take a TaskHandle_t parameter that can optionally be NULL,
;  237	 * where NULL is used to indicate that the handle of the currently executing
;  238	 * task should be used in place of the parameter.  This macro simply checks to
;  239	 * see if the parameter is NULL and returns a pointer to the appropriate TCB.
;  240	 */
;  241	#define prvGetTCBFromHandle( pxHandle )    ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )
;  242	
;  243	/* The item value of the event list item is normally used to hold the priority
;  244	 * of the task to which it belongs (coded to allow it to be held in reverse
;  245	 * priority order).  However, it is occasionally borrowed for other purposes.  It
;  246	 * is important its value is not updated due to a task priority change while it is
;  247	 * being used for another purpose.  The following bit definition is used to inform
;  248	 * the scheduler that the value should not be changed - in which case it is the
;  249	 * responsibility of whichever module is using the value to ensure it gets set back
;  250	 * to its original value when it is released. */
;  251	#if ( configUSE_16_BIT_TICKS == 1 )
;  252	    #define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x8000U
;  253	#else
;  254	    #define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x80000000UL
;  255	#endif
;  256	
;  257	/*
;  258	 * Task control block.  A task control block (TCB) is allocated for each task,
;  259	 * and stores task state information, including a pointer to the task's context
;  260	 * (the task's run time environment, including register values)
;  261	 */
;  262	typedef struct tskTaskControlBlock       /* The old naming convention is used to prevent breaking kernel aware debuggers. */
;  263	{
;  264	    volatile StackType_t * pxTopOfStack; /*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
;  265	
;  266	    #if ( portUSING_MPU_WRAPPERS == 1 )
;  267	        xMPU_SETTINGS xMPUSettings; /*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
;  268	    #endif
;  269	
;  270	    ListItem_t xStateListItem;                  /*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
;  271	    ListItem_t xEventListItem;                  /*< Used to reference a task from an event list. */
;  272	    UBaseType_t uxPriority;                     /*< The priority of the task.  0 is the lowest priority. */
;  273	    StackType_t * pxStack;                      /*< Points to the start of the stack. */
;  274	    char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;  275	
;  276	    #if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
;  277	        StackType_t * pxEndOfStack; /*< Points to the highest valid address for the stack. */
;  278	    #endif
;  279	
;  280	    #if ( portCRITICAL_NESTING_IN_TCB == 1 )
;  281	        UBaseType_t uxCriticalNesting; /*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
;  282	    #endif
;  283	
;  284	    #if ( configUSE_TRACE_FACILITY == 1 )
;  285	        UBaseType_t uxTCBNumber;  /*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
;  286	        UBaseType_t uxTaskNumber; /*< Stores a number specifically for use by third party trace code. */
;  287	    #endif
;  288	
;  289	    #if ( configUSE_MUTEXES == 1 )
;  290	        UBaseType_t uxBasePriority; /*< The priority last assigned to the task - used by the priority inheritance mechanism. */
;  291	        UBaseType_t uxMutexesHeld;
;  292	    #endif
;  293	
;  294	    #if ( configUSE_APPLICATION_TASK_TAG == 1 )
;  295	        TaskHookFunction_t pxTaskTag;
;  296	    #endif
;  297	
;  298	    #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
;  299	        void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
;  300	    #endif
;  301	
;  302	    #if ( configGENERATE_RUN_TIME_STATS == 1 )
;  303	        configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /*< Stores the amount of time the task has spent in the Running state. */
;  304	    #endif
;  305	
;  306	    #if ( ( configUSE_NEWLIB_REENTRANT == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 ) )
;  307	        configTLS_BLOCK_TYPE xTLSBlock; /*< Memory block used as Thread Local Storage (TLS) Block for the task. */
;  308	    #endif
;  309	
;  310	    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
;  311	        volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
;  312	        volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
;  313	    #endif
;  314	
;  315	    /* See the comments in FreeRTOS.h with the definition of
;  316	     * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
;  317	    #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
;  318	        uint8_t ucStaticallyAllocated;                     /*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
;  319	    #endif
;  320	
;  321	    #if ( INCLUDE_xTaskAbortDelay == 1 )
;  322	        uint8_t ucDelayAborted;
;  323	    #endif
;  324	
;  325	    #if ( configUSE_POSIX_ERRNO == 1 )
;  326	        int iTaskErrno;
;  327	    #endif
;  328	} tskTCB;
.BEGREC "tskTaskControlBlock",69
.DEFINE "pxTopOfStack"
.VALUE 0
.CLASS 8
.TYPE 46
.ENDEF
.DEFINE "xStateListItem"
.VALUE 3
.CLASS 8
.TAG "xLIST_ITEM"
.TYPE 8
.ENDEF
.DEFINE "xEventListItem"
.VALUE 19
.CLASS 8
.TAG "xLIST_ITEM"
.TYPE 8
.ENDEF
.DEFINE "uxPriority"
.VALUE 35
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "pxStack"
.VALUE 38
.CLASS 8
.TYPE 46
.ENDEF
.DEFINE "pcTaskName"
.VALUE 41
.CLASS 8
.DIM 16
.TYPE 98
.ENDEF
.DEFINE "uxBasePriority"
.VALUE 57
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "uxMutexesHeld"
.VALUE 60
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "ulNotifiedValue"
.VALUE 63
.CLASS 8
.DIM 1
.TYPE 111
.ENDEF
.DEFINE "ucNotifyState"
.VALUE 67
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.DEFINE "ucDelayAborted"
.VALUE 68
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "tskTaskControlBlock"
	SEGMENT DATA
_pxCurrentTCB:
	DW24	0
.DEFINE "pxCurrentTCB"
.ALIAS "_pxCurrentTCB"
.CLASS 69
.VALUE _pxCurrentTCB
.TAG "tskTaskControlBlock"
.TYPE 40
.ENDEF
	SEGMENT BSS
_pxReadyTasksLists:
	DS	80
.DEFINE "pxReadyTasksLists"
.ALIAS "_pxReadyTasksLists"
.CLASS 83
.VALUE _pxReadyTasksLists
.DIM 5
.TAG "xLIST"
.TYPE 104
.ENDEF
_xDelayedTaskList1:
	DS	16
.DEFINE "xDelayedTaskList1"
.ALIAS "_xDelayedTaskList1"
.CLASS 83
.VALUE _xDelayedTaskList1
.TAG "xLIST"
.TYPE 8
.ENDEF
_xDelayedTaskList2:
	DS	16
.DEFINE "xDelayedTaskList2"
.ALIAS "_xDelayedTaskList2"
.CLASS 83
.VALUE _xDelayedTaskList2
.TAG "xLIST"
.TYPE 8
.ENDEF
_pxDelayedTaskList:
	DS	3
.DEFINE "pxDelayedTaskList"
.ALIAS "_pxDelayedTaskList"
.CLASS 83
.VALUE _pxDelayedTaskList
.TAG "xLIST"
.TYPE 40
.ENDEF
_pxOverflowDelayedTaskList:
	DS	3
.DEFINE "pxOverflowDelayedTaskList"
.ALIAS "_pxOverflowDelayedTaskList"
.CLASS 83
.VALUE _pxOverflowDelayedTaskList
.TAG "xLIST"
.TYPE 40
.ENDEF
_xPendingReadyList:
	DS	16
.DEFINE "xPendingReadyList"
.ALIAS "_xPendingReadyList"
.CLASS 83
.VALUE _xPendingReadyList
.TAG "xLIST"
.TYPE 8
.ENDEF
_xTasksWaitingTermination:
	DS	16
.DEFINE "xTasksWaitingTermination"
.ALIAS "_xTasksWaitingTermination"
.CLASS 83
.VALUE _xTasksWaitingTermination
.TAG "xLIST"
.TYPE 8
.ENDEF
	SEGMENT DATA
_uxDeletedTasksWaitingCleanUp:
	DW	0
	DB	0
.DEFINE "uxDeletedTasksWaitingCleanUp"
.ALIAS "_uxDeletedTasksWaitingCleanUp"
.CLASS 69
.VALUE _uxDeletedTasksWaitingCleanUp
.TYPE 14
.ENDEF
	SEGMENT BSS
_xSuspendedTaskList:
	DS	16
.DEFINE "xSuspendedTaskList"
.ALIAS "_xSuspendedTaskList"
.CLASS 83
.VALUE _xSuspendedTaskList
.TAG "xLIST"
.TYPE 8
.ENDEF
	SEGMENT DATA
_uxCurrentNumberOfTasks:
	DW	0
	DB	0
.DEFINE "uxCurrentNumberOfTasks"
.ALIAS "_uxCurrentNumberOfTasks"
.CLASS 69
.VALUE _uxCurrentNumberOfTasks
.TYPE 14
.ENDEF
_xTickCount:
	DL	0
.DEFINE "xTickCount"
.ALIAS "_xTickCount"
.CLASS 69
.VALUE _xTickCount
.TYPE 15
.ENDEF
_uxTopReadyPriority:
	DW	0
	DB	0
.DEFINE "uxTopReadyPriority"
.ALIAS "_uxTopReadyPriority"
.CLASS 69
.VALUE _uxTopReadyPriority
.TYPE 14
.ENDEF
_xSchedulerRunning:
	DW	0
	DB	0
.DEFINE "xSchedulerRunning"
.ALIAS "_xSchedulerRunning"
.CLASS 69
.VALUE _xSchedulerRunning
.TYPE 4
.ENDEF
_xPendedTicks:
	DL	0
.DEFINE "xPendedTicks"
.ALIAS "_xPendedTicks"
.CLASS 69
.VALUE _xPendedTicks
.TYPE 15
.ENDEF
_xYieldPending:
	DW	0
	DB	0
.DEFINE "xYieldPending"
.ALIAS "_xYieldPending"
.CLASS 69
.VALUE _xYieldPending
.TYPE 4
.ENDEF
_xNumOfOverflows:
	DW	0
	DB	0
.DEFINE "xNumOfOverflows"
.ALIAS "_xNumOfOverflows"
.CLASS 69
.VALUE _xNumOfOverflows
.TYPE 4
.ENDEF
_uxTaskNumber:
	DW	0
	DB	0
.DEFINE "uxTaskNumber"
.ALIAS "_uxTaskNumber"
.CLASS 69
.VALUE _uxTaskNumber
.TYPE 14
.ENDEF
_xNextTaskUnblockTime:
	DL	0
.DEFINE "xNextTaskUnblockTime"
.ALIAS "_xNextTaskUnblockTime"
.CLASS 69
.VALUE _xNextTaskUnblockTime
.TYPE 15
.ENDEF
_xIdleTaskHandle:
	DW24	0
.DEFINE "xIdleTaskHandle"
.ALIAS "_xIdleTaskHandle"
.CLASS 69
.VALUE _xIdleTaskHandle
.TAG "tskTaskControlBlock"
.TYPE 40
.ENDEF
	SEGMENT TEXT
_uxTopUsedPriority:
	DW	4
	DB	0
.DEFINE "uxTopUsedPriority"
.ALIAS "_uxTopUsedPriority"
.CLASS 69
.VALUE _uxTopUsedPriority
.TYPE 14
.ENDEF
	SEGMENT DATA
_uxSchedulerSuspended:
	DW	0
	DB	0
.DEFINE "uxSchedulerSuspended"
.ALIAS "_uxSchedulerSuspended"
.CLASS 69
.VALUE _uxSchedulerSuspended
.TYPE 14
.ENDEF
;  329	
;  330	/* The old tskTCB name is maintained above then typedefed to the new TCB_t name
;  331	 * below to enable the use of older kernel aware debuggers. */
;  332	typedef tskTCB TCB_t;
;  333	
;  334	/*lint -save -e956 A manual analysis and inspection has been used to determine
;  335	 * which static variables must be declared volatile. */
;  336	portDONT_DISCARD PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
;  337	
;  338	/* Lists for ready and blocked tasks. --------------------
;  339	 * xDelayedTaskList1 and xDelayedTaskList2 could be moved to function scope but
;  340	 * doing so breaks some kernel aware debuggers and debuggers that rely on removing
;  341	 * the static qualifier. */
;  342	PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ]; /*< Prioritised ready tasks. */
;  343	PRIVILEGED_DATA static List_t xDelayedTaskList1;                         /*< Delayed tasks. */
;  344	PRIVILEGED_DATA static List_t xDelayedTaskList2;                         /*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
;  345	PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;              /*< Points to the delayed task list currently being used. */
;  346	PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;      /*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
;  347	PRIVILEGED_DATA static List_t xPendingReadyList;                         /*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
;  348	
;  349	#if ( INCLUDE_vTaskDelete == 1 )
;  350	
;  351	    PRIVILEGED_DATA static List_t xTasksWaitingTermination; /*< Tasks that have been deleted - but their memory not yet freed. */
;  352	    PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
;  353	
;  354	#endif
;  355	
;  356	#if ( INCLUDE_vTaskSuspend == 1 )
;  357	
;  358	    PRIVILEGED_DATA static List_t xSuspendedTaskList; /*< Tasks that are currently suspended. */
;  359	
;  360	#endif
;  361	
;  362	/* Global POSIX errno. Its value is changed upon context switching to match
;  363	 * the errno of the currently running task. */
;  364	#if ( configUSE_POSIX_ERRNO == 1 )
;  365	    int FreeRTOS_errno = 0;
;  366	#endif
;  367	
;  368	/* Other file private variables. --------------------------------*/
;  369	PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
;  370	PRIVILEGED_DATA static volatile TickType_t xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
;  371	PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority = tskIDLE_PRIORITY;
;  372	PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning = pdFALSE;
;  373	PRIVILEGED_DATA static volatile TickType_t xPendedTicks = ( TickType_t ) 0U;
;  374	PRIVILEGED_DATA static volatile BaseType_t xYieldPending = pdFALSE;
;  375	PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows = ( BaseType_t ) 0;
;  376	PRIVILEGED_DATA static UBaseType_t uxTaskNumber = ( UBaseType_t ) 0U;
;  377	PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime = ( TickType_t ) 0U; /* Initialised to portMAX_DELAY before the scheduler starts. */
;  378	PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;                          /*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
;  379	
;  380	/* Improve support for OpenOCD. The kernel tracks Ready tasks via priority lists.
;  381	 * For tracking the state of remote threads, OpenOCD uses uxTopUsedPriority
;  382	 * to determine the number of priority lists to read back from the remote target. */
;  383	const volatile UBaseType_t uxTopUsedPriority = configMAX_PRIORITIES - 1U;
;  384	
;  385	/* Context switches are held pending while the scheduler is suspended.  Also,
;  386	 * interrupts must not manipulate the xStateListItem of a TCB, or any of the
;  387	 * lists the xStateListItem can be referenced from, if the scheduler is suspended.
;  388	 * If an interrupt needs to unblock a task while the scheduler is suspended then it
;  389	 * moves the task's event list item into the xPendingReadyList, ready for the
;  390	 * kernel to move the task from the pending ready list into the real ready list
;  391	 * when the scheduler is unsuspended.  The pending ready list itself can only be
;  392	 * accessed from a critical section. */
;  393	PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended = ( UBaseType_t ) pdFALSE;
	SEGMENT CODE
;  394	
;  395	#if ( configGENERATE_RUN_TIME_STATS == 1 )
;  396	
;  397	/* Do not move these variables to function scope as doing so prevents the
;  398	 * code working with debuggers that need to remove the static qualifier. */
;  399	    PRIVILEGED_DATA static configRUN_TIME_COUNTER_TYPE ulTaskSwitchedInTime = 0UL;    /*< Holds the value of a timer/counter the last time a task was switched in. */
;  400	    PRIVILEGED_DATA static volatile configRUN_TIME_COUNTER_TYPE ulTotalRunTime = 0UL; /*< Holds the total amount of execution time as defined by the run time counter clock. */
;  401	
;  402	#endif
;  403	
;  404	/*lint -restore */
;  405	
;  406	/*-----------------------------------------------------------*/
;  407	
;  408	/* File private functions. --------------------------------*/
;  409	
;  410	/**
;  411	 * Utility task that simply returns pdTRUE if the task referenced by xTask is
;  412	 * currently in the Suspended state, or pdFALSE if the task referenced by xTask
;  413	 * is in any other state.
;  414	 */
;  415	#if ( INCLUDE_vTaskSuspend == 1 )
;  416	
;  417	    static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
;  418	
;  419	#endif /* INCLUDE_vTaskSuspend */
;  420	
;  421	/*
;  422	 * Utility to ready all the lists used by the scheduler.  This is called
;  423	 * automatically upon the creation of the first task.
;  424	 */
;  425	static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
;  426	
;  427	/*
;  428	 * The idle task, which as all tasks is implemented as a never ending loop.
;  429	 * The idle task is automatically created and added to the ready lists upon
;  430	 * creation of the first user task.
;  431	 *
;  432	 * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
;  433	 * language extensions.  The equivalent prototype for this function is:
;  434	 *
;  435	 * void prvIdleTask( void *pvParameters );
;  436	 *
;  437	 */
;  438	static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters ) PRIVILEGED_FUNCTION;
;  439	
;  440	/*
;  441	 * Utility to free all memory allocated by the scheduler to hold a TCB,
;  442	 * including the stack pointed to by the TCB.
;  443	 *
;  444	 * This does not free memory allocated by the task itself (i.e. memory
;  445	 * allocated by calls to pvPortMalloc from within the tasks application code).
;  446	 */
;  447	#if ( INCLUDE_vTaskDelete == 1 )
;  448	
;  449	    static void prvDeleteTCB( TCB_t * pxTCB ) PRIVILEGED_FUNCTION;
;  450	
;  451	#endif
;  452	
;  453	/*
;  454	 * Used only by the idle task.  This checks to see if anything has been placed
;  455	 * in the list of tasks waiting to be deleted.  If so the task is cleaned up
;  456	 * and its TCB deleted.
;  457	 */
;  458	static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
;  459	
;  460	/*
;  461	 * The currently executing task is entering the Blocked state.  Add the task to
;  462	 * either the current or the overflow delayed task list.
;  463	 */
;  464	static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
;  465	                                            const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;
;  466	
;  467	/*
;  468	 * Fills an TaskStatus_t structure with information on each task that is
;  469	 * referenced from the pxList list (which may be a ready list, a delayed list,
;  470	 * a suspended list, etc.).
;  471	 *
;  472	 * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
;  473	 * NORMAL APPLICATION CODE.
;  474	 */
;  475	#if ( configUSE_TRACE_FACILITY == 1 )
;  476	
;  477	    static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
;  478	                                                     List_t * pxList,
;  479	                                                     eTaskState eState ) PRIVILEGED_FUNCTION;
;  480	
;  481	#endif
;  482	
;  483	/*
;  484	 * Searches pxList for a task with name pcNameToQuery - returning a handle to
;  485	 * the task if it is found, or NULL if the task is not found.
;  486	 */
;  487	#if ( INCLUDE_xTaskGetHandle == 1 )
;  488	
;  489	    static TCB_t * prvSearchForNameWithinSingleList( List_t * pxList,
;  490	                                                     const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;
;  491	
;  492	#endif
;  493	
;  494	/*
;  495	 * When a task is created, the stack of the task is filled with a known value.
;  496	 * This function determines the 'high water mark' of the task stack by
;  497	 * determining how much of the stack remains at the original preset value.
;  498	 */
;  499	#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )
;  500	
;  501	    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
;  502	
;  503	#endif
;  504	
;  505	/*
;  506	 * Return the amount of time, in ticks, that will pass before the kernel will
;  507	 * next move a task from the Blocked state to the Running state.
;  508	 *
;  509	 * This conditional compilation should use inequality to 0, not equality to 1.
;  510	 * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
;  511	 * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
;  512	 * set to a value other than 1.
;  513	 */
;  514	#if ( configUSE_TICKLESS_IDLE != 0 )
;  515	
;  516	    static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
;  517	
;  518	#endif
;  519	
;  520	/*
;  521	 * Set xNextTaskUnblockTime to the time at which the next Blocked state task
;  522	 * will exit the Blocked state.
;  523	 */
;  524	static void prvResetNextTaskUnblockTime( void ) PRIVILEGED_FUNCTION;
;  525	
;  526	#if ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 )
;  527	
;  528	/*
;  529	 * Helper function used to pad task names with spaces when printing out
;  530	 * human readable tables of task information.
;  531	 */
;  532	    static char * prvWriteNameToBuffer( char * pcBuffer,
;  533	                                        const char * pcTaskName ) PRIVILEGED_FUNCTION;
;  534	
;  535	#endif
;  536	
;  537	/*
;  538	 * Called after a Task_t structure has been allocated either statically or
;  539	 * dynamically to fill in the structure's members.
;  540	 */
;  541	static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
;  542	                                  const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;  543	                                  const uint32_t ulStackDepth,
;  544	                                  void * const pvParameters,
;  545	                                  UBaseType_t uxPriority,
;  546	                                  TaskHandle_t * const pxCreatedTask,
;  547	                                  TCB_t * pxNewTCB,
;  548	                                  const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
;  549	
;  550	/*
;  551	 * Called after a new task has been created and initialised to place the task
;  552	 * under the control of the scheduler.
;  553	 */
;  554	static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB ) PRIVILEGED_FUNCTION;
;  555	
;  556	/*
;  557	 * freertos_tasks_c_additions_init() should only be called if the user definable
;  558	 * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
;  559	 * called by the function.
;  560	 */
;  561	#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
;  562	
;  563	    static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
;  564	
;  565	#endif
;  566	
;  567	/*-----------------------------------------------------------*/
;  568	
;  569	#if ( configSUPPORT_STATIC_ALLOCATION == 1 )
;  570	
;  571	    TaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode,
;  572	                                    const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;  573	                                    const uint32_t ulStackDepth,
;  574	                                    void * const pvParameters,
;  575	                                    UBaseType_t uxPriority,
;  576	                                    StackType_t * const puxStackBuffer,
;  577	                                    StaticTask_t * const pxTaskBuffer )
;  578	    {
;  579	        TCB_t * pxNewTCB;
;  580	        TaskHandle_t xReturn;
;  581	
;  582	        configASSERT( puxStackBuffer != NULL );
;  583	        configASSERT( pxTaskBuffer != NULL );
;  584	
;  585	        #if ( configASSERT_DEFINED == 1 )
;  586	        {
;  587	            /* Sanity check that the size of the structure used to declare a
;  588	             * variable of type StaticTask_t equals the size of the real task
;  589	             * structure. */
;  590	            volatile size_t xSize = sizeof( StaticTask_t );
;  591	            configASSERT( xSize == sizeof( TCB_t ) );
;  592	            ( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
;  593	        }
;  594	        #endif /* configASSERT_DEFINED */
;  595	
;  596	        if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
;  597	        {
;  598	            /* The memory used for the task's TCB and stack are passed into this
;  599	             * function - use them. */
;  600	            pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
;  601	            memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
;  602	            pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
;  603	
;  604	            #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
;  605	            {
;  606	                /* Tasks can be created statically or dynamically, so note this
;  607	                 * task was created statically in case the task is later deleted. */
;  608	                pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
;  609	            }
;  610	            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
;  611	
;  612	            prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
;  613	            prvAddNewTaskToReadyList( pxNewTCB );
;  614	        }
;  615	        else
;  616	        {
;  617	            xReturn = NULL;
;  618	        }
;  619	
;  620	        return xReturn;
;  621	    }
;  622	
;  623	#endif /* SUPPORT_STATIC_ALLOCATION */
;  624	/*-----------------------------------------------------------*/
;  625	
;  626	#if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;  627	
;  628	    BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition,
;  629	                                            TaskHandle_t * pxCreatedTask )
;  630	    {
;  631	        TCB_t * pxNewTCB;
;  632	        BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
;  633	
;  634	        configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
;  635	        configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
;  636	
;  637	        if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
;  638	        {
;  639	            /* Allocate space for the TCB.  Where the memory comes from depends
;  640	             * on the implementation of the port malloc function and whether or
;  641	             * not static allocation is being used. */
;  642	            pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
;  643	            memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
;  644	
;  645	            /* Store the stack location in the TCB. */
;  646	            pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
;  647	
;  648	            #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
;  649	            {
;  650	                /* Tasks can be created statically or dynamically, so note this
;  651	                 * task was created statically in case the task is later deleted. */
;  652	                pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
;  653	            }
;  654	            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
;  655	
;  656	            prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
;  657	                                  pxTaskDefinition->pcName,
;  658	                                  ( uint32_t ) pxTaskDefinition->usStackDepth,
;  659	                                  pxTaskDefinition->pvParameters,
;  660	                                  pxTaskDefinition->uxPriority,
;  661	                                  pxCreatedTask, pxNewTCB,
;  662	                                  pxTaskDefinition->xRegions );
;  663	
;  664	            prvAddNewTaskToReadyList( pxNewTCB );
;  665	            xReturn = pdPASS;
;  666	        }
;  667	
;  668	        return xReturn;
;  669	    }
;  670	
;  671	#endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
;  672	/*-----------------------------------------------------------*/
;  673	
;  674	#if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
;  675	
;  676	    BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition,
;  677	                                      TaskHandle_t * pxCreatedTask )
;  678	    {
;  679	        TCB_t * pxNewTCB;
;  680	        BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
;  681	
;  682	        configASSERT( pxTaskDefinition->puxStackBuffer );
;  683	
;  684	        if( pxTaskDefinition->puxStackBuffer != NULL )
;  685	        {
;  686	            /* Allocate space for the TCB.  Where the memory comes from depends
;  687	             * on the implementation of the port malloc function and whether or
;  688	             * not static allocation is being used. */
;  689	            pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
;  690	
;  691	            if( pxNewTCB != NULL )
;  692	            {
;  693	                memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
;  694	
;  695	                /* Store the stack location in the TCB. */
;  696	                pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
;  697	
;  698	                #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
;  699	                {
;  700	                    /* Tasks can be created statically or dynamically, so note
;  701	                     * this task had a statically allocated stack in case it is
;  702	                     * later deleted.  The TCB was allocated dynamically. */
;  703	                    pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
;  704	                }
;  705	                #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
;  706	
;  707	                prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
;  708	                                      pxTaskDefinition->pcName,
;  709	                                      ( uint32_t ) pxTaskDefinition->usStackDepth,
;  710	                                      pxTaskDefinition->pvParameters,
;  711	                                      pxTaskDefinition->uxPriority,
;  712	                                      pxCreatedTask, pxNewTCB,
;  713	                                      pxTaskDefinition->xRegions );
;  714	
;  715	                prvAddNewTaskToReadyList( pxNewTCB );
;  716	                xReturn = pdPASS;
;  717	            }
;  718	        }
;  719	
;  720	        return xReturn;
;  721	    }
;  722	
;  723	#endif /* portUSING_MPU_WRAPPERS */
;  724	/*-----------------------------------------------------------*/
;  725	
;  726	#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
;  727	
;  728	    BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,
;  729	                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;  730	                            const configSTACK_DEPTH_TYPE usStackDepth,
;  731	                            void * const pvParameters,
;  732	                            UBaseType_t uxPriority,
;  733	                            TaskHandle_t * const pxCreatedTask )
;  734	    {
_xTaskCreate:
.DEFINE "_xTaskCreate"

.VALUE _xTaskCreate

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xTaskCreate",734,"_xTaskCreate"

.LINE 734

.DEFINE "pxTaskCode"

.CLASS 65

.VALUE 6

.TYPE 545

.ENDEF

.DEFINE "pcName"

.CLASS 65

.VALUE 9

.TYPE 194

.ENDEF

.DEFINE "usStackDepth"

.CLASS 65

.VALUE 12

.TYPE 4

.ENDEF

.DEFINE "pvParameters"

.CLASS 65

.VALUE 15

.TYPE 33

.ENDEF

.DEFINE "uxPriority"

.CLASS 65

.VALUE 18

.TYPE 14

.ENDEF

.DEFINE "pxCreatedTask"

.CLASS 65

.VALUE 21

.TAG "tskTaskControlBlock"

.TYPE 296

.ENDEF

.DEFINE "pxNewTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxStack"

.CLASS 65

.VALUE -6

.TYPE 46

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -9

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
;  735	        TCB_t * pxNewTCB;
;  736	        BaseType_t xReturn;
;  737	
;  738	        /* If the stack grows down then allocate the stack then the TCB so the stack
;  739	         * does not grow into the TCB.  Likewise if the stack grows up then allocate
;  740	         * the TCB then the stack. */
;  741	        #if ( portSTACK_GROWTH > 0 )
;  742	        {
;  743	            /* Allocate space for the TCB.  Where the memory comes from depends on
;  744	             * the implementation of the port malloc function and whether or not static
;  745	             * allocation is being used. */
;  746	            pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
;  747	            if( pxNewTCB != NULL )
;  748	            {
;  749	                memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
;  750	
;  751	                /* Allocate space for the stack used by the task being created.
;  752	                 * The base of the stack memory stored in the TCB so the task can
;  753	                 * be deleted later if required. */
;  754	                pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;  755	                if( pxNewTCB->pxStack == NULL )
;  756	                {
;  757	                    /* Could not allocate the stack.  Delete the allocated TCB. */
;  758	                    vPortFree( pxNewTCB );
;  759	                    pxNewTCB = NULL;
;  760	                }
;  761	            }
;  762	        }
;  763	        #else /* portSTACK_GROWTH < 0 */
;  764	        {
;  765	            StackType_t * pxStack;
;  766	
;  767	            /* Allocate space for the stack used by the task being created. */
;  768	            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
.LINE 768

	LD	HL,(IX+%C)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	PUSH	HL
	CALL	_pvPortMalloc
	POP	BC
	LD	(IX+%FFFFFFFA),HL
;  769	            if( pxStack != NULL )
.LINE 769

	LD	HL,(IX+%FFFFFFFA)
	CALL	__icmpzero
	JR	Z,L_3
;  770	            {
;  771	#				if defined( _DEBUG )&&0
;  772					{
;  773						( void )printf( "pxStack Mallocated = 0x%p\r\n", pxStack );
;  774					}
;  775	#				endif
;  776	
;  777						/* Allocate space for the TCB. */
;  778	                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
.LINE 778

	LD	BC,69
	PUSH	BC
	CALL	_pvPortMalloc
	POP	BC
	LD	(IX+%FFFFFFFD),HL
;  779	                if( pxNewTCB != NULL )
.LINE 779

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	Z,L_1
;  780	                {
;  781	#					if defined( _DEBUG )&& 0
;  782						{
;  783							( void )printf( "pxNewTCB Mallocated = 0x%p\r\n", pxNewTCB );
;  784						}
;  785	#					endif
;  786	                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
.LINE 786

	LD	BC,69
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  787	
;  788	                    /* Store the stack location in the TCB. */
;  789	                    pxNewTCB->pxStack = pxStack;
.LINE 789

	LD	BC,(IX+%FFFFFFFA)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%26),BC
;  790	                }
;  791	                else
.LINE 791

	JR	L_6
L_1:
;  792	                {
;  793	                    /* The stack cannot be used as the TCB was not created.  Free
;  794	                     * it again. */
;  795	                    vPortFreeStack( pxStack );
.LINE 795

	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_vPortFree
	POP	BC
;  796	
;  797	#					if defined( _DEBUG )&& 0
;  798						{
;  799							( void )printf( "pxNewTCB malloc null\r\n" );
;  800						}
;  801	#					endif
;  802					}
;  803	            }
;  804	            else
.LINE 804

	JR	L_6
L_3:
;  805	            {
;  806	                pxNewTCB = NULL;
.LINE 806

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
;  807					
;  808	#				if defined( _DEBUG )&& 0
;  809					{
;  810						( void )printf( "pxNewTCB malloc null\r\n" );
;  811					}
;  812	#				endif
;  813	            }
;  814	        }
L_6:
.LINE 814

;  815	        #endif /* portSTACK_GROWTH */
;  816	
;  817	        if( pxNewTCB != NULL )
.LINE 817

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	Z,L_5
;  818	        {
;  819	            #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
;  820	            {
;  821	                /* Tasks can be created statically or dynamically, so note this
;  822	                 * task was created dynamically in case it is later deleted. */
;  823	                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
;  824	            }
;  825	            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
;  826	
;  827	            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
.LINE 827

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	LD	BC,(IX+%15)
	PUSH	BC
	LD	BC,(IX+%12)
	PUSH	BC
	LD	BC,(IX+%F)
	PUSH	BC
	LD	BC,(IX+%C)
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_prvInitialiseNewTask
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
;  828	            prvAddNewTaskToReadyList( pxNewTCB );
.LINE 828

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvAddNewTaskToReadyList
	POP	BC
;  829	            xReturn = pdPASS;
.LINE 829

	LD	BC,1
	LD	(IX+%FFFFFFF7),BC
;  830	        }
;  831	        else
.LINE 831

	JR	L_7
L_5:
;  832	        {
;  833	            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
.LINE 833

	LD	BC,16777215
	LD	(IX+%FFFFFFF7),BC
;  834	        }
L_7:
.LINE 834

;  835	
;  836	        return xReturn;
.LINE 836

	LD	HL,(IX+%FFFFFFF7)
;  837	    }
.LINE 837

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskCreate ***************************
;Name                         Addr/Register   Size   Type
;_prvAddNewTaskToReadyList           IMPORT  -----   function
;_prvInitialiseNewTask               IMPORT  -----   function
;_vPortFree                          IMPORT  -----   function
;_memset                             IMPORT  -----   function
;_pvPortMalloc                       IMPORT  -----   function
;xReturn                               IX-9      3   variable
;pxStack                               IX-6      3   variable
;pxNewTCB                              IX-3      3   variable
;pxCreatedTask                        IX+21      3   parameter
;uxPriority                           IX+18      3   parameter
;pvParameters                         IX+15      3   parameter
;usStackDepth                         IX+12      3   parameter
;pcName                                IX+9      3   parameter
;pxTaskCode                            IX+6      3   parameter


; Stack Frame Size: 33 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskCreate",837,"_xTaskCreate"
;  838	
;  839	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;  840	/*-----------------------------------------------------------*/
;  841	
;  842	static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
;  843	                                  const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;  844	                                  const uint32_t ulStackDepth,
;  845	                                  void * const pvParameters,
;  846	                                  UBaseType_t uxPriority,
;  847	                                  TaskHandle_t * const pxCreatedTask,
;  848	                                  TCB_t * pxNewTCB,
;  849	                                  const MemoryRegion_t * const xRegions )
;  850	{
_prvInitialiseNewTask:
.DEFINE "_prvInitialiseNewTask"

.VALUE _prvInitialiseNewTask

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "prvInitialiseNewTask",850,"_prvInitialiseNewTask"

.LINE 850

.DEFINE "pxTaskCode"

.CLASS 65

.VALUE 6

.TYPE 545

.ENDEF

.DEFINE "pcName"

.CLASS 65

.VALUE 9

.TYPE 194

.ENDEF

.DEFINE "ulStackDepth"

.CLASS 65

.VALUE 12

.TYPE 15

.ENDEF

.DEFINE "pvParameters"

.CLASS 65

.VALUE 18

.TYPE 33

.ENDEF

.DEFINE "uxPriority"

.CLASS 65

.VALUE 21

.TYPE 14

.ENDEF

.DEFINE "pxCreatedTask"

.CLASS 65

.VALUE 24

.TAG "tskTaskControlBlock"

.TYPE 296

.ENDEF

.DEFINE "pxNewTCB"

.CLASS 65

.VALUE 27

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "xRegions"

.CLASS 65

.VALUE 30

.TAG "xMEMORY_REGION"

.TYPE 200

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "pxTopOfStack"

.CLASS 65

.VALUE -6

.TYPE 46

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF4
	LD	SP,HL
;  851	    StackType_t * pxTopOfStack;
;  852	    UBaseType_t x;
;  853	
;  854	#	if defined( _DEBUG )&& 0
;  855		{
;  856			( void )printf( "%s : %d : prvInitialiseNewTask %s : prio %d : tcb %p"
;  857							": stack %p\r\n", 
;  858							"tasks.c", __LINE__, pcName, uxPriority, pxNewTCB,
;  859							pxNewTCB->pxStack );
;  860		}
;  861	#	endif
;  862	
;  863	    #if ( portUSING_MPU_WRAPPERS == 1 )
;  864	        /* Should the task be created in privileged mode? */
;  865	        BaseType_t xRunPrivileged;
;  866	
;  867	        if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;  868	        {
;  869	            xRunPrivileged = pdTRUE;
;  870	        }
;  871	        else
;  872	        {
;  873	            xRunPrivileged = pdFALSE;
;  874	        }
;  875	        uxPriority &= ~portPRIVILEGE_BIT;
;  876	    #endif /* portUSING_MPU_WRAPPERS == 1 */
;  877	
;  878	    /* Avoid dependency on memset() if it is not required. */
;  879	    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
;  880	    {
;  881	#		if defined( _DEBUG )&& 0
;  882			{
;  883				( void )printf( "prvInitialiseNewTask : %d\r\n", __LINE__ );
;  884			}
;  885	#		endif
;  886			
;  887	        /* Fill the stack with a known value to assist debugging. */
;  888	        ( void )memset( pxNewTCB->pxStack, ( int )tskSTACK_FILL_BYTE, ( size_t )( ulStackDepth * sizeof( StackType_t )));
.LINE 888

	LD	HL,(IX+%C)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	PUSH	HL
	LD	BC,165
	PUSH	BC
	LD	IY,(IX+%1B)
	LD	BC,(IY+%26)
	PUSH	BC
	CALL	_memset
	POP	BC
	POP	BC
	POP	BC
;  889	    }
;  890	    #endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
;  891	
;  892	    /* Calculate the top of stack address.  This depends on whether the stack
;  893	     * grows from high memory to low (as per the 80x86) or vice versa.
;  894	     * portSTACK_GROWTH is used to make the result positive or negative as required
;  895	     * by the port. */
;  896	    #if ( portSTACK_GROWTH < 0 )
;  897	    {
;  898	        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
.LINE 898

	LD	HL,(IX+%C)
	LD	E,(IX+%F)
	LD	BC,1
	XOR	A,A
	CALL	__lsub
	LD	BC,3
	XOR	A,A
	CALL	__lmulu
	LD	IY,(IX+%1B)
	LD	BC,(IY+%26)
	ADD	HL,BC
	LD	(IX+%FFFFFFFA),HL
;  899	        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
.LINE 899

	LD	BC,16777213
	LD	HL,(IX+%FFFFFFFA)
	CALL	__iand
	LD	(IX+%FFFFFFFA),HL
;  900	
;  901	#		if defined( _DEBUG )&& 0
;  902			{
;  903				( void )printf( "prvInitialiseNewTask : %d : pxTopOfStack = 0x%p\r\n",
;  904								__LINE__, pxTopOfStack );
;  905			}
;  906	#		endif
;  907	
;  908	        /* Check the alignment of the calculated top of stack is correct. */
;  909	        configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;  910	
;  911	        #if ( configRECORD_STACK_HIGH_ADDRESS == 1 )
;  912	        {
;  913	            /* Also record the stack's high address, which may assist
;  914	             * debugging. */
;  915	            pxNewTCB->pxEndOfStack = pxTopOfStack;
;  916	        }
;  917	        #endif /* configRECORD_STACK_HIGH_ADDRESS */
;  918	    }
;  919	    #else /* portSTACK_GROWTH */
;  920	    {
;  921	        pxTopOfStack = pxNewTCB->pxStack;
;  922	
;  923	        /* Check the alignment of the stack buffer is correct. */
;  924	        configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;  925	
;  926	        /* The other extreme of the stack space is required if stack checking is
;  927	         * performed. */
;  928	        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
;  929	    }
;  930	    #endif /* portSTACK_GROWTH */
;  931	
;  932	    /* Store the task name in the TCB. */
;  933	    if( pcName != NULL )
.LINE 933

	LD	HL,(IX+%9)
	CALL	__icmpzero
	JR	NZ,L_12
	JR	L_18
;  934	    {
;  935	        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
L_13:
.LINE 935

	LD	BC,16
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_15
	JR	L_16
L_12:
	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_13
L_15:
;  936	        {
;  937	            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
.LINE 937

	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%9)
	ADD	HL,BC
	LD	(IX+%FFFFFFF4),HL	; spill
	LD	BC,(IX+%FFFFFFFD)
	LD	IY,(IX+%1B)
	LEA	HL,IY+%29
	ADD	HL,BC
	LD	(IX+%FFFFFFF7),HL	; spill
	LD	HL,(IX+%FFFFFFF4)	; unspill
	LD	A,(HL)
	LD	HL,(IX+%FFFFFFF7)	; unspill
	LD	(HL),A
;  938	
;  939	            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
;  940	             * configMAX_TASK_NAME_LEN characters just in case the memory after the
;  941	             * string is not accessible (extremely unlikely). */
;  942	            if( pcName[ x ] == ( char ) 0x00 )
.LINE 942

	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(IX+%9)
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	Z,L_16
;  943	            {
;  944	                break;
.LINE 944

;  945	            }
;  946	            else
.LINE 946

	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  947	            {
;  948	                mtCOVERAGE_TEST_MARKER();
;  949	            }
;  950	        }
.LINE 950

	JR	L_13
L_16:
;  951	
;  952	        /* Ensure the name string is terminated in the case that the string length
;  953	         * was greater or equal to configMAX_TASK_NAME_LEN. */
;  954	        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
.LINE 954

	LD	IY,(IX+%1B)
	LEA	HL,IY+%38
	LD	(HL),%0
;  955	    }
;  956	    else
L_18:
.LINE 956

;  957	    {
;  958	        mtCOVERAGE_TEST_MARKER();
;  959	    }
;  960	
;  961	    /* This is used as an array index so must ensure it's not too large. */
;  962	    configASSERT( uxPriority < configMAX_PRIORITIES );
;  963	
;  964	    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
.LINE 964

	LD	BC,5
	LD	HL,(IX+%15)
	OR	A,A
	SBC	HL,BC
	JR	C,L_21
;  965	    {
;  966	        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
.LINE 966

	LD	BC,4
	LD	(IX+%15),BC
;  967	    }
;  968	    else
L_21:
.LINE 968

;  969	    {
;  970	        mtCOVERAGE_TEST_MARKER();
;  971	    }
;  972	
;  973	    pxNewTCB->uxPriority = uxPriority;
.LINE 973

	LD	BC,(IX+%15)
	LD	IY,(IX+%1B)
	LD	(IY+%23),BC
;  974	    #if ( configUSE_MUTEXES == 1 )
;  975	    {
;  976	        pxNewTCB->uxBasePriority = uxPriority;
.LINE 976

	LD	BC,(IX+%15)
	LD	IY,(IX+%1B)
	LD	(IY+%39),BC
;  977	    }
;  978	    #endif /* configUSE_MUTEXES */
;  979	
;  980	    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
.LINE 980

	LD	IY,(IX+%1B)
	PEA	IY+%3
	CALL	_vListInitialiseItem
	POP	BC
;  981	    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
.LINE 981

	LD	IY,(IX+%1B)
	PEA	IY+%13
	CALL	_vListInitialiseItem
	POP	BC
;  982	
;  983	    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
;  984	     * back to  the containing TCB from a generic item in a list. */
;  985	    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
.LINE 985

	LD	BC,(IX+%1B)
	LD	IY,(IX+%1B)
	LD	(IY+%D),BC
;  986	
;  987	    /* Event lists are always in priority order. */
;  988	    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
.LINE 988

	LD	BC,(IX+%15)
	XOR	A,A
	LD	HL,5
	LD	E,%0
	CALL	__lsub
	LD	IY,(IX+%1B)
	LD	(IY+%13),HL
	LD	(IY+%16),E
;  989	    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
.LINE 989

	LD	BC,(IX+%1B)
	LD	IY,(IX+%1B)
	LD	(IY+%1D),BC
;  990	
;  991	    #if ( portUSING_MPU_WRAPPERS == 1 )
;  992	    {
;  993	        vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
;  994	    }
;  995	    #else
;  996	    {
;  997	        /* Avoid compiler warning about unreferenced parameter. */
;  998	        ( void ) xRegions;
;  999	    }
; 1000	    #endif
; 1001	
; 1002	    #if ( ( configUSE_NEWLIB_REENTRANT == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 ) )
; 1003	    {
; 1004	        /* Allocate and initialize memory for the task's TLS Block. */
; 1005	        configINIT_TLS_BLOCK( pxNewTCB->xTLSBlock );
; 1006	    }
; 1007	    #endif
; 1008	
; 1009	    /* Initialize the TCB stack to look as if the task was already running,
; 1010	     * but had been interrupted by the scheduler.  The return address is set
; 1011	     * to the start of the task function. Once the stack has been initialised
; 1012	     * the top of stack variable is updated. */
; 1013	    #if ( portUSING_MPU_WRAPPERS == 1 )
; 1014	    {
; 1015	        /* If the port has capability to detect stack overflow,
; 1016	         * pass the stack end address to the stack initialization
; 1017	         * function as well. */
; 1018	        #if ( portHAS_STACK_OVERFLOW_CHECKING == 1 )
; 1019	        {
; 1020	            #if ( portSTACK_GROWTH < 0 )
; 1021	            {
; 1022	                pxNewTCB->pxTopOfStack = 
; 1023						pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pvParameters, xRunPrivileged );
; 1024	            }
; 1025	            #else /* portSTACK_GROWTH */
; 1026	            {
; 1027	                pxNewTCB->pxTopOfStack = 
; 1028						pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCode, pvParameters, xRunPrivileged );
; 1029	            }
; 1030	            #endif /* portSTACK_GROWTH */
; 1031	        }
; 1032	        #else /* portHAS_STACK_OVERFLOW_CHECKING */
; 1033	        {
; 1034	#			if defined( _DEBUG )&& 0
; 1035				{
; 1036					( void )printf( "prvInitialiseNewTask : %d\r\n", __LINE__ );
; 1037				}
; 1038	#			endif
; 1039				
; 1040	            pxNewTCB->pxTopOfStack =
; 1041					pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
; 1042	        }
; 1043	        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
; 1044	    }
; 1045	    #else /* portUSING_MPU_WRAPPERS */
; 1046	    {
; 1047	        /* If the port has capability to detect stack overflow,
; 1048	         * pass the stack end address to the stack initialization
; 1049	         * function as well. */
; 1050	        #if ( portHAS_STACK_OVERFLOW_CHECKING == 1 )
; 1051	        {
; 1052	            #if ( portSTACK_GROWTH < 0 )
; 1053	            {
; 1054	                pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pvParameters );
; 1055	            }
; 1056	            #else /* portSTACK_GROWTH */
; 1057	            {
; 1058	                pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCode, pvParameters );
; 1059	            }
; 1060	            #endif /* portSTACK_GROWTH */
; 1061	        }
; 1062	        #else /* portHAS_STACK_OVERFLOW_CHECKING */
; 1063	        {
; 1064	            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
.LINE 1064

	LD	BC,(IX+%12)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_pxPortInitialiseStack
	POP	BC
	POP	BC
	POP	BC
	LD	IY,(IX+%1B)
	LD	(IY+%0),HL
; 1065	#			if defined( _DEBUG )&& 0
; 1066				{
; 1067					( void )printf( "prvInitialiseNewTask : %d : pxNewTCB->pxTopOfStack = 0x%p\r\n",
; 1068							__LINE__, pxNewTCB->pxTopOfStack );
; 1069				}
; 1070	#			endif
; 1071	        }
; 1072	        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
; 1073	    }
; 1074	    #endif /* portUSING_MPU_WRAPPERS */
; 1075	
; 1076	    if( pxCreatedTask != NULL )
.LINE 1076

	LD	HL,(IX+%18)
	CALL	__icmpzero
	JR	Z,L_24
; 1077	    {
; 1078	        /* Pass the handle out in an anonymous way.  The handle can be used to
; 1079	         * change the created task's priority, delete the created task, etc.*/
; 1080	        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
.LINE 1080

	LD	HL,(IX+%18)
	LD	BC,(IX+%1B)
	LD	(HL),BC
; 1081	    }
; 1082	    else
L_24:
.LINE 1082

; 1083	    {
; 1084	        mtCOVERAGE_TEST_MARKER();
; 1085	    }
; 1086	}
.LINE 1086

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvInitialiseNewTask ***************************
;Name                         Addr/Register   Size   Type
;_pxPortInitialiseStack              IMPORT  -----   function
;_vListInitialiseItem                IMPORT  -----   function
;_memset                             IMPORT  -----   function
;pxTopOfStack                          IX-6      3   variable
;x                                     IX-3      3   variable
;xRegions                             IX+30      3   parameter
;pxNewTCB                             IX+27      3   parameter
;pxCreatedTask                        IX+24      3   parameter
;uxPriority                           IX+21      3   parameter
;pvParameters                         IX+18      3   parameter
;ulStackDepth                         IX+12      4   parameter
;pcName                                IX+9      3   parameter
;pxTaskCode                            IX+6      3   parameter


; Stack Frame Size: 45 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvInitialiseNewTask",1086,"_prvInitialiseNewTask"
; 1087	/*-----------------------------------------------------------*/
; 1088	
; 1089	static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
; 1090	{
_prvAddNewTaskToReadyList:
.DEFINE "_prvAddNewTaskToReadyList"

.VALUE _prvAddNewTaskToReadyList

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "prvAddNewTaskToReadyList",1090,"_prvAddNewTaskToReadyList"

.LINE 1090

.DEFINE "pxNewTCB"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -3

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
; 1091	    /* Ensure interrupts don't access the task lists while the lists are being
; 1092	     * updated. */
; 1093	    taskENTER_CRITICAL();
.LINE 1093

	 di
; 1094	    {
; 1095	        uxCurrentNumberOfTasks++;
.LINE 1095

	LD	BC,(_uxCurrentNumberOfTasks)
	LD	BC,(_uxCurrentNumberOfTasks)
	INC	BC
	LD	(_uxCurrentNumberOfTasks),BC
; 1096	
; 1097	        if( pxCurrentTCB == NULL )
.LINE 1097

	LD	HL,(_pxCurrentTCB)
	CALL	__icmpzero
	JR	NZ,L_34
; 1098	        {
; 1099	            /* There are no other tasks, or all the other tasks are in
; 1100	             * the suspended state - make this the current task. */
; 1101	            pxCurrentTCB = pxNewTCB;
.LINE 1101

	LD	BC,(IX+%6)
	LD	(_pxCurrentTCB),BC
; 1102	
; 1103	#			if defined( _DEBUG )&& 0
; 1104					( void )printf( "%s : %d\r\n", "tasks.c", __LINE__ );
; 1105	#			endif
; 1106	
; 1107	            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
.LINE 1107

	LD	BC,1
	LD	HL,(_uxCurrentNumberOfTasks)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_36
; 1108	            {
; 1109	                /* This is the first task to be created so do the preliminary
; 1110	                 * initialisation required.  We will not recover if this call
; 1111	                 * fails, but we will report the failure. */
; 1112	                prvInitialiseTaskLists();
.LINE 1112

	CALL	_prvInitialiseTaskLists
; 1113	            }
; 1114	            else
.LINE 1114

	JR	L_36
; 1115	            {
; 1116	                mtCOVERAGE_TEST_MARKER();
; 1117	            }
; 1118	        }
; 1119	        else
.LINE 1119

L_34:
; 1120	        {
; 1121	            /* If the scheduler is not already running, make this task the
; 1122	             * current task if it is the highest priority task to be created
; 1123	             * so far. */
; 1124	            if( xSchedulerRunning == pdFALSE )
.LINE 1124

	LD	HL,(_xSchedulerRunning)
	CALL	__icmpzero
	JR	NZ,L_32
; 1125	            {
; 1126	                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
.LINE 1126

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IY+%23)
	LD	IY,(IX+%6)
	LD	HL,(IY+%23)
	OR	A,A
	SBC	HL,BC
	JR	C,L_30
; 1127	                {
; 1128	                    pxCurrentTCB = pxNewTCB;
.LINE 1128

	LD	BC,(IX+%6)
	LD	(_pxCurrentTCB),BC
; 1129	#					if defined( _DEBUG )&& 0
; 1130							( void )printf( "%s : %d\r\n", "tasks.c", __LINE__ );
; 1131	#					endif
; 1132	                }
; 1133	                else
L_30:
.LINE 1133

; 1134	                {
; 1135	                    mtCOVERAGE_TEST_MARKER();
; 1136	                }
; 1137	            }
; 1138	            else
L_32:
.LINE 1138

; 1139	            {
; 1140	                mtCOVERAGE_TEST_MARKER();
; 1141	            }
; 1142	        }
L_36:
.LINE 1142

; 1143	
; 1144	        uxTaskNumber++;
.LINE 1144

	LD	BC,(_uxTaskNumber)
	INC	BC
	LD	(_uxTaskNumber),BC
; 1145	
; 1146	        #if ( configUSE_TRACE_FACILITY == 1 )
; 1147	        {
; 1148	            /* Add a counter into the TCB for tracing only. */
; 1149	            pxNewTCB->uxTCBNumber = uxTaskNumber;
; 1150	        }
; 1151	        #endif /* configUSE_TRACE_FACILITY */
; 1152	        traceTASK_CREATE( pxNewTCB );
; 1153	
; 1154	        prvAddTaskToReadyList( pxNewTCB );
.LINE 1154

	LD	IY,(IX+%6)
	LD	BC,(IY+%23)
	LD	HL,(_uxTopReadyPriority)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_38
	LD	IY,(IX+%6)
	LD	BC,(IY+%23)
	LD	(_uxTopReadyPriority),BC
L_38:
	LD	IY,(IX+%6)
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFFD),BC
	LD	IY,(IX+%6)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%7)
	LD	IY,(IX+%6)
	LD	(IY+%A),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	DE,(IY+%7)
	LD	IY,(IX+%6)
	LEA	BC,IY+%3
	LD	IY,DE
	LD	(IY+%4),BC
	LD	IY,(IX+%6)
	LEA	BC,IY+%3
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	IY,(IX+%6)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	(IY+%10),HL
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	LD	IY,(IX+%6)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,_pxReadyTasksLists
	ADD	HL,DE
	LD	IY,BC
	LD	BC,(IY+%0)
	INC	BC
	LD	IY,HL
	LD	(IY+%0),BC
; 1155	
; 1156	        portSETUP_TCB( pxNewTCB );
; 1157	    }
; 1158	    taskEXIT_CRITICAL();
.LINE 1158

	 ei
; 1159	
; 1160	    if( xSchedulerRunning != pdFALSE )
.LINE 1160

	LD	HL,(_xSchedulerRunning)
	CALL	__icmpzero
	JR	Z,L_43
; 1161	    {
; 1162	        /* If the created task is of a higher priority than the current task
; 1163	         * then it should run now. */
; 1164	        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
.LINE 1164

	LD	DE,(_pxCurrentTCB)
	LD	IY,(IX+%6)
	LD	BC,(IY+%23)
	LD	IY,DE
	LD	HL,(IY+%23)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_41
; 1165	        {
; 1166	            taskYIELD_IF_USING_PREEMPTION();
.LINE 1166

	CALL	_vPortYield
; 1167	        }
; 1168	        else
L_41:
.LINE 1168

; 1169	        {
; 1170	            mtCOVERAGE_TEST_MARKER();
; 1171	        }
; 1172	    }
; 1173	    else
L_43:
.LINE 1173

; 1174	    {
; 1175	        mtCOVERAGE_TEST_MARKER();
; 1176	    }
; 1177	}
.LINE 1177

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvAddNewTaskToReadyList ***************************
;Name                         Addr/Register   Size   Type
;_vPortYield                         IMPORT  -----   function
;_pxReadyTasksLists                  STATIC     80   variable
;_uxTopReadyPriority                 STATIC      3   variable
;_uxTaskNumber                       STATIC      3   variable
;_xSchedulerRunning                  STATIC      3   variable
;_prvInitialiseTaskLists             IMPORT  -----   function
;_pxCurrentTCB                       STATIC      3   variable
;_uxCurrentNumberOfTasks             STATIC      3   variable
;pxIndex                               IX-3      3   variable
;pxNewTCB                              IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvAddNewTaskToReadyList",1177,"_prvAddNewTaskToReadyList"
; 1178	/*-----------------------------------------------------------*/
; 1179	
; 1180	#if ( INCLUDE_vTaskDelete == 1 )
; 1181	
; 1182	    void vTaskDelete( TaskHandle_t xTaskToDelete )
; 1183	    {
_vTaskDelete:
.DEFINE "_vTaskDelete"

.VALUE _vTaskDelete

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vTaskDelete",1183,"_vTaskDelete"

.LINE 1183

.DEFINE "xTaskToDelete"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
; 1184	        TCB_t * pxTCB;
; 1185	
; 1186	        taskENTER_CRITICAL();
.LINE 1186

	 di
; 1187	        {
; 1188	            /* If null is passed in here then it is the calling task that is
; 1189	             * being deleted. */
; 1190	            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
.LINE 1190

	LD	HL,(IX+%6)
	CALL	__icmpzero
	JR	NZ,L_47
	LD	BC,(_pxCurrentTCB)
	LD	(IX+%FFFFFFFA),BC
	JR	L_48
L_47:
	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFA),BC
L_48:
	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFFD),BC
; 1191	
; 1192	            /* Remove task from the ready/delayed list. */
; 1193	            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
.LINE 1193

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%3
	CALL	_uxListRemove
	POP	BC
	CALL	__icmpzero
; 1194	            {
; 1195	                taskRESET_READY_PRIORITY( pxTCB->uxPriority );
; 1196	            }
; 1197	            else
.LINE 1197

; 1198	            {
; 1199	                mtCOVERAGE_TEST_MARKER();
; 1200	            }
; 1201	
; 1202	            /* Is the task waiting on an event also? */
; 1203	            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
.LINE 1203

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%20)
	CALL	__icmpzero
	JR	Z,L_52
; 1204	            {
; 1205	                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
.LINE 1205

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%13
	CALL	_uxListRemove
	POP	BC
; 1206	            }
; 1207	            else
L_52:
.LINE 1207

; 1208	            {
; 1209	                mtCOVERAGE_TEST_MARKER();
; 1210	            }
; 1211	
; 1212	            /* Increment the uxTaskNumber also so kernel aware debuggers can
; 1213	             * detect that the task lists need re-generating.  This is done before
; 1214	             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
; 1215	             * not return. */
; 1216	            uxTaskNumber++;
.LINE 1216

	LD	BC,(_uxTaskNumber)
	INC	BC
	LD	(_uxTaskNumber),BC
; 1217	
; 1218	            if( pxTCB == pxCurrentTCB )
.LINE 1218

	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(_pxCurrentTCB)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_57
; 1219	            {
; 1220	                /* A task is deleting itself.  This cannot complete within the
; 1221	                 * task itself, as a context switch to another task is required.
; 1222	                 * Place the task in the termination list.  The idle task will
; 1223	                 * check the termination list and free up any memory allocated by
; 1224	                 * the scheduler for the TCB and stack of the deleted task. */
; 1225	                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
.LINE 1225

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%3
	LD	BC,_xTasksWaitingTermination
	PUSH	BC
	CALL	_vListInsertEnd
	POP	BC
	POP	BC
; 1226	
; 1227	                /* Increment the ucTasksDeleted variable so the idle task knows
; 1228	                 * there is a task that has been deleted and that it should therefore
; 1229	                 * check the xTasksWaitingTermination list. */
; 1230	                ++uxDeletedTasksWaitingCleanUp;
.LINE 1230

	LD	BC,(_uxDeletedTasksWaitingCleanUp)
	INC	BC
	LD	(_uxDeletedTasksWaitingCleanUp),BC
; 1231	
; 1232	                /* Call the delete hook before portPRE_TASK_DELETE_HOOK() as
; 1233	                 * portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */
; 1234	                traceTASK_DELETE( pxTCB );
; 1235	
; 1236	                /* The pre-delete hook is primarily for the Windows simulator,
; 1237	                 * in which Windows specific clean up operations are performed,
; 1238	                 * after which it is not possible to yield away from this task -
; 1239	                 * hence xYieldPending is used to latch that a context switch is
; 1240	                 * required. */
; 1241	                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
; 1242	            }
; 1243	            else
.LINE 1243

	JR	L_58
L_57:
; 1244	            {
; 1245	                --uxCurrentNumberOfTasks;
.LINE 1245

	LD	IY,(_uxCurrentNumberOfTasks)
	LEA	BC,IY+%FFFFFFFF
	LD	(_uxCurrentNumberOfTasks),BC
; 1246	                traceTASK_DELETE( pxTCB );
; 1247	
; 1248	                /* Reset the next expected unblock time in case it referred to
; 1249	                 * the task that has just been deleted. */
; 1250	                prvResetNextTaskUnblockTime();
.LINE 1250

	CALL	_prvResetNextTaskUnblockTime
; 1251	            }
; 1252	        }
L_58:
.LINE 1252

; 1253	        taskEXIT_CRITICAL();
.LINE 1253

	 ei
; 1254	
; 1255	        /* If the task is not deleting itself, call prvDeleteTCB from outside of
; 1256	         * critical section. If a task deletes itself, prvDeleteTCB is called
; 1257	         * from prvCheckTasksWaitingTermination which is called from Idle task. */
; 1258	        if( pxTCB != pxCurrentTCB )
.LINE 1258

	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(_pxCurrentTCB)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_63
; 1259	        {
; 1260	            prvDeleteTCB( pxTCB );
.LINE 1260

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvDeleteTCB
	POP	BC
; 1261	        }
L_63:
.LINE 1261

; 1262	
; 1263	        /* Force a reschedule if it is the currently running task that has just
; 1264	         * been deleted. */
; 1265	        if( xSchedulerRunning != pdFALSE )
.LINE 1265

	LD	HL,(_xSchedulerRunning)
	CALL	__icmpzero
	JR	Z,L_64
; 1266	        {
; 1267	            if( pxTCB == pxCurrentTCB )
.LINE 1267

	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(_pxCurrentTCB)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_61
; 1268	            {
; 1269	                configASSERT( uxSchedulerSuspended == 0 );
; 1270	                portYIELD_WITHIN_API();
.LINE 1270

	CALL	_vPortYield
; 1271	            }
; 1272	            else
L_61:
.LINE 1272

; 1273	            {
; 1274	                mtCOVERAGE_TEST_MARKER();
; 1275	            }
; 1276	        }
; 1277	    }
L_64:
.LINE 1277

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vTaskDelete ***************************
;Name                         Addr/Register   Size   Type
;_vPortYield                         IMPORT  -----   function
;_xSchedulerRunning                  STATIC      3   variable
;_prvDeleteTCB                       IMPORT  -----   function
;_prvResetNextTaskUnblockTime        IMPORT  -----   function
;_uxCurrentNumberOfTasks             STATIC      3   variable
;_uxDeletedTasksWaitingCleanUp       STATIC      3   variable
;_xTasksWaitingTermination           STATIC     16   variable
;_vListInsertEnd                     IMPORT  -----   function
;_uxTaskNumber                       STATIC      3   variable
;_uxListRemove                       IMPORT  -----   function
;_pxCurrentTCB                       STATIC      3   variable
;temp45                                IX-6      3   variable
;pxTCB                                 IX-3      3   variable
;xTaskToDelete                         IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vTaskDelete",1277,"_vTaskDelete"
; 1278	
; 1279	#endif /* INCLUDE_vTaskDelete */
; 1280	/*-----------------------------------------------------------*/
; 1281	
; 1282	#if ( INCLUDE_xTaskDelayUntil == 1 )
; 1283	
; 1284	    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
; 1285	                                const TickType_t xTimeIncrement )
; 1286	    {
_xTaskDelayUntil:
.DEFINE "_xTaskDelayUntil"

.VALUE _xTaskDelayUntil

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xTaskDelayUntil",1286,"_xTaskDelayUntil"

.LINE 1286

.DEFINE "pxPreviousWakeTime"

.CLASS 65

.VALUE 6

.TYPE 47

.ENDEF

.DEFINE "xTimeIncrement"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "xTimeToWake"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

.DEFINE "xShouldDelay"

.CLASS 65

.VALUE -7

.TYPE 4

.ENDEF

.DEFINE "xConstTickCount"

.CLASS 65

.VALUE -11

.TYPE 15

.ENDEF

.DEFINE "xAlreadyYielded"

.CLASS 65

.VALUE -14

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF2
	LD	SP,HL
; 1287	        TickType_t xTimeToWake;
; 1288	        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
.LINE 1288

	LD	BC,0
	LD	(IX+%FFFFFFF9),BC
; 1289	
; 1290	        configASSERT( pxPreviousWakeTime );
; 1291	        configASSERT( ( xTimeIncrement > 0U ) );
; 1292	        configASSERT( uxSchedulerSuspended == 0 );
; 1293	
; 1294	        vTaskSuspendAll();
.LINE 1294

	CALL	_vTaskSuspendAll
; 1295	        {
; 1296	            /* Minor optimisation.  The tick count cannot change in this
; 1297	             * block. */
; 1298	            const TickType_t xConstTickCount = xTickCount;
.LINE 1298

	LD	BC,(_xTickCount)
	LD	A,(_xTickCount+3)
	LD	(IX+%FFFFFFF5),BC
	LD	(IX+%FFFFFFF8),A
; 1299	
; 1300	            /* Generate the tick time at which the task wants to wake. */
; 1301	            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
.LINE 1301

	LD	IY,(IX+%6)
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	CALL	__ladd
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
; 1302	
; 1303	            if( xConstTickCount < *pxPreviousWakeTime )
.LINE 1303

	LD	IY,(IX+%6)
	LD	HL,(IX+%FFFFFFF5)
	LD	E,(IX+%FFFFFFF8)
	LD	BC,(IY)
	LD	A,(IY+%3)
	CALL	__lcmpu
	JR	NC,L_72
; 1304	            {
; 1305	                /* The tick count has overflowed since this function was
; 1306	                 * lasted called.  In this case the only time we should ever
; 1307	                 * actually delay is if the wake time has also  overflowed,
; 1308	                 * and the wake time is greater than the tick time.  When this
; 1309	                 * is the case it is as if neither time had overflowed. */
; 1310	                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
.LINE 1310

	LD	IY,(IX+%6)
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,(IY)
	LD	A,(IY+%3)
	CALL	__lcmpu
	JR	NC,L_73
	LD	HL,(IX+%FFFFFFF5)
	LD	E,(IX+%FFFFFFF8)
	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	CALL	__lcmpu
	JR	NC,L_73
; 1311	                {
; 1312	                    xShouldDelay = pdTRUE;
.LINE 1312

	LD	BC,1
	LD	(IX+%FFFFFFF9),BC
; 1313	                }
; 1314	                else
.LINE 1314

	JR	L_73
; 1315	                {
; 1316	                    mtCOVERAGE_TEST_MARKER();
; 1317	                }
; 1318	            }
; 1319	            else
.LINE 1319

L_72:
; 1320	            {
; 1321	                /* The tick time has not overflowed.  In this case we will
; 1322	                 * delay if either the wake time has overflowed, and/or the
; 1323	                 * tick time is less than the wake time. */
; 1324	                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
.LINE 1324

	LD	IY,(IX+%6)
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,(IY)
	LD	A,(IY+%3)
	CALL	__lcmpu
	JR	C,L_69
	LD	HL,(IX+%FFFFFFF5)
	LD	E,(IX+%FFFFFFF8)
	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	CALL	__lcmpu
	JR	NC,L_70
L_69:
; 1325	                {
; 1326	                    xShouldDelay = pdTRUE;
.LINE 1326

	LD	BC,1
	LD	(IX+%FFFFFFF9),BC
; 1327	                }
; 1328	                else
L_70:
.LINE 1328

; 1329	                {
; 1330	                    mtCOVERAGE_TEST_MARKER();
; 1331	                }
; 1332	            }
L_73:
.LINE 1332

; 1333	
; 1334	            /* Update the wake time ready for the next call. */
; 1335	            *pxPreviousWakeTime = xTimeToWake;
.LINE 1335

	LD	HL,(IX+%6)
	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
; 1336	
; 1337	            if( xShouldDelay != pdFALSE )
.LINE 1337

	LD	HL,(IX+%FFFFFFF9)
	CALL	__icmpzero
	JR	Z,L_75
; 1338	            {
; 1339	                traceTASK_DELAY_UNTIL( xTimeToWake );
; 1340	
; 1341	                /* prvAddCurrentTaskToDelayedList() needs the block time, not
; 1342	                 * the time to wake, so subtract the current tick count. */
; 1343	                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
.LINE 1343

	LD	BC,0
	PUSH	BC
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	CALL	__lsub
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	CALL	_prvAddCurrentTaskToDelayedList
	POP	BC
	POP	BC
	POP	BC
; 1344	            }
; 1345	            else
L_75:
.LINE 1345

; 1346	            {
; 1347	                mtCOVERAGE_TEST_MARKER();
; 1348	            }
; 1349	        }
; 1350	        xAlreadyYielded = xTaskResumeAll();
.LINE 1350

	CALL	_xTaskResumeAll
	LD	(IX+%FFFFFFF2),HL
; 1351	
; 1352	        /* Force a reschedule if xTaskResumeAll has not already done so, we may
; 1353	         * have put ourselves to sleep. */
; 1354	        if( xAlreadyYielded == pdFALSE )
.LINE 1354

	LD	HL,(IX+%FFFFFFF2)
	CALL	__icmpzero
	JR	NZ,L_78
; 1355	        {
; 1356	            portYIELD_WITHIN_API();
.LINE 1356

	CALL	_vPortYield
; 1357	        }
; 1358	        else
L_78:
.LINE 1358

; 1359	        {
; 1360	            mtCOVERAGE_TEST_MARKER();
; 1361	        }
; 1362	
; 1363	        return xShouldDelay;
.LINE 1363

	LD	HL,(IX+%FFFFFFF9)
; 1364	    }
.LINE 1364

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskDelayUntil ***************************
;Name                         Addr/Register   Size   Type
;_vPortYield                         IMPORT  -----   function
;_xTaskResumeAll                     IMPORT  -----   function
;_prvAddCurrentTaskToDelayedList      IMPORT  -----   function
;_xTickCount                         STATIC      4   variable
;_vTaskSuspendAll                    IMPORT  -----   function
;xAlreadyYielded                      IX-14      3   variable
;xConstTickCount                      IX-11      4   variable
;xShouldDelay                          IX-7      3   variable
;xTimeToWake                           IX-4      4   variable
;xTimeIncrement                        IX+9      4   parameter
;pxPreviousWakeTime                    IX+6      3   parameter


; Stack Frame Size: 29 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskDelayUntil",1364,"_xTaskDelayUntil"
; 1365	
; 1366	#endif /* INCLUDE_xTaskDelayUntil */
; 1367	/*-----------------------------------------------------------*/
; 1368	
; 1369	#if ( INCLUDE_vTaskDelay == 1 )
; 1370	
; 1371	    void vTaskDelay( const TickType_t xTicksToDelay )
; 1372	    {
_vTaskDelay:
.DEFINE "_vTaskDelay"

.VALUE _vTaskDelay

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vTaskDelay",1372,"_vTaskDelay"

.LINE 1372

.DEFINE "xTicksToDelay"

.CLASS 65

.VALUE 6

.TYPE 15

.ENDEF

.DEFINE "xAlreadyYielded"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
; 1373	        BaseType_t xAlreadyYielded = pdFALSE;
.LINE 1373

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 1374	
; 1375	        /* A delay time of zero just forces a reschedule. */
; 1376	        if( xTicksToDelay > ( TickType_t ) 0U )
.LINE 1376

	OR	A,A
	SBC	HL,HL
	LD	E,%0
	LD	BC,(IX+%6)
	LD	A,(IX+%9)
	CALL	__lcmpu
	JR	NC,L_82
; 1377	        {
; 1378	            configASSERT( uxSchedulerSuspended == 0 );
; 1379	            vTaskSuspendAll();
.LINE 1379

	CALL	_vTaskSuspendAll
; 1380	            {
; 1381	                traceTASK_DELAY();
; 1382	
; 1383	                /* A task that is removed from the event list while the
; 1384	                 * scheduler is suspended will not get placed in the ready
; 1385	                 * list or removed from the blocked list until the scheduler
; 1386	                 * is resumed.
; 1387	                 *
; 1388	                 * This task cannot be in an event list as it is the currently
; 1389	                 * executing task. */
; 1390	                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
.LINE 1390

	LD	BC,0
	PUSH	BC
	LD	C,(IX+%9)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_prvAddCurrentTaskToDelayedList
	POP	BC
	POP	BC
	POP	BC
; 1391	            }
; 1392	            xAlreadyYielded = xTaskResumeAll();
.LINE 1392

	CALL	_xTaskResumeAll
	LD	(IX+%FFFFFFFD),HL
; 1393	        }
; 1394	        else
L_82:
.LINE 1394

; 1395	        {
; 1396	            mtCOVERAGE_TEST_MARKER();
; 1397	        }
; 1398	
; 1399	        /* Force a reschedule if xTaskResumeAll has not already done so, we may
; 1400	         * have put ourselves to sleep. */
; 1401	        if( xAlreadyYielded == pdFALSE )
.LINE 1401

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	NZ,L_84
; 1402	        {
; 1403	            portYIELD_WITHIN_API();
.LINE 1403

	CALL	_vPortYield
; 1404	        }
; 1405	        else
L_84:
.LINE 1405

; 1406	        {
; 1407	            mtCOVERAGE_TEST_MARKER();
; 1408	        }
; 1409	    }
.LINE 1409

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vTaskDelay ***************************
;Name                         Addr/Register   Size   Type
;_vPortYield                         IMPORT  -----   function
;_xTaskResumeAll                     IMPORT  -----   function
;_prvAddCurrentTaskToDelayedList      IMPORT  -----   function
;_vTaskSuspendAll                    IMPORT  -----   function
;xAlreadyYielded                       IX-3      3   variable
;xTicksToDelay                         IX+6      4   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vTaskDelay",1409,"_vTaskDelay"
; 1410	
; 1411	#endif /* INCLUDE_vTaskDelay */
; 1412	/*-----------------------------------------------------------*/
; 1413	
; 1414	#if ( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay == 1 ) )
; 1415	
; 1416	    eTaskState eTaskGetState( TaskHandle_t xTask )
; 1417	    {
_eTaskGetState:
.DEFINE "_eTaskGetState"

.VALUE _eTaskGetState

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "eTaskGetState",1417,"_eTaskGetState"

.LINE 1417

.DEFINE "xTask"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "eReturn"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "pxStateList"

.CLASS 65

.VALUE -6

.TAG "xLIST"

.TYPE 200

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -9

.TYPE 4

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -12

.TAG "tskTaskControlBlock"

.TYPE 200

.ENDEF

.DEFINE "pxDelayedList"

.CLASS 65

.VALUE -15

.TAG "xLIST"

.TYPE 200

.ENDEF

.DEFINE "pxOverflowedDelayedList"

.CLASS 65

.VALUE -18

.TAG "xLIST"

.TYPE 200

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEE
	LD	SP,HL
; 1418	        eTaskState eReturn;
; 1419	        List_t const * pxStateList;
; 1420	        List_t const * pxDelayedList;
; 1421	        List_t const * pxOverflowedDelayedList;
; 1422	        const TCB_t * const pxTCB = xTask;
.LINE 1422

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFF4),BC
; 1423	
; 1424	        configASSERT( pxTCB );
; 1425	
; 1426	        if( pxTCB == pxCurrentTCB )
.LINE 1426

	LD	BC,(IX+%FFFFFFF4)
	LD	HL,(_pxCurrentTCB)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_104
; 1427	        {
; 1428	            /* The task calling this function is querying its own state. */
; 1429	            eReturn = eRunning;
.LINE 1429

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 1430	        }
; 1431	        else
.LINE 1431

	JR	L_105
L_104:
; 1432	        {
; 1433	            taskENTER_CRITICAL();
.LINE 1433

	 di
; 1434	            {
; 1435	                pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
.LINE 1435

	LD	IY,(IX+%FFFFFFF4)
	LD	BC,(IY+%10)
	LD	(IX+%FFFFFFFA),BC
; 1436	                pxDelayedList = pxDelayedTaskList;
.LINE 1436

	LD	BC,(_pxDelayedTaskList)
	LD	(IX+%FFFFFFF1),BC
; 1437	                pxOverflowedDelayedList = pxOverflowDelayedTaskList;
.LINE 1437

	LD	BC,(_pxOverflowDelayedTaskList)
	LD	(IX+%FFFFFFEE),BC
; 1438	            }
; 1439	            taskEXIT_CRITICAL();
.LINE 1439

	 ei
; 1440	
; 1441	            if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
.LINE 1441

	LD	BC,(IX+%FFFFFFF1)
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_101
	LD	BC,(IX+%FFFFFFEE)
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_102
L_101:
; 1442	            {
; 1443	                /* The task being queried is referenced from one of the Blocked
; 1444	                 * lists. */
; 1445	                eReturn = eBlocked;
.LINE 1445

	LD	BC,2
	LD	(IX+%FFFFFFFD),BC
; 1446	            }
; 1447	
; 1448	            #if ( INCLUDE_vTaskSuspend == 1 )
; 1449	                else if( pxStateList == &xSuspendedTaskList )
.LINE 1449

	JR	L_105
L_102:
	LD	BC,_xSuspendedTaskList
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_100
; 1450	                {
; 1451	                    /* The task being queried is referenced from the suspended
; 1452	                     * list.  Is it genuinely suspended or is it blocked
; 1453	                     * indefinitely? */
; 1454	                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
.LINE 1454

	LD	IY,(IX+%FFFFFFF4)
	LD	HL,(IY+%20)
	CALL	__icmpzero
	JR	NZ,L_95
; 1455	                    {
; 1456	                        #if ( configUSE_TASK_NOTIFICATIONS == 1 )
; 1457	                        {
; 1458	                            BaseType_t x;
; 1459	
; 1460	                            /* The task does not appear on the event list item of
; 1461	                             * and of the RTOS objects, but could still be in the
; 1462	                             * blocked state if it is waiting on its notification
; 1463	                             * rather than waiting on an object.  If not, is
; 1464	                             * suspended. */
; 1465	                            eReturn = eSuspended;
.LINE 1465

	LD	BC,3
	LD	(IX+%FFFFFFFD),BC
	JR	L_90
; 1466	
; 1467	                            for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
L_91:
.LINE 1467

	LD	BC,1
	LD	HL,(IX+%FFFFFFF7)
	OR	A,A
	SBC	HL,BC
	JP	M,L_93
	JR	L_105
L_90:
	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
	JR	L_91
L_93:
; 1468	                            {
; 1469	                                if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
.LINE 1469

	LD	BC,(IX+%FFFFFFF7)
	LD	IY,(IX+%FFFFFFF4)
	LEA	HL,IY+%43
	ADD	HL,BC
	LD	A,(HL)
	CP	A,%1
	JR	NZ,L_92
; 1470	                                {
; 1471	                                    eReturn = eBlocked;
.LINE 1471

	LD	BC,2
	LD	(IX+%FFFFFFFD),BC
; 1472	                                    break;
.LINE 1472

	JR	L_105
; 1473	                                }
; 1474	                            }
L_92:
.LINE 1474

	LD	BC,(IX+%FFFFFFF7)
	INC	BC
	LD	(IX+%FFFFFFF7),BC
	JR	L_91
; 1475	                        }
; 1476	                        #else /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
; 1477	                        {
; 1478	                            eReturn = eSuspended;
; 1479	                        }
; 1480	                        #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
; 1481	                    }
; 1482	                    else
L_95:
.LINE 1482

; 1483	                    {
; 1484	                        eReturn = eBlocked;
.LINE 1484

	LD	BC,2
	LD	(IX+%FFFFFFFD),BC
; 1485	                    }
; 1486	                }
; 1487	            #endif /* if ( INCLUDE_vTaskSuspend == 1 ) */
; 1488	
; 1489	            #if ( INCLUDE_vTaskDelete == 1 )
; 1490	                else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
.LINE 1490

	JR	L_105
L_100:
	LD	BC,_xTasksWaitingTermination
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_97
	LD	HL,(IX+%FFFFFFFA)
	CALL	__icmpzero
	JR	NZ,L_98
L_97:
; 1491	                {
; 1492	                    /* The task being queried is referenced from the deleted
; 1493	                     * tasks list, or it is not referenced from any lists at
; 1494	                     * all. */
; 1495	                    eReturn = eDeleted;
.LINE 1495

	LD	BC,4
	LD	(IX+%FFFFFFFD),BC
; 1496	                }
; 1497	            #endif
; 1498	
; 1499	            else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
.LINE 1499

	JR	L_105
L_98:
; 1500	            {
; 1501	                /* If the task is not in any other state, it must be in the
; 1502	                 * Ready (including pending ready) state. */
; 1503	                eReturn = eReady;
.LINE 1503

	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
; 1504	            }
; 1505	        }
L_105:
.LINE 1505

; 1506	
; 1507	        return eReturn;
.LINE 1507

	LD	HL,(IX+%FFFFFFFD)
; 1508	    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
.LINE 1508

	LD	SP,IX
	POP	IX
	RET	


;**************************** _eTaskGetState ***************************
;Name                         Addr/Register   Size   Type
;_xTasksWaitingTermination           STATIC     16   variable
;_xSuspendedTaskList                 STATIC     16   variable
;_pxOverflowDelayedTaskList          STATIC      3   variable
;_pxDelayedTaskList                  STATIC      3   variable
;_pxCurrentTCB                       STATIC      3   variable
;pxOverflowedDelayedList              IX-18      3   variable
;pxDelayedList                        IX-15      3   variable
;pxTCB                                IX-12      3   variable
;x                                     IX-9      3   variable
;pxStateList                           IX-6      3   variable
;eReturn                               IX-3      3   variable
;xTask                                 IX+6      3   parameter


; Stack Frame Size: 27 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "eTaskGetState",1508,"_eTaskGetState"
; 1509	
; 1510	#endif /* INCLUDE_eTaskGetState */
; 1511	/*-----------------------------------------------------------*/
; 1512	
; 1513	#if ( INCLUDE_uxTaskPriorityGet == 1 )
; 1514	
; 1515	    UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
; 1516	    {
_uxTaskPriorityGet:
.DEFINE "_uxTaskPriorityGet"

.VALUE _uxTaskPriorityGet

.CLASS 2

.TYPE 78

.ENDEF

.BEGFUNC "uxTaskPriorityGet",1516,"_uxTaskPriorityGet"

.LINE 1516

.DEFINE "xTask"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -6

.TAG "tskTaskControlBlock"

.TYPE 200

.ENDEF

.DEFINE "uxReturn"

.CLASS 65

.VALUE -9

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
; 1517	        TCB_t const * pxTCB;
; 1518	        UBaseType_t uxReturn;
; 1519	
; 1520	        taskENTER_CRITICAL();
.LINE 1520

	 di
; 1521	        {
; 1522	            /* If null is passed in here then it is the priority of the task
; 1523	             * that called uxTaskPriorityGet() that is being queried. */
; 1524	            pxTCB = prvGetTCBFromHandle( xTask );
.LINE 1524

	LD	HL,(IX+%6)
	CALL	__icmpzero
	JR	NZ,L_109
	LD	BC,(_pxCurrentTCB)
	LD	(IX+%FFFFFFFD),BC
	JR	L_110
L_109:
	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
L_110:
	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFFA),BC
; 1525	            uxReturn = pxTCB->uxPriority;
.LINE 1525

	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%23)
	LD	(IX+%FFFFFFF7),BC
; 1526	        }
; 1527	        taskEXIT_CRITICAL();
.LINE 1527

	 ei
; 1528	
; 1529	        return uxReturn;
.LINE 1529

	LD	HL,(IX+%FFFFFFF7)
; 1530	    }
.LINE 1530

	LD	SP,IX
	POP	IX
	RET	


;**************************** _uxTaskPriorityGet ***************************
;Name                         Addr/Register   Size   Type
;_pxCurrentTCB                       STATIC      3   variable
;uxReturn                              IX-9      3   variable
;pxTCB                                 IX-6      3   variable
;temp107                               IX-3      3   variable
;xTask                                 IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "uxTaskPriorityGet",1530,"_uxTaskPriorityGet"
; 1531	
; 1532	#endif /* INCLUDE_uxTaskPriorityGet */
; 1533	/*-----------------------------------------------------------*/
; 1534	
; 1535	#if ( INCLUDE_uxTaskPriorityGet == 1 )
; 1536	
; 1537	    UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
; 1538	    {
_uxTaskPriorityGetFromISR:
.DEFINE "_uxTaskPriorityGetFromISR"

.VALUE _uxTaskPriorityGetFromISR

.CLASS 2

.TYPE 78

.ENDEF

.BEGFUNC "uxTaskPriorityGetFromISR",1538,"_uxTaskPriorityGetFromISR"

.LINE 1538

.DEFINE "xTask"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -6

.TAG "tskTaskControlBlock"

.TYPE 200

.ENDEF

.DEFINE "uxReturn"

.CLASS 65

.VALUE -9

.TYPE 14

.ENDEF

.DEFINE "uxSavedInterruptState"

.CLASS 65

.VALUE -12

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF4
	LD	SP,HL
; 1539	        TCB_t const * pxTCB;
; 1540	        UBaseType_t uxReturn, uxSavedInterruptState;
; 1541	
; 1542	        /* RTOS ports that support interrupt nesting have the concept of a
; 1543	         * maximum  system call (or maximum API call) interrupt priority.
; 1544	         * Interrupts that are  above the maximum system call priority are keep
; 1545	         * permanently enabled, even when the RTOS kernel is in a critical section,
; 1546	         * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
; 1547	         * is defined in FreeRTOSConfig.h then
; 1548	         * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
; 1549	         * failure if a FreeRTOS API function is called from an interrupt that has
; 1550	         * been assigned a priority above the configured maximum system call
; 1551	         * priority.  Only FreeRTOS functions that end in FromISR can be called
; 1552	         * from interrupts  that have been assigned a priority at or (logically)
; 1553	         * below the maximum system call interrupt priority.  FreeRTOS maintains a
; 1554	         * separate interrupt safe API to ensure interrupt entry is as fast and as
; 1555	         * simple as possible.  More information (albeit Cortex-M specific) is
; 1556	         * provided on the following link:
; 1557	         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
; 1558	        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
; 1559	
; 1560	        uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
.LINE 1560

	LD	BC,0
	LD	(IX+%FFFFFFF4),BC
; 1561	        {
; 1562	            /* If null is passed in here then it is the priority of the calling
; 1563	             * task that is being queried. */
; 1564	            pxTCB = prvGetTCBFromHandle( xTask );
.LINE 1564

	LD	HL,(IX+%6)
	CALL	__icmpzero
	JR	NZ,L_114
	LD	BC,(_pxCurrentTCB)
	LD	(IX+%FFFFFFFD),BC
	JR	L_115
L_114:
	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
L_115:
	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFFA),BC
; 1565	            uxReturn = pxTCB->uxPriority;
.LINE 1565

	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%23)
	LD	(IX+%FFFFFFF7),BC
; 1566	        }
; 1567	        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
; 1568	
; 1569	        return uxReturn;
.LINE 1569

	LD	HL,(IX+%FFFFFFF7)
; 1570	    }
.LINE 1570

	LD	SP,IX
	POP	IX
	RET	


;**************************** _uxTaskPriorityGetFromISR ***************************
;Name                         Addr/Register   Size   Type
;_pxCurrentTCB                       STATIC      3   variable
;uxSavedInterruptState                IX-12      3   variable
;uxReturn                              IX-9      3   variable
;pxTCB                                 IX-6      3   variable
;temp112                               IX-3      3   variable
;xTask                                 IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "uxTaskPriorityGetFromISR",1570,"_uxTaskPriorityGetFromISR"
; 1571	
; 1572	#endif /* INCLUDE_uxTaskPriorityGet */
; 1573	/*-----------------------------------------------------------*/
; 1574	
; 1575	#if ( INCLUDE_vTaskPrioritySet == 1 )
; 1576	
; 1577	    void vTaskPrioritySet( TaskHandle_t xTask,
; 1578	                           UBaseType_t uxNewPriority )
; 1579	    {
_vTaskPrioritySet:
.DEFINE "_vTaskPrioritySet"

.VALUE _vTaskPrioritySet

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vTaskPrioritySet",1579,"_vTaskPrioritySet"

.LINE 1579

.DEFINE "xTask"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "uxNewPriority"

.CLASS 65

.VALUE 9

.TYPE 14

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -6

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

.DEFINE "xYieldRequired"

.CLASS 65

.VALUE -9

.TYPE 4

.ENDEF

.DEFINE "uxCurrentBasePriority"

.CLASS 65

.VALUE -18

.TYPE 14

.ENDEF

.DEFINE "uxPriorityUsedOnEntry"

.CLASS 65

.VALUE -21

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEB
	LD	SP,HL
; 1580	        TCB_t * pxTCB;
; 1581	        UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
; 1582	        BaseType_t xYieldRequired = pdFALSE;
.LINE 1582

	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
; 1583	
; 1584	        configASSERT( uxNewPriority < configMAX_PRIORITIES );
; 1585	
; 1586	        /* Ensure the new priority is valid. */
; 1587	        if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
.LINE 1587

	LD	BC,5
	LD	HL,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JR	C,L_118
; 1588	        {
; 1589	            uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
.LINE 1589

	LD	BC,4
	LD	(IX+%9),BC
; 1590	        }
; 1591	        else
L_118:
.LINE 1591

; 1592	        {
; 1593	            mtCOVERAGE_TEST_MARKER();
; 1594	        }
; 1595	
; 1596	        taskENTER_CRITICAL();
.LINE 1596

	 di
; 1597	        {
; 1598	            /* If null is passed in here then it is the priority of the calling
; 1599	             * task that is being changed. */
; 1600	            pxTCB = prvGetTCBFromHandle( xTask );
.LINE 1600

	LD	HL,(IX+%6)
	CALL	__icmpzero
	JR	NZ,L_122
	LD	BC,(_pxCurrentTCB)
	LD	(IX+%FFFFFFF4),BC
	JR	L_123
L_122:
	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFF4),BC
L_123:
	LD	BC,(IX+%FFFFFFF4)
	LD	(IX+%FFFFFFFD),BC
; 1601	
; 1602	            traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
; 1603	
; 1604	            #if ( configUSE_MUTEXES == 1 )
; 1605	            {
; 1606	                uxCurrentBasePriority = pxTCB->uxBasePriority;
.LINE 1606

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%39)
	LD	(IX+%FFFFFFEE),BC
; 1607	            }
; 1608	            #else
; 1609	            {
; 1610	                uxCurrentBasePriority = pxTCB->uxPriority;
; 1611	            }
; 1612	            #endif
; 1613	
; 1614	            if( uxCurrentBasePriority != uxNewPriority )
.LINE 1614

	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFEE)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_156
; 1615	            {
; 1616	                /* The priority change may have readied a task of higher
; 1617	                 * priority than the calling task. */
; 1618	                if( uxNewPriority > uxCurrentBasePriority )
.LINE 1618

	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFEE)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_131
; 1619	                {
; 1620	                    if( pxTCB != pxCurrentTCB )
.LINE 1620

	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(_pxCurrentTCB)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_132
; 1621	                    {
; 1622	                        /* The priority of a task other than the currently
; 1623	                         * running task is being raised.  Is the priority being
; 1624	                         * raised above that of the running task? */
; 1625	                        if( uxNewPriority >= pxCurrentTCB->uxPriority )
.LINE 1625

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IY+%23)
	LD	HL,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JR	C,L_132
; 1626	                        {
; 1627	                            xYieldRequired = pdTRUE;
.LINE 1627

	LD	BC,1
	LD	(IX+%FFFFFFF7),BC
; 1628	                        }
; 1629	                        else
.LINE 1629

	JR	L_132
; 1630	                        {
; 1631	                            mtCOVERAGE_TEST_MARKER();
; 1632	                        }
; 1633	                    }
; 1634	                    else
.LINE 1634

; 1635	                    {
; 1636	                        /* The priority of the running task is being raised,
; 1637	                         * but the running task must already be the highest
; 1638	                         * priority task able to run so no yield is required. */
; 1639	                    }
; 1640	                }
; 1641	                else if( pxTCB == pxCurrentTCB )
.LINE 1641

	JR	L_132
L_131:
	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(_pxCurrentTCB)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_129
; 1642	                {
; 1643	                    /* Setting the priority of the running task down means
; 1644	                     * there may now be another task of higher priority that
; 1645	                     * is ready to execute. */
; 1646	                    xYieldRequired = pdTRUE;
.LINE 1646

	LD	BC,1
	LD	(IX+%FFFFFFF7),BC
; 1647	                }
; 1648	                else
L_129:
.LINE 1648

; 1649	                {
; 1650	                    /* Setting the priority of any other task down does not
; 1651	                     * require a yield as the running task must be above the
; 1652	                     * new priority of the task being modified. */
; 1653	                }
L_132:
.LINE 1653

; 1654	
; 1655	                /* Remember the ready list the task might be referenced from
; 1656	                 * before its uxPriority member is changed so the
; 1657	                 * taskRESET_READY_PRIORITY() macro can function correctly. */
; 1658	                uxPriorityUsedOnEntry = pxTCB->uxPriority;
.LINE 1658

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	(IX+%FFFFFFEB),BC
; 1659	
; 1660	                #if ( configUSE_MUTEXES == 1 )
; 1661	                {
; 1662	                    /* Only change the priority being used if the task is not
; 1663	                     * currently using an inherited priority. */
; 1664	                    if( pxTCB->uxBasePriority == pxTCB->uxPriority )
.LINE 1664

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,(IY+%39)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_134
; 1665	                    {
; 1666	                        pxTCB->uxPriority = uxNewPriority;
.LINE 1666

	LD	BC,(IX+%9)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%23),BC
; 1667	                    }
; 1668	                    else
L_134:
.LINE 1668

; 1669	                    {
; 1670	                        mtCOVERAGE_TEST_MARKER();
; 1671	                    }
; 1672	
; 1673	                    /* The base priority gets set whatever. */
; 1674	                    pxTCB->uxBasePriority = uxNewPriority;
.LINE 1674

	LD	BC,(IX+%9)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%39),BC
; 1675	                }
; 1676	                #else /* if ( configUSE_MUTEXES == 1 ) */
; 1677	                {
; 1678	                    pxTCB->uxPriority = uxNewPriority;
; 1679	                }
; 1680	                #endif /* if ( configUSE_MUTEXES == 1 ) */
; 1681	
; 1682	                /* Only reset the event list item value if the value is not
; 1683	                 * being used for anything else. */
; 1684	                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
.LINE 1684

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%13)
	LD	E,(IY+%16)
	LD	BC,0
	LD	A,%80
	CALL	__land
	CALL	__lcmpzero
	JR	NZ,L_137
; 1685	                {
; 1686	                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
.LINE 1686

	LD	BC,(IX+%9)
	XOR	A,A
	LD	HL,5
	LD	E,%0
	CALL	__lsub
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%13),HL
	LD	(IY+%16),E
; 1687	                }
; 1688	                else
L_137:
.LINE 1688

; 1689	                {
; 1690	                    mtCOVERAGE_TEST_MARKER();
; 1691	                }
; 1692	
; 1693	                /* If the task is in the blocked or suspended list we need do
; 1694	                 * nothing more than change its priority variable. However, if
; 1695	                 * the task is in a ready list it needs to be removed and placed
; 1696	                 * in the list appropriate to its new priority. */
; 1697	                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
.LINE 1697

	LD	HL,(IX+%FFFFFFEB)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%10)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_140
	LD	BC,1
	LD	(IX+%FFFFFFF1),BC
	JR	L_141
L_140:
	LD	BC,0
	LD	(IX+%FFFFFFF1),BC
L_141:
	LD	HL,(IX+%FFFFFFF1)
	CALL	__icmpzero
	JR	Z,L_149
; 1698	                {
; 1699	                    /* The task is currently in its ready list - remove before
; 1700	                     * adding it to its new ready list.  As we are in a critical
; 1701	                     * section we can do this even if the scheduler is suspended. */
; 1702	                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
.LINE 1702

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%3
	CALL	_uxListRemove
	POP	BC
	CALL	__icmpzero
; 1703	                    {
; 1704	                        /* It is known that the task is in its ready list so
; 1705	                         * there is no need to check again and the port level
; 1706	                         * reset macro can be called directly. */
; 1707	                        portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
; 1708	                    }
; 1709	                    else
.LINE 1709

; 1710	                    {
; 1711	                        mtCOVERAGE_TEST_MARKER();
; 1712	                    }
; 1713	
; 1714	                    prvAddTaskToReadyList( pxTCB );
.LINE 1714

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,(_uxTopReadyPriority)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_146
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	(_uxTopReadyPriority),BC
L_146:
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFFA),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%A),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	DE,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,DE
	LD	(IY+%4),BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	(IY+%10),HL
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,_pxReadyTasksLists
	ADD	HL,DE
	LD	IY,BC
	LD	BC,(IY+%0)
	INC	BC
	LD	IY,HL
	LD	(IY+%0),BC
; 1715	                }
; 1716	                else
L_149:
.LINE 1716

; 1717	                {
; 1718	                    mtCOVERAGE_TEST_MARKER();
; 1719	                }
; 1720	
; 1721	                if( xYieldRequired != pdFALSE )
.LINE 1721

	LD	HL,(IX+%FFFFFFF7)
	CALL	__icmpzero
	JR	Z,L_154
; 1722	                {
; 1723	                    taskYIELD_IF_USING_PREEMPTION();
.LINE 1723

	CALL	_vPortYield
; 1724	                }
; 1725	                else
.LINE 1725

; 1726	                {
; 1727	                    mtCOVERAGE_TEST_MARKER();
; 1728	                }
L_154:
.LINE 1728

; 1729	
; 1730	                /* Remove compiler warning about unused variables when the port
; 1731	                 * optimised task selection is not being used. */
; 1732	                ( void ) uxPriorityUsedOnEntry;
; 1733	            }
; 1734	        }
L_156:
.LINE 1734

; 1735	        taskEXIT_CRITICAL();
.LINE 1735

	 ei
; 1736	    }
.LINE 1736

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vTaskPrioritySet ***************************
;Name                         Addr/Register   Size   Type
;_vPortYield                         IMPORT  -----   function
;_uxTopReadyPriority                 STATIC      3   variable
;_uxListRemove                       IMPORT  -----   function
;_pxReadyTasksLists                  STATIC     80   variable
;_pxCurrentTCB                       STATIC      3   variable
;uxPriorityUsedOnEntry                IX-21      3   variable
;uxCurrentBasePriority                IX-18      3   variable
;temp138                              IX-15      3   variable
;temp120                              IX-12      3   variable
;xYieldRequired                        IX-9      3   variable
;pxIndex                               IX-6      3   variable
;pxTCB                                 IX-3      3   variable
;uxNewPriority                         IX+9      3   parameter
;xTask                                 IX+6      3   parameter


; Stack Frame Size: 33 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vTaskPrioritySet",1736,"_vTaskPrioritySet"
; 1737	
; 1738	#endif /* INCLUDE_vTaskPrioritySet */
; 1739	/*-----------------------------------------------------------*/
; 1740	
; 1741	#if ( INCLUDE_vTaskSuspend == 1 )
; 1742	
; 1743	    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
; 1744	    {
_vTaskSuspend:
.DEFINE "_vTaskSuspend"

.VALUE _vTaskSuspend

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vTaskSuspend",1744,"_vTaskSuspend"

.LINE 1744

.DEFINE "xTaskToSuspend"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
; 1745	        TCB_t * pxTCB;
; 1746	
; 1747	        taskENTER_CRITICAL();
.LINE 1747

	 di
; 1748	        {
; 1749	            /* If null is passed in here then it is the running task that is
; 1750	             * being suspended. */
; 1751	            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
.LINE 1751

	LD	HL,(IX+%6)
	CALL	__icmpzero
	JR	NZ,L_160
	LD	BC,(_pxCurrentTCB)
	LD	(IX+%FFFFFFF7),BC
	JR	L_161
L_160:
	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFF7),BC
L_161:
	LD	BC,(IX+%FFFFFFF7)
	LD	(IX+%FFFFFFFD),BC
; 1752	
; 1753	            traceTASK_SUSPEND( pxTCB );
; 1754	
; 1755	            /* Remove task from the ready/delayed list and place in the
; 1756	             * suspended list. */
; 1757	            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
.LINE 1757

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%3
	CALL	_uxListRemove
	POP	BC
	CALL	__icmpzero
; 1758	            {
; 1759	                taskRESET_READY_PRIORITY( pxTCB->uxPriority );
; 1760	            }
; 1761	            else
.LINE 1761

; 1762	            {
; 1763	                mtCOVERAGE_TEST_MARKER();
; 1764	            }
; 1765	
; 1766	            /* Is the task waiting on an event also? */
; 1767	            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
.LINE 1767

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%20)
	CALL	__icmpzero
	JR	Z,L_165
; 1768	            {
; 1769	                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
.LINE 1769

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%13
	CALL	_uxListRemove
	POP	BC
; 1770	            }
; 1771	            else
L_165:
.LINE 1771

; 1772	            {
; 1773	                mtCOVERAGE_TEST_MARKER();
; 1774	            }
; 1775	
; 1776	            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
.LINE 1776

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%3
	LD	BC,_xSuspendedTaskList
	PUSH	BC
	CALL	_vListInsertEnd
	POP	BC
	POP	BC
	JR	L_170
; 1777	
; 1778	            #if ( configUSE_TASK_NOTIFICATIONS == 1 )
; 1779	            {
; 1780	                BaseType_t x;
; 1781	
; 1782	                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
L_171:
.LINE 1782

	LD	BC,1
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_173
	JR	L_174
L_170:
	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
	JR	L_171
L_173:
; 1783	                {
; 1784	                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
.LINE 1784

	LD	BC,(IX+%FFFFFFFA)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%43
	ADD	HL,BC
	LD	IY,HL
	LD	A,(HL)
	CP	A,%1
	JR	NZ,L_172
; 1785	                    {
; 1786	                        /* The task was blocked to wait for a notification, but is
; 1787	                         * now suspended, so no notification was received. */
; 1788	                        pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
.LINE 1788

	LD	BC,(IX+%FFFFFFFA)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%43
	ADD	HL,BC
	LD	IY,HL
	LD	(HL),%0
; 1789	                    }
; 1790	                }
L_172:
.LINE 1790

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
	JR	L_171
; 1791	            }
; 1792	            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
; 1793	        }
L_174:
.LINE 1793

; 1794	        taskEXIT_CRITICAL();
.LINE 1794

	 ei
; 1795	
; 1796	        if( xSchedulerRunning != pdFALSE )
.LINE 1796

	LD	HL,(_xSchedulerRunning)
	CALL	__icmpzero
	JR	Z,L_176
; 1797	        {
; 1798	            /* Reset the next expected unblock time in case it referred to the
; 1799	             * task that is now in the Suspended state. */
; 1800	            taskENTER_CRITICAL();
.LINE 1800

	 di
; 1801	            {
; 1802	                prvResetNextTaskUnblockTime();
.LINE 1802

	CALL	_prvResetNextTaskUnblockTime
; 1803	            }
; 1804	            taskEXIT_CRITICAL();
.LINE 1804

	 ei
; 1805	        }
; 1806	        else
L_176:
.LINE 1806

; 1807	        {
; 1808	            mtCOVERAGE_TEST_MARKER();
; 1809	        }
; 1810	
; 1811	        if( pxTCB == pxCurrentTCB )
.LINE 1811

	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(_pxCurrentTCB)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_182
; 1812	        {
; 1813	            if( xSchedulerRunning != pdFALSE )
.LINE 1813

	LD	HL,(_xSchedulerRunning)
	CALL	__icmpzero
	JR	Z,L_180
; 1814	            {
; 1815	                /* The current task has just been suspended. */
; 1816	                configASSERT( uxSchedulerSuspended == 0 );
; 1817	                portYIELD_WITHIN_API();
.LINE 1817

	CALL	_vPortYield
; 1818	            }
; 1819	            else
.LINE 1819

	JR	L_184
L_180:
; 1820	            {
; 1821	                /* The scheduler is not running, but the task that was pointed
; 1822	                 * to by pxCurrentTCB has just been suspended and pxCurrentTCB
; 1823	                 * must be adjusted to point to a different task. */
; 1824	                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
.LINE 1824

	LD	BC,(_uxCurrentNumberOfTasks)
	LD	HL,(_xSuspendedTaskList)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_178
; 1825	                {
; 1826	                    /* No other tasks are ready, so set pxCurrentTCB back to
; 1827	                     * NULL so when the next task is created pxCurrentTCB will
; 1828	                     * be set to point to it no matter what its relative priority
; 1829	                     * is. */
; 1830	                    pxCurrentTCB = NULL;
.LINE 1830

	LD	BC,0
	LD	(_pxCurrentTCB),BC
; 1831	                }
; 1832	                else
.LINE 1832

	JR	L_184
L_178:
; 1833	                {
; 1834	                    vTaskSwitchContext();
.LINE 1834

	CALL	_vTaskSwitchContext
; 1835	                }
; 1836	            }
; 1837	        }
; 1838	        else
L_182:
.LINE 1838

; 1839	        {
; 1840	            mtCOVERAGE_TEST_MARKER();
; 1841	        }
; 1842	    }
L_184:
.LINE 1842

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vTaskSuspend ***************************
;Name                         Addr/Register   Size   Type
;_vTaskSwitchContext                 IMPORT  -----   function
;_uxCurrentNumberOfTasks             STATIC      3   variable
;_vPortYield                         IMPORT  -----   function
;_prvResetNextTaskUnblockTime        IMPORT  -----   function
;_xSchedulerRunning                  STATIC      3   variable
;_xSuspendedTaskList                 STATIC     16   variable
;_vListInsertEnd                     IMPORT  -----   function
;_uxListRemove                       IMPORT  -----   function
;_pxCurrentTCB                       STATIC      3   variable
;temp158                               IX-9      3   variable
;x                                     IX-6      3   variable
;pxTCB                                 IX-3      3   variable
;xTaskToSuspend                        IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vTaskSuspend",1842,"_vTaskSuspend"
; 1843	
; 1844	#endif /* INCLUDE_vTaskSuspend */
; 1845	/*-----------------------------------------------------------*/
; 1846	
; 1847	#if ( INCLUDE_vTaskSuspend == 1 )
; 1848	
; 1849	    static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
; 1850	    {
_prvTaskIsTaskSuspended:
.DEFINE "_prvTaskIsTaskSuspended"

.VALUE _prvTaskIsTaskSuspended

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "prvTaskIsTaskSuspended",1850,"_prvTaskIsTaskSuspended"

.LINE 1850

.DEFINE "xTask"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 200

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF1
	LD	SP,HL
; 1851	        BaseType_t xReturn = pdFALSE;
.LINE 1851

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
; 1852	        const TCB_t * const pxTCB = xTask;
.LINE 1852

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 1853	
; 1854	        /* Accesses xPendingReadyList so must be called from a critical
; 1855	         * section. */
; 1856	
; 1857	        /* It does not make sense to check if the calling task is suspended. */
; 1858	        configASSERT( xTask );
; 1859	
; 1860	        /* Is the task being resumed actually in the suspended list? */
; 1861	        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
.LINE 1861

	LD	BC,_xSuspendedTaskList
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%10)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_187
	LD	BC,1
	LD	(IX+%FFFFFFF7),BC
	JR	L_188
L_187:
	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
L_188:
	LD	HL,(IX+%FFFFFFF7)
	CALL	__icmpzero
	JR	Z,L_202
; 1862	        {
; 1863	            /* Has the task already been resumed from within an ISR? */
; 1864	            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
.LINE 1864

	LD	BC,_xPendingReadyList
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%20)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_191
	LD	BC,1
	LD	(IX+%FFFFFFF4),BC
	JR	L_192
L_191:
	LD	BC,0
	LD	(IX+%FFFFFFF4),BC
L_192:
	LD	HL,(IX+%FFFFFFF4)
	CALL	__icmpzero
	JR	NZ,L_200
; 1865	            {
; 1866	                /* Is it in the suspended list because it is in the Suspended
; 1867	                 * state, or because is is blocked with no timeout? */
; 1868	                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
.LINE 1868

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%20)
	CALL	__icmpzero
	JR	NZ,L_195
	LD	BC,1
	LD	(IX+%FFFFFFF1),BC
	JR	L_196
L_195:
	LD	BC,0
	LD	(IX+%FFFFFFF1),BC
L_196:
	LD	HL,(IX+%FFFFFFF1)
	CALL	__icmpzero
	JR	Z,L_198
; 1869	                {
; 1870	                    xReturn = pdTRUE;
.LINE 1870

	LD	BC,1
	LD	(IX+%FFFFFFFA),BC
; 1871	                }
; 1872	                else
L_198:
.LINE 1872

; 1873	                {
; 1874	                    mtCOVERAGE_TEST_MARKER();
; 1875	                }
; 1876	            }
; 1877	            else
L_200:
.LINE 1877

; 1878	            {
; 1879	                mtCOVERAGE_TEST_MARKER();
; 1880	            }
; 1881	        }
; 1882	        else
L_202:
.LINE 1882

; 1883	        {
; 1884	            mtCOVERAGE_TEST_MARKER();
; 1885	        }
; 1886	
; 1887	        return xReturn;
.LINE 1887

	LD	HL,(IX+%FFFFFFFA)
; 1888	    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
.LINE 1888

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvTaskIsTaskSuspended ***************************
;Name                         Addr/Register   Size   Type
;_xPendingReadyList                  STATIC     16   variable
;_xSuspendedTaskList                 STATIC     16   variable
;temp193                              IX-15      3   variable
;temp189                              IX-12      3   variable
;temp185                               IX-9      3   variable
;xReturn                               IX-6      3   variable
;pxTCB                                 IX-3      3   variable
;xTask                                 IX+6      3   parameter


; Stack Frame Size: 24 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvTaskIsTaskSuspended",1888,"_prvTaskIsTaskSuspended"
; 1889	
; 1890	#endif /* INCLUDE_vTaskSuspend */
; 1891	/*-----------------------------------------------------------*/
; 1892	
; 1893	#if ( INCLUDE_vTaskSuspend == 1 )
; 1894	
; 1895	    void vTaskResume( TaskHandle_t xTaskToResume )
; 1896	    {
_vTaskResume:
.DEFINE "_vTaskResume"

.VALUE _vTaskResume

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vTaskResume",1896,"_vTaskResume"

.LINE 1896

.DEFINE "xTaskToResume"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -6

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
; 1897	        TCB_t * const pxTCB = xTaskToResume;
.LINE 1897

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 1898	
; 1899	        /* It does not make sense to resume the calling task. */
; 1900	        configASSERT( xTaskToResume );
; 1901	
; 1902	        /* The parameter cannot be NULL as it is impossible to resume the
; 1903	         * currently executing task. */
; 1904	        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
.LINE 1904

	LD	BC,(IX+%FFFFFFFD)
	LD	HL,(_pxCurrentTCB)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_215
	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	Z,L_215
; 1905	        {
; 1906	            taskENTER_CRITICAL();
.LINE 1906

	 di
; 1907	            {
; 1908	                if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
.LINE 1908

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvTaskIsTaskSuspended
	POP	BC
	CALL	__icmpzero
	JR	Z,L_212
; 1909	                {
; 1910	                    traceTASK_RESUME( pxTCB );
; 1911	
; 1912	                    /* The ready list can be accessed even if the scheduler is
; 1913	                     * suspended because this is inside a critical section. */
; 1914	                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
.LINE 1914

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%3
	CALL	_uxListRemove
	POP	BC
; 1915	                    prvAddTaskToReadyList( pxTCB );
.LINE 1915

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,(_uxTopReadyPriority)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_207
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	(_uxTopReadyPriority),BC
L_207:
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFFA),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%A),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	DE,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,DE
	LD	(IY+%4),BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	(IY+%10),HL
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,_pxReadyTasksLists
	ADD	HL,DE
	LD	IY,BC
	LD	BC,(IY+%0)
	INC	BC
	LD	IY,HL
	LD	(IY+%0),BC
; 1916	
; 1917	                    /* A higher priority task may have just been resumed. */
; 1918	                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
.LINE 1918

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IY+%23)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	OR	A,A
	SBC	HL,BC
	JR	C,L_210
; 1919	                    {
; 1920	                        /* This yield may not cause the task just resumed to run,
; 1921	                         * but will leave the lists in the correct state for the
; 1922	                         * next yield. */
; 1923	                        taskYIELD_IF_USING_PREEMPTION();
.LINE 1923

	CALL	_vPortYield
; 1924	                    }
; 1925	                    else
L_210:
.LINE 1925

; 1926	                    {
; 1927	                        mtCOVERAGE_TEST_MARKER();
; 1928	                    }
; 1929	                }
; 1930	                else
L_212:
.LINE 1930

; 1931	                {
; 1932	                    mtCOVERAGE_TEST_MARKER();
; 1933	                }
; 1934	            }
; 1935	            taskEXIT_CRITICAL();
.LINE 1935

	 ei
; 1936	        }
; 1937	        else
L_215:
.LINE 1937

; 1938	        {
; 1939	            mtCOVERAGE_TEST_MARKER();
; 1940	        }
; 1941	    }
.LINE 1941

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vTaskResume ***************************
;Name                         Addr/Register   Size   Type
;_vPortYield                         IMPORT  -----   function
;_pxReadyTasksLists                  STATIC     80   variable
;_uxTopReadyPriority                 STATIC      3   variable
;_uxListRemove                       IMPORT  -----   function
;_prvTaskIsTaskSuspended             IMPORT  -----   function
;_pxCurrentTCB                       STATIC      3   variable
;pxIndex                               IX-6      3   variable
;pxTCB                                 IX-3      3   variable
;xTaskToResume                         IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vTaskResume",1941,"_vTaskResume"
; 1942	
; 1943	#endif /* INCLUDE_vTaskSuspend */
; 1944	
; 1945	/*-----------------------------------------------------------*/
; 1946	
; 1947	#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
; 1948	
; 1949	    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
; 1950	    {
_xTaskResumeFromISR:
.DEFINE "_xTaskResumeFromISR"

.VALUE _xTaskResumeFromISR

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xTaskResumeFromISR",1950,"_xTaskResumeFromISR"

.LINE 1950

.DEFINE "xTaskToResume"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -6

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

.DEFINE "xYieldRequired"

.CLASS 65

.VALUE -9

.TYPE 4

.ENDEF

.DEFINE "uxSavedInterruptStatus"

.CLASS 65

.VALUE -12

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF4
	LD	SP,HL
; 1951	        BaseType_t xYieldRequired = pdFALSE;
.LINE 1951

	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
; 1952	        TCB_t * const pxTCB = xTaskToResume;
.LINE 1952

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 1953	        UBaseType_t uxSavedInterruptStatus;
; 1954	
; 1955	        configASSERT( xTaskToResume );
; 1956	
; 1957	        /* RTOS ports that support interrupt nesting have the concept of a
; 1958	         * maximum  system call (or maximum API call) interrupt priority.
; 1959	         * Interrupts that are  above the maximum system call priority are keep
; 1960	         * permanently enabled, even when the RTOS kernel is in a critical section,
; 1961	         * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
; 1962	         * is defined in FreeRTOSConfig.h then
; 1963	         * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
; 1964	         * failure if a FreeRTOS API function is called from an interrupt that has
; 1965	         * been assigned a priority above the configured maximum system call
; 1966	         * priority.  Only FreeRTOS functions that end in FromISR can be called
; 1967	         * from interrupts  that have been assigned a priority at or (logically)
; 1968	         * below the maximum system call interrupt priority.  FreeRTOS maintains a
; 1969	         * separate interrupt safe API to ensure interrupt entry is as fast and as
; 1970	         * simple as possible.  More information (albeit Cortex-M specific) is
; 1971	         * provided on the following link:
; 1972	         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
; 1973	        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
; 1974	
; 1975	        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
.LINE 1975

	LD	BC,0
	LD	(IX+%FFFFFFF4),BC
; 1976	        {
; 1977	            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
.LINE 1977

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvTaskIsTaskSuspended
	POP	BC
	CALL	__icmpzero
	JR	Z,L_226
; 1978	            {
; 1979	                traceTASK_RESUME_FROM_ISR( pxTCB );
; 1980	
; 1981	                /* Check the ready lists can be accessed. */
; 1982	                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
.LINE 1982

	LD	HL,(_uxSchedulerSuspended)
	CALL	__icmpzero
	JR	NZ,L_224
; 1983	                {
; 1984	                    /* Ready lists can be accessed so move the task from the
; 1985	                     * suspended list to the ready list directly. */
; 1986	                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
.LINE 1986

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IY+%23)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	OR	A,A
	SBC	HL,BC
	JR	C,L_218
; 1987	                    {
; 1988	                        xYieldRequired = pdTRUE;
.LINE 1988

	LD	BC,1
	LD	(IX+%FFFFFFF7),BC
; 1989	
; 1990	                        /* Mark that a yield is pending in case the user is not
; 1991	                         * using the return value to initiate a context switch
; 1992	                         * from the ISR using portYIELD_FROM_ISR. */
; 1993	                        xYieldPending = pdTRUE;
.LINE 1993

	LD	BC,1
	LD	(_xYieldPending),BC
; 1994	                    }
; 1995	                    else
L_218:
.LINE 1995

; 1996	                    {
; 1997	                        mtCOVERAGE_TEST_MARKER();
; 1998	                    }
; 1999	
; 2000	                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
.LINE 2000

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%3
	CALL	_uxListRemove
	POP	BC
; 2001	                    prvAddTaskToReadyList( pxTCB );
.LINE 2001

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,(_uxTopReadyPriority)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_221
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	(_uxTopReadyPriority),BC
L_221:
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFFA),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%A),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	DE,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,DE
	LD	(IY+%4),BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	(IY+%10),HL
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,_pxReadyTasksLists
	ADD	HL,DE
	LD	IY,BC
	LD	BC,(IY+%0)
	INC	BC
	LD	IY,HL
	LD	(IY+%0),BC
; 2002	                }
; 2003	                else
.LINE 2003

	JR	L_227
L_224:
; 2004	                {
; 2005	                    /* The delayed or ready lists cannot be accessed so the task
; 2006	                     * is held in the pending ready list until the scheduler is
; 2007	                     * unsuspended. */
; 2008	                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
.LINE 2008

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%13
	LD	BC,_xPendingReadyList
	PUSH	BC
	CALL	_vListInsertEnd
	POP	BC
	POP	BC
; 2009	                }
; 2010	            }
; 2011	            else
L_226:
.LINE 2011

; 2012	            {
; 2013	                mtCOVERAGE_TEST_MARKER();
; 2014	            }
; 2015	        }
L_227:
.LINE 2015

; 2016	        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
; 2017	
; 2018	        return xYieldRequired;
.LINE 2018

	LD	HL,(IX+%FFFFFFF7)
; 2019	    }
.LINE 2019

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskResumeFromISR ***************************
;Name                         Addr/Register   Size   Type
;_xPendingReadyList                  STATIC     16   variable
;_vListInsertEnd                     IMPORT  -----   function
;_pxReadyTasksLists                  STATIC     80   variable
;_uxTopReadyPriority                 STATIC      3   variable
;_uxListRemove                       IMPORT  -----   function
;_xYieldPending                      STATIC      3   variable
;_pxCurrentTCB                       STATIC      3   variable
;_uxSchedulerSuspended               STATIC      3   variable
;_prvTaskIsTaskSuspended             IMPORT  -----   function
;uxSavedInterruptStatus               IX-12      3   variable
;xYieldRequired                        IX-9      3   variable
;pxIndex                               IX-6      3   variable
;pxTCB                                 IX-3      3   variable
;xTaskToResume                         IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskResumeFromISR",2019,"_xTaskResumeFromISR"
; 2020	
; 2021	#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
; 2022	/*-----------------------------------------------------------*/
; 2023	
; 2024	void vTaskStartScheduler( void )
; 2025	{
_vTaskStartScheduler:
.DEFINE "_vTaskStartScheduler"

.VALUE _vTaskStartScheduler

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vTaskStartScheduler",2025,"_vTaskStartScheduler"

.LINE 2025

.DEFINE "xReturn"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "r"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
; 2026	    BaseType_t xReturn;
; 2027		portBASE_TYPE r;
; 2028		
; 2029	    /* Add the idle task at the lowest priority. */
; 2030	    #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
; 2031	    {
; 2032	        StaticTask_t * pxIdleTaskTCBBuffer = NULL;
; 2033	        StackType_t * pxIdleTaskStackBuffer = NULL;
; 2034	        uint32_t ulIdleTaskStackSize;
; 2035	
; 2036	        /* The Idle task is created using user provided RAM - obtain the
; 2037	         * address of the RAM then create the idle task. */
; 2038	        vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
; 2039	        xIdleTaskHandle = xTaskCreateStatic( prvIdleTask,
; 2040	                                             configIDLE_TASK_NAME,
; 2041	                                             ulIdleTaskStackSize,
; 2042	                                             ( void * ) NULL,       /*lint !e961.  The cast is not redundant for all compilers. */
; 2043	                                             portPRIVILEGE_BIT,     /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
; 2044	                                             pxIdleTaskStackBuffer,
; 2045	                                             pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
; 2046	
; 2047	        if( xIdleTaskHandle != NULL )
; 2048	        {
; 2049	            xReturn = pdPASS;
; 2050	        }
; 2051	        else
; 2052	        {
; 2053	            xReturn = pdFAIL;
; 2054	        }
; 2055	    }
; 2056	    #else /* !( configSUPPORT_STATIC_ALLOCATION == 1 ) */
; 2057	    {
; 2058	        /* The Idle task is being created using dynamically allocated RAM. */
; 2059	        xReturn = xTaskCreate( prvIdleTask,
; 2060	                               configIDLE_TASK_NAME,
; 2061	                               configMINIMAL_STACK_SIZE,
; 2062	                               ( void * ) NULL,
; 2063	                               portPRIVILEGE_BIT,  /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
; 2064	                               &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
.LINE 2064

	LD	BC,_xIdleTaskHandle
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,512
	PUSH	BC
	LD	BC,L__94
	PUSH	BC
	LD	BC,_prvIdleTask
	PUSH	BC
	CALL	_xTaskCreate
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 2065	
; 2066	#		if defined( _DEBUG )&& 0
; 2067			{
; 2068				if( pdPASS != xReturn )
; 2069				{
; 2070					( void )printf( "Failed to Create Idle task\r\n" );				
; 2071				}
; 2072				else
; 2073				{
; 2074					( void )printf( "Created Idle task\r\n" );				
; 2075				}
; 2076			}
; 2077	#		endif
; 2078	    }
; 2079	    #endif /* configSUPPORT_STATIC_ALLOCATION */
; 2080	
; 2081	    #if ( configUSE_TIMERS == 1 )
; 2082	    {
; 2083	        if( xReturn == pdPASS )
; 2084	        {
; 2085	            xReturn = xTimerCreateTimerTask();
; 2086	        }
; 2087	        else
; 2088	        {
; 2089	            mtCOVERAGE_TEST_MARKER();
; 2090	        }
; 2091	    }
; 2092	    #endif /* configUSE_TIMERS */
; 2093	
; 2094	    if( xReturn == pdPASS )
.LINE 2094

	LD	BC,1
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_232
; 2095	    {
; 2096	        /* freertos_tasks_c_additions_init() should only be called if the user
; 2097	         * definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
; 2098	         * the only macro called by the function. */
; 2099	        #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
; 2100	        {
; 2101	            freertos_tasks_c_additions_init();
; 2102	        }
; 2103	        #endif
; 2104	
; 2105	        /* Interrupts are turned off here, to ensure a tick does not occur
; 2106	         * before or during the call to xPortStartScheduler().  The stacks of
; 2107	         * the created tasks contain a status word with interrupts switched on
; 2108	         * so interrupts will automatically get re-enabled when the first task
; 2109	         * starts to run. */
; 2110	#		if defined( _DEBUG )&& 0
; 2111				( void )printf( "%s : %d\r\n", "tasks.c", __LINE__ );
; 2112	#		endif
; 2113			portDISABLE_INTERRUPTS();
.LINE 2113

	 di
; 2114	
; 2115	        #if ( ( configUSE_NEWLIB_REENTRANT == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 ) )
; 2116	        {
; 2117	            /* Switch C-Runtime's TLS Block to point to the TLS
; 2118	             * block specific to the task that will run first. */
; 2119	            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
; 2120	        }
; 2121	        #endif
; 2122	
; 2123	        xNextTaskUnblockTime = portMAX_DELAY;
.LINE 2123

	LD	BC,16777215
	LD	A,%FF
	LD	(_xNextTaskUnblockTime),BC
	LD	(_xNextTaskUnblockTime+3),A
; 2124	        xSchedulerRunning = pdTRUE;
.LINE 2124

	LD	BC,1
	LD	(_xSchedulerRunning),BC
; 2125	        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
.LINE 2125

	LD	BC,0
	XOR	A,A
	LD	(_xTickCount),BC
	LD	(_xTickCount+3),A
; 2126	
; 2127	        /* If configGENERATE_RUN_TIME_STATS is defined then the following
; 2128	         * macro must be defined to configure the timer/counter used to generate
; 2129	         * the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
; 2130	         * is set to 0 and the following line fails to build then ensure you do not
; 2131	         * have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
; 2132	         * FreeRTOSConfig.h file. */
; 2133	        portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
; 2134	
; 2135	        traceTASK_SWITCHED_IN();
; 2136	#		if defined( _DEBUG )&& 0
; 2137				( void )printf( "%s : %d\r\n", "tasks.c", __LINE__ );
; 2138	#		endif
; 2139	
; 2140	        /* Setting up the timer tick is hardware specific and thus in the
; 2141	         * portable interface. */
; 2142	        r = xPortStartScheduler( );
.LINE 2142

	CALL	_xPortStartScheduler
	LD	(IX+%FFFFFFFA),HL
; 2143	
; 2144	        /* In most cases, xPortStartScheduler() will not return. If it
; 2145	         * returns pdTRUE then there was not enough heap memory available
; 2146	         * to create either the Idle or the Timer task. If it returned
; 2147	         * pdFALSE, then the application called xTaskEndScheduler().
; 2148	         * Most ports don't implement xTaskEndScheduler() as there is
; 2149	         * nothing to return to. */
; 2150	#		if defined( _DEBUG )&& 0
; 2151				( void )printf( "%s : %d : %d\r\n", "tasks.c", __LINE__, r );
; 2152	#		endif
; 2153	
; 2154			vPortEndScheduler( );
.LINE 2154

	CALL	_vPortEndScheduler
; 2155			vTaskSuspendAll( );
.LINE 2155

	CALL	_vTaskSuspendAll
; 2156			/* After here the stack may not be set up to return to main.
; 2157			   So to be safe we should just spin here. And blink an ended LED. */
; 2158			for( ;; );
L_229:
.LINE 2158

	JR	L_229
; 2159	    }
; 2160	    else
L_232:
.LINE 2160

; 2161	    {
; 2162	        /* This line will only be reached if the kernel could not be started,
; 2163	         * because there was not enough FreeRTOS heap to create the idle task
; 2164	         * or the timer task. */
; 2165	        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
; 2166	    }
; 2167	
; 2168		#if !defined( __EZ80__ )  /* The ZDSII eZ80 compiler cannot cast away global variables */
; 2169		{
; 2170			/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
; 2171			 * meaning xIdleTaskHandle is not used anywhere else. */
; 2172			( void ) xIdleTaskHandle;
; 2173	
; 2174			/* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
; 2175			 * from getting optimized out as it is no longer used by the kernel. */
; 2176			( void ) uxTopUsedPriority;
; 2177		}
; 2178		#endif
; 2179	}
.LINE 2179

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vTaskStartScheduler ***************************
;Name                         Addr/Register   Size   Type
;_vTaskSuspendAll                    IMPORT  -----   function
;_vPortEndScheduler                  IMPORT  -----   function
;_xPortStartScheduler                IMPORT  -----   function
;_xTickCount                         STATIC      4   variable
;_xSchedulerRunning                  STATIC      3   variable
;_xNextTaskUnblockTime               STATIC      4   variable
;_prvIdleTask                        IMPORT  -----   function
;_xIdleTaskHandle                    STATIC      3   variable
;_xTaskCreate                        IMPORT  -----   function
;r                                     IX-6      3   variable
;xReturn                               IX-3      3   variable


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vTaskStartScheduler",2179,"_vTaskStartScheduler"
	SEGMENT STRSECT
L__94:
	DB	"IDLE"
	DB	0
	SEGMENT CODE
; 2180	/*-----------------------------------------------------------*/
; 2181	
; 2182	void vTaskEndScheduler( void )
; 2183	{
_vTaskEndScheduler:
.DEFINE "_vTaskEndScheduler"

.VALUE _vTaskEndScheduler

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vTaskEndScheduler",2183,"_vTaskEndScheduler"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 2184	    /* Stop the scheduler interrupts and call the portable scheduler end
; 2185	     * routine so the original ISRs can be restored if necessary.  The port
; 2186	     * layer must ensure interrupts enable  bit is left in the correct state. */
; 2187	    portDISABLE_INTERRUPTS();
.LINE 2187

	 di
; 2188	    xSchedulerRunning = pdFALSE;
.LINE 2188

	LD	BC,0
	LD	(_xSchedulerRunning),BC
; 2189	    vPortEndScheduler();
.LINE 2189

	CALL	_vPortEndScheduler
; 2190	}
.LINE 2190

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vTaskEndScheduler ***************************
;Name                         Addr/Register   Size   Type
;_vPortEndScheduler                  IMPORT  -----   function
;_xSchedulerRunning                  STATIC      3   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vTaskEndScheduler",2190,"_vTaskEndScheduler"
; 2191	/*----------------------------------------------------------*/
; 2192	
; 2193	void vTaskSuspendAll( void )
; 2194	{
_vTaskSuspendAll:
.DEFINE "_vTaskSuspendAll"

.VALUE _vTaskSuspendAll

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vTaskSuspendAll",2194,"_vTaskSuspendAll"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 2195	    /* A critical section is not required as the variable is of type
; 2196	     * BaseType_t.  Please read Richard Barry's reply in the following link to a
; 2197	     * post in the FreeRTOS support forum before reporting this as a bug! -
; 2198	     * https://goo.gl/wu4acr */
; 2199	
; 2200	    /* portSOFTWARE_BARRIER() is only implemented for emulated/simulated ports that
; 2201	     * do not otherwise exhibit real time behaviour. */
; 2202	    portSOFTWARE_BARRIER();
; 2203	
; 2204	    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
; 2205	     * is used to allow calls to vTaskSuspendAll() to nest. */
; 2206	    ++uxSchedulerSuspended;
.LINE 2206

	LD	BC,(_uxSchedulerSuspended)
	INC	BC
	LD	(_uxSchedulerSuspended),BC
; 2207	
; 2208	    /* Enforces ordering for ports and optimised compilers that may otherwise place
; 2209	     * the above increment elsewhere. */
; 2210	    portMEMORY_BARRIER();
; 2211	}
.LINE 2211

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vTaskSuspendAll ***************************
;Name                         Addr/Register   Size   Type
;_uxSchedulerSuspended               STATIC      3   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vTaskSuspendAll",2211,"_vTaskSuspendAll"
; 2212	/*----------------------------------------------------------*/
; 2213	
; 2214	#if ( configUSE_TICKLESS_IDLE != 0 )
; 2215	
; 2216	    static TickType_t prvGetExpectedIdleTime( void )
; 2217	    {
; 2218	        TickType_t xReturn;
; 2219	        UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
; 2220	
; 2221	        /* uxHigherPriorityReadyTasks takes care of the case where
; 2222	         * configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
; 2223	         * task that are in the Ready state, even though the idle task is
; 2224	         * running. */
; 2225	        #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
; 2226	        {
; 2227	            if( uxTopReadyPriority > tskIDLE_PRIORITY )
; 2228	            {
; 2229	                uxHigherPriorityReadyTasks = pdTRUE;
; 2230	            }
; 2231	        }
; 2232	        #else
; 2233	        {
; 2234	            const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
; 2235	
; 2236	            /* When port optimised task selection is used the uxTopReadyPriority
; 2237	             * variable is used as a bit map.  If bits other than the least
; 2238	             * significant bit are set then there are tasks that have a priority
; 2239	             * above the idle priority that are in the Ready state.  This takes
; 2240	             * care of the case where the co-operative scheduler is in use. */
; 2241	            if( uxTopReadyPriority > uxLeastSignificantBit )
; 2242	            {
; 2243	                uxHigherPriorityReadyTasks = pdTRUE;
; 2244	            }
; 2245	        }
; 2246	        #endif /* if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 ) */
; 2247	
; 2248	        if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
; 2249	        {
; 2250	            xReturn = 0;
; 2251	        }
; 2252	        else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
; 2253	        {
; 2254	            /* There are other idle priority tasks in the ready state.  If
; 2255	             * time slicing is used then the very next tick interrupt must be
; 2256	             * processed. */
; 2257	            xReturn = 0;
; 2258	        }
; 2259	        else if( uxHigherPriorityReadyTasks != pdFALSE )
; 2260	        {
; 2261	            /* There are tasks in the Ready state that have a priority above the
; 2262	             * idle priority.  This path can only be reached if
; 2263	             * configUSE_PREEMPTION is 0. */
; 2264	            xReturn = 0;
; 2265	        }
; 2266	        else
; 2267	        {
; 2268	            xReturn = xNextTaskUnblockTime - xTickCount;
; 2269	        }
; 2270	
; 2271	        return xReturn;
; 2272	    }
; 2273	
; 2274	#endif /* configUSE_TICKLESS_IDLE */
; 2275	/*----------------------------------------------------------*/
; 2276	
; 2277	BaseType_t xTaskResumeAll( void )
; 2278	{
_xTaskResumeAll:
.DEFINE "_xTaskResumeAll"

.VALUE _xTaskResumeAll

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xTaskResumeAll",2278,"_xTaskResumeAll"

.LINE 2278

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxList"

.CLASS 65

.VALUE -6

.TAG "xLIST"

.TYPE 40

.ENDEF

.DEFINE "pxList"

.CLASS 65

.VALUE -9

.TAG "xLIST"

.TYPE 40

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -12

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

.DEFINE "xPendedCounts"

.CLASS 65

.VALUE -16

.TYPE 15

.ENDEF

.DEFINE "xAlreadyYielded"

.CLASS 65

.VALUE -19

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEA
	LD	SP,HL
; 2279	    TCB_t * pxTCB = NULL;
.LINE 2279

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 2280	    BaseType_t xAlreadyYielded = pdFALSE;
.LINE 2280

	LD	BC,0
	LD	(IX+%FFFFFFED),BC
; 2281	
; 2282	    /* If uxSchedulerSuspended is zero then this function does not match a
; 2283	     * previous call to vTaskSuspendAll(). */
; 2284	    configASSERT( uxSchedulerSuspended );
; 2285	
; 2286	    /* It is possible that an ISR caused a task to be removed from an event
; 2287	     * list while the scheduler was suspended.  If this was the case then the
; 2288	     * removed task will have been added to the xPendingReadyList.  Once the
; 2289	     * scheduler has been resumed it is safe to move all the pending ready
; 2290	     * tasks from this list into their appropriate ready list. */
; 2291	    taskENTER_CRITICAL();
.LINE 2291

	 di
; 2292	    {
; 2293	        --uxSchedulerSuspended;
.LINE 2293

	LD	IY,(_uxSchedulerSuspended)
	LEA	BC,IY+%FFFFFFFF
	LD	(_uxSchedulerSuspended),BC
; 2294	
; 2295	        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
.LINE 2295

	LD	HL,(_uxSchedulerSuspended)
	CALL	__icmpzero
	JR	NZ,L_269
; 2296	        {
; 2297	            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
.LINE 2297

	LD	BC,(_uxCurrentNumberOfTasks)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_270
; 2298	            {
; 2299	                /* Move any readied tasks from the pending list into the
; 2300	                 * appropriate ready list. */
; 2301	                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
L_251:
.LINE 2301

	LD	HL,(_xPendingReadyList)
	CALL	__icmpzero
	JR	NZ,L_238
	LD	BC,1
	LD	(IX+%FFFFFFEA),BC
	JR	L_239
L_238:
	LD	BC,0
	LD	(IX+%FFFFFFEA),BC
L_239:
	LD	HL,(IX+%FFFFFFEA)
	CALL	__icmpzero
	JR	NZ,L_254
; 2302	                {
; 2303	                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
.LINE 2303

	LD	IY,(_xPendingReadyList+10)
	LD	BC,(IY+%A)
	LD	(IX+%FFFFFFFD),BC
; 2304	                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
.LINE 2304

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%20)
	LD	(IX+%FFFFFFFA),BC
	LD	BC,(IY+%17)
	LD	DE,(IY+%1A)
	LD	IY,BC
	LD	(IY+%7),DE
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%1A)
	LD	DE,(IY+%17)
	LD	IY,BC
	LD	(IY+%4),DE
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%3)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%13
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_241
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%1A)
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%3),BC
L_241:
	LD	BC,0
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%20),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%0)
	LD	IY,(IY+%0)
	LEA	BC,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%0),BC
; 2305	                    portMEMORY_BARRIER();
; 2306	                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
.LINE 2306

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%10)
	LD	(IX+%FFFFFFF7),BC
	LD	BC,(IY+%7)
	LD	DE,(IY+%A)
	LD	IY,BC
	LD	(IY+%7),DE
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%A)
	LD	DE,(IY+%7)
	LD	IY,BC
	LD	(IY+%4),DE
	LD	IY,(IX+%FFFFFFF7)
	LD	BC,(IY+%3)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_244
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%A)
	LD	IY,(IX+%FFFFFFF7)
	LD	(IY+%3),BC
L_244:
	LD	BC,0
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%10),BC
	LD	IY,(IX+%FFFFFFF7)
	LD	BC,(IY+%0)
	LD	IY,(IY+%0)
	LEA	BC,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFF7)
	LD	(IY+%0),BC
; 2307	                    prvAddTaskToReadyList( pxTCB );
.LINE 2307

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,(_uxTopReadyPriority)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_247
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	(_uxTopReadyPriority),BC
L_247:
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFF4),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFF4)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%A),BC
	LD	IY,(IX+%FFFFFFF4)
	LD	DE,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,DE
	LD	(IY+%4),BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,(IX+%FFFFFFF4)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	(IY+%10),HL
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,_pxReadyTasksLists
	ADD	HL,DE
	LD	IY,BC
	LD	BC,(IY+%0)
	INC	BC
	LD	IY,HL
	LD	(IY+%0),BC
; 2308	
; 2309	                    /* If the moved task has a priority higher than or equal to
; 2310	                     * the current task then a yield must be performed. */
; 2311	                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
.LINE 2311

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IY+%23)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	OR	A,A
	SBC	HL,BC
	JR	C,L_251
; 2312	                    {
; 2313	                        xYieldPending = pdTRUE;
.LINE 2313

	LD	BC,1
	LD	(_xYieldPending),BC
; 2314	                    }
; 2315	                    else
.LINE 2315

	JR	L_251
; 2316	                    {
; 2317	                        mtCOVERAGE_TEST_MARKER();
; 2318	                    }
; 2319	                }
.LINE 2319

L_254:
; 2320	
; 2321	                if( pxTCB != NULL )
.LINE 2321

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	Z,L_263
; 2322	                {
; 2323	                    /* A task was unblocked while the scheduler was suspended,
; 2324	                     * which may have prevented the next unblock time from being
; 2325	                     * re-calculated, in which case re-calculate it now.  Mainly
; 2326	                     * important for low power tickless implementations, where
; 2327	                     * this can prevent an unnecessary exit from low power
; 2328	                     * state. */
; 2329	                    prvResetNextTaskUnblockTime();
.LINE 2329

	CALL	_prvResetNextTaskUnblockTime
; 2330	                }
L_263:
.LINE 2330

; 2331	
; 2332	                /* If any ticks occurred while the scheduler was suspended then
; 2333	                 * they should be processed now.  This ensures the tick count does
; 2334	                 * not  slip, and that any delayed tasks are resumed at the correct
; 2335	                 * time. */
; 2336	                {
; 2337	                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
.LINE 2337

	LD	BC,(_xPendedTicks)
	LD	A,(_xPendedTicks+3)
	LD	(IX+%FFFFFFF0),BC
	LD	(IX+%FFFFFFF3),A
; 2338	
; 2339	                    if( xPendedCounts > ( TickType_t ) 0U )
.LINE 2339

	OR	A,A
	SBC	HL,HL
	LD	E,%0
	LD	BC,(IX+%FFFFFFF0)
	LD	A,(IX+%FFFFFFF3)
	CALL	__lcmpu
	JR	NC,L_262
; 2340	                    {
; 2341	                        do
L_258:
.LINE 2341

; 2342	                        {
; 2343	                            if( xTaskIncrementTick() != pdFALSE )
.LINE 2343

	CALL	_xTaskIncrementTick
	CALL	__icmpzero
	JR	Z,L_256
; 2344	                            {
; 2345	                                xYieldPending = pdTRUE;
.LINE 2345

	LD	BC,1
	LD	(_xYieldPending),BC
; 2346	                            }
; 2347	                            else
L_256:
.LINE 2347

; 2348	                            {
; 2349	                                mtCOVERAGE_TEST_MARKER();
; 2350	                            }
; 2351	
; 2352	                            --xPendedCounts;
.LINE 2352

	LD	HL,(IX+%FFFFFFF0)
	LD	E,(IX+%FFFFFFF3)
	LD	BC,1
	XOR	A,A
	CALL	__lsub
	LD	(IX+%FFFFFFF0),HL
	LD	(IX+%FFFFFFF3),E
; 2353	                        } while( xPendedCounts > ( TickType_t ) 0U );
.LINE 2353

	OR	A,A
	SBC	HL,HL
	LD	E,%0
	LD	BC,(IX+%FFFFFFF0)
	LD	A,(IX+%FFFFFFF3)
	CALL	__lcmpu
	JR	C,L_258
; 2354	
; 2355	                        xPendedTicks = 0;
.LINE 2355

	LD	BC,0
	XOR	A,A
	LD	(_xPendedTicks),BC
	LD	(_xPendedTicks+3),A
; 2356	                    }
; 2357	                    else
L_262:
.LINE 2357

; 2358	                    {
; 2359	                        mtCOVERAGE_TEST_MARKER();
; 2360	                    }
; 2361	                }
; 2362	
; 2363	                if( xYieldPending != pdFALSE )
.LINE 2363

	LD	HL,(_xYieldPending)
	CALL	__icmpzero
	JR	Z,L_265
; 2364	                {
; 2365	                    #if ( configUSE_PREEMPTION != 0 )
; 2366	                    {
; 2367	                        xAlreadyYielded = pdTRUE;
.LINE 2367

	LD	BC,1
	LD	(IX+%FFFFFFED),BC
; 2368	                    }
; 2369	                    #endif
; 2370	                    taskYIELD_IF_USING_PREEMPTION();
.LINE 2370

	CALL	_vPortYield
; 2371	                }
; 2372	                else
L_265:
.LINE 2372

; 2373	                {
; 2374	                    mtCOVERAGE_TEST_MARKER();
; 2375	                }
; 2376	            }
; 2377	        }
; 2378	        else
L_269:
.LINE 2378

; 2379	        {
; 2380	            mtCOVERAGE_TEST_MARKER();
; 2381	        }
; 2382	    }
L_270:
.LINE 2382

; 2383	    taskEXIT_CRITICAL();
.LINE 2383

	 ei
; 2384	
; 2385	    return xAlreadyYielded;
.LINE 2385

	LD	HL,(IX+%FFFFFFED)
; 2386	}
.LINE 2386

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskResumeAll ***************************
;Name                         Addr/Register   Size   Type
;_vPortYield                         IMPORT  -----   function
;_xTaskIncrementTick                 IMPORT  -----   function
;_xPendedTicks                       STATIC      4   variable
;_prvResetNextTaskUnblockTime        IMPORT  -----   function
;_xYieldPending                      STATIC      3   variable
;_pxCurrentTCB                       STATIC      3   variable
;_pxReadyTasksLists                  STATIC     80   variable
;_uxTopReadyPriority                 STATIC      3   variable
;_xPendingReadyList                  STATIC     16   variable
;_uxCurrentNumberOfTasks             STATIC      3   variable
;_uxSchedulerSuspended               STATIC      3   variable
;temp236                              IX-22      3   variable
;xAlreadyYielded                      IX-19      3   variable
;xPendedCounts                        IX-16      4   variable
;pxIndex                              IX-12      3   variable
;pxList                                IX-9      3   variable
;pxList                                IX-6      3   variable
;pxTCB                                 IX-3      3   variable


; Stack Frame Size: 28 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskResumeAll",2386,"_xTaskResumeAll"
; 2387	/*-----------------------------------------------------------*/
; 2388	
; 2389	TickType_t xTaskGetTickCount( void )
; 2390	{
_xTaskGetTickCount:
.DEFINE "_xTaskGetTickCount"

.VALUE _xTaskGetTickCount

.CLASS 2

.TYPE 79

.ENDEF

.BEGFUNC "xTaskGetTickCount",2390,"_xTaskGetTickCount"

.LINE 2390

.DEFINE "xTicks"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
; 2391	    TickType_t xTicks;
; 2392	
; 2393	    /* Critical section required if running on a 16 bit processor. */
; 2394	    portTICK_TYPE_ENTER_CRITICAL();
.LINE 2394

	 di
; 2395	    {
; 2396	        xTicks = xTickCount;
.LINE 2396

	LD	BC,(_xTickCount)
	LD	A,(_xTickCount+3)
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
; 2397	    }
; 2398	    portTICK_TYPE_EXIT_CRITICAL();
.LINE 2398

	 ei
; 2399	
; 2400	    return xTicks;
.LINE 2400

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
; 2401	}
.LINE 2401

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskGetTickCount ***************************
;Name                         Addr/Register   Size   Type
;_xTickCount                         STATIC      4   variable
;xTicks                                IX-4      4   variable


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskGetTickCount",2401,"_xTaskGetTickCount"
; 2402	/*-----------------------------------------------------------*/
; 2403	
; 2404	TickType_t xTaskGetTickCountFromISR( void )
; 2405	{
_xTaskGetTickCountFromISR:
.DEFINE "_xTaskGetTickCountFromISR"

.VALUE _xTaskGetTickCountFromISR

.CLASS 2

.TYPE 79

.ENDEF

.BEGFUNC "xTaskGetTickCountFromISR",2405,"_xTaskGetTickCountFromISR"

.LINE 2405

.DEFINE "xReturn"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

.DEFINE "uxSavedInterruptStatus"

.CLASS 65

.VALUE -7

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	DEC	SP
; 2406	    TickType_t xReturn;
; 2407	    UBaseType_t uxSavedInterruptStatus;
; 2408	
; 2409	    /* RTOS ports that support interrupt nesting have the concept of a maximum
; 2410	     * system call (or maximum API call) interrupt priority.  Interrupts that are
; 2411	     * above the maximum system call priority are kept permanently enabled, even
; 2412	     * when the RTOS kernel is in a critical section, but cannot make any calls to
; 2413	     * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
; 2414	     * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
; 2415	     * failure if a FreeRTOS API function is called from an interrupt that has been
; 2416	     * assigned a priority above the configured maximum system call priority.
; 2417	     * Only FreeRTOS functions that end in FromISR can be called from interrupts
; 2418	     * that have been assigned a priority at or (logically) below the maximum
; 2419	     * system call  interrupt priority.  FreeRTOS maintains a separate interrupt
; 2420	     * safe API to ensure interrupt entry is as fast and as simple as possible.
; 2421	     * More information (albeit Cortex-M specific) is provided on the following
; 2422	     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
; 2423	    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
; 2424	
; 2425	    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
.LINE 2425

	LD	BC,0
	LD	(IX+%FFFFFFF9),BC
; 2426	    {
; 2427	        xReturn = xTickCount;
.LINE 2427

	LD	BC,(_xTickCount)
	LD	A,(_xTickCount+3)
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
; 2428	    }
; 2429	    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
; 2430	
; 2431	    return xReturn;
.LINE 2431

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
; 2432	}
.LINE 2432

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskGetTickCountFromISR ***************************
;Name                         Addr/Register   Size   Type
;_xTickCount                         STATIC      4   variable
;uxSavedInterruptStatus                IX-7      3   variable
;xReturn                               IX-4      4   variable


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskGetTickCountFromISR",2432,"_xTaskGetTickCountFromISR"
; 2433	/*-----------------------------------------------------------*/
; 2434	
; 2435	UBaseType_t uxTaskGetNumberOfTasks( void )
; 2436	{
_uxTaskGetNumberOfTasks:
.DEFINE "_uxTaskGetNumberOfTasks"

.VALUE _uxTaskGetNumberOfTasks

.CLASS 2

.TYPE 78

.ENDEF

.BEGFUNC "uxTaskGetNumberOfTasks",2436,"_uxTaskGetNumberOfTasks"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 2437	    /* A critical section is not required because the variables are of type
; 2438	     * BaseType_t. */
; 2439	    return uxCurrentNumberOfTasks;
.LINE 2439

	LD	HL,(_uxCurrentNumberOfTasks)
; 2440	}
.LINE 2440

	LD	SP,IX
	POP	IX
	RET	


;**************************** _uxTaskGetNumberOfTasks ***************************
;Name                         Addr/Register   Size   Type
;_uxCurrentNumberOfTasks             STATIC      3   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "uxTaskGetNumberOfTasks",2440,"_uxTaskGetNumberOfTasks"
; 2441	/*-----------------------------------------------------------*/
; 2442	
; 2443	char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
; 2444	{
_pcTaskGetName:
.DEFINE "_pcTaskGetName"

.VALUE _pcTaskGetName

.CLASS 2

.TYPE 322

.ENDEF

.BEGFUNC "pcTaskGetName",2444,"_pcTaskGetName"

.LINE 2444

.DEFINE "xTaskToQuery"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
; 2445	    TCB_t * pxTCB;
; 2446	
; 2447	    /* If null is passed in here then the name of the calling task is being
; 2448	     * queried. */
; 2449	    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
.LINE 2449

	LD	HL,(IX+%6)
	CALL	__icmpzero
	JR	NZ,L_277
	LD	BC,(_pxCurrentTCB)
	LD	(IX+%FFFFFFFD),BC
	JR	L_278
L_277:
	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
L_278:
	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFFA),BC
; 2450	    configASSERT( pxTCB );
; 2451	    return &( pxTCB->pcTaskName[ 0 ] );
.LINE 2451

	LD	IY,(IX+%FFFFFFFA)
	LEA	HL,IY+%29
; 2452	}
.LINE 2452

	LD	SP,IX
	POP	IX
	RET	


;**************************** _pcTaskGetName ***************************
;Name                         Addr/Register   Size   Type
;_pxCurrentTCB                       STATIC      3   variable
;pxTCB                                 IX-6      3   variable
;temp275                               IX-3      3   variable
;xTaskToQuery                          IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "pcTaskGetName",2452,"_pcTaskGetName"
; 2453	/*-----------------------------------------------------------*/
; 2454	
; 2455	#if ( INCLUDE_xTaskGetHandle == 1 )
; 2456	
; 2457	    static TCB_t * prvSearchForNameWithinSingleList( List_t * pxList,
; 2458	                                                     const char pcNameToQuery[] )
; 2459	    {
_prvSearchForNameWithinSingleList:
.DEFINE "_prvSearchForNameWithinSingleList"

.VALUE _prvSearchForNameWithinSingleList

.CLASS 2

.TAG "tskTaskControlBlock"

.TYPE 328

.ENDEF

.BEGFUNC "prvSearchForNameWithinSingleList",2459,"_prvSearchForNameWithinSingleList"

.LINE 2459

.DEFINE "pxList"

.CLASS 65

.VALUE 6

.TAG "xLIST"

.TYPE 40

.ENDEF

.DEFINE "pcNameToQuery"

.CLASS 65

.VALUE 9

.TYPE 194

.ENDEF

.DEFINE "pxConstList"

.CLASS 65

.VALUE -3

.TAG "xLIST"

.TYPE 40

.ENDEF

.DEFINE "pxConstList"

.CLASS 65

.VALUE -6

.TAG "xLIST"

.TYPE 40

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -9

.TYPE 14

.ENDEF

.DEFINE "cNextChar"

.CLASS 65

.VALUE -10

.TYPE 2

.ENDEF

.DEFINE "xBreakLoop"

.CLASS 65

.VALUE -13

.TYPE 4

.ENDEF

.DEFINE "pxNextTCB"

.CLASS 65

.VALUE -16

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxReturn"

.CLASS 65

.VALUE -19

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxFirstTCB"

.CLASS 65

.VALUE -22

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEA
	LD	SP,HL
; 2460	        TCB_t * pxNextTCB;
; 2461	        TCB_t * pxFirstTCB;
; 2462	        TCB_t * pxReturn = NULL;
.LINE 2462

	LD	BC,0
	LD	(IX+%FFFFFFED),BC
; 2463	        UBaseType_t x;
; 2464	        char cNextChar;
; 2465	        BaseType_t xBreakLoop;
; 2466	
; 2467	        /* This function is called with the scheduler suspended. */
; 2468	
; 2469	        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
.LINE 2469

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_300
; 2470	        {
; 2471	            listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
.LINE 2471

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	IY,(IY+%3)
	LD	BC,(IY+%4)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%3),BC
	LD	BC,(IY+%3)
	LEA	HL,IY+%6
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_281
	LD	IY,(IX+%FFFFFFFD)
	LD	IY,(IY+%3)
	LD	BC,(IY+%4)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%3),BC
L_281:
	LD	IY,(IX+%FFFFFFFD)
	LD	IY,(IY+%3)
	LD	BC,(IY+%A)
	LD	(IX+%FFFFFFEA),BC
; 2472	
; 2473	            do
L_297:
.LINE 2473

; 2474	            {
; 2475	                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
.LINE 2475

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFA),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	IY,(IY+%3)
	LD	BC,(IY+%4)
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%3),BC
	LD	BC,(IY+%3)
	LEA	HL,IY+%6
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_283
	LD	IY,(IX+%FFFFFFFA)
	LD	IY,(IY+%3)
	LD	BC,(IY+%4)
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%3),BC
L_283:
	LD	IY,(IX+%FFFFFFFA)
	LD	IY,(IY+%3)
	LD	BC,(IY+%A)
	LD	(IX+%FFFFFFF0),BC
; 2476	
; 2477	                /* Check each character in the name looking for a match or
; 2478	                 * mismatch. */
; 2479	                xBreakLoop = pdFALSE;
.LINE 2479

	LD	BC,0
	LD	(IX+%FFFFFFF3),BC
	JR	L_291
; 2480	
; 2481	                for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
L_292:
.LINE 2481

	LD	BC,16
	LD	HL,(IX+%FFFFFFF7)
	OR	A,A
	SBC	HL,BC
	JR	C,L_294
	JR	L_296
L_291:
	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
	JR	L_292
L_294:
; 2482	                {
; 2483	                    cNextChar = pxNextTCB->pcTaskName[ x ];
.LINE 2483

	LD	BC,(IX+%FFFFFFF7)
	LD	IY,(IX+%FFFFFFF0)
	LEA	HL,IY+%29
	ADD	HL,BC
	LD	A,(HL)
	LD	(IX+%FFFFFFF6),A
; 2484	
; 2485	                    if( cNextChar != pcNameToQuery[ x ] )
.LINE 2485

	LD	BC,(IX+%FFFFFFF7)
	LD	HL,(IX+%9)
	ADD	HL,BC
	LD	A,(HL)
	CP	A,(IX+%FFFFFFF6)
	JR	Z,L_288
; 2486	                    {
; 2487	                        /* Characters didn't match. */
; 2488	                        xBreakLoop = pdTRUE;
.LINE 2488

	LD	BC,1
	LD	(IX+%FFFFFFF3),BC
; 2489	                    }
; 2490	                    else if( cNextChar == ( char ) 0x00 )
.LINE 2490

	JR	L_290
L_288:
	LD	A,(IX+%FFFFFFF6)
	OR	A,A
	JR	NZ,L_286
; 2491	                    {
; 2492	                        /* Both strings terminated, a match must have been
; 2493	                         * found. */
; 2494	                        pxReturn = pxNextTCB;
.LINE 2494

	LD	BC,(IX+%FFFFFFF0)
	LD	(IX+%FFFFFFED),BC
; 2495	                        xBreakLoop = pdTRUE;
.LINE 2495

	LD	BC,1
	LD	(IX+%FFFFFFF3),BC
; 2496	                    }
; 2497	                    else
L_286:
.LINE 2497

; 2498	                    {
; 2499	                        mtCOVERAGE_TEST_MARKER();
; 2500	                    }
L_290:
.LINE 2500

; 2501	
; 2502	                    if( xBreakLoop != pdFALSE )
.LINE 2502

	LD	HL,(IX+%FFFFFFF3)
	CALL	__icmpzero
	JR	NZ,L_296
; 2503	                    {
; 2504	                        break;
.LINE 2504

; 2505	                    }
; 2506	                }
.LINE 2506

	LD	BC,(IX+%FFFFFFF7)
	INC	BC
	LD	(IX+%FFFFFFF7),BC
	JR	L_292
L_296:
; 2507	
; 2508	                if( pxReturn != NULL )
.LINE 2508

	LD	HL,(IX+%FFFFFFED)
	CALL	__icmpzero
	JR	NZ,L_301
; 2509	                {
; 2510	                    /* The handle has been found. */
; 2511	                    break;
.LINE 2511

; 2512	                }
; 2513	            } while( pxNextTCB != pxFirstTCB );
.LINE 2513

	LD	BC,(IX+%FFFFFFEA)
	LD	HL,(IX+%FFFFFFF0)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_297
; 2514	        }
; 2515	        else
L_300:
.LINE 2515

; 2516	        {
; 2517	            mtCOVERAGE_TEST_MARKER();
; 2518	        }
L_301:
.LINE 2518

; 2519	
; 2520	        return pxReturn;
.LINE 2520

	LD	HL,(IX+%FFFFFFED)
; 2521	    }
.LINE 2521

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvSearchForNameWithinSingleList ***************************
;Name                         Addr/Register   Size   Type
;pxFirstTCB                           IX-22      3   variable
;pxReturn                             IX-19      3   variable
;pxNextTCB                            IX-16      3   variable
;xBreakLoop                           IX-13      3   variable
;cNextChar                            IX-10      1   variable
;x                                     IX-9      3   variable
;pxConstList                           IX-6      3   variable
;pxConstList                           IX-3      3   variable
;pcNameToQuery                         IX+9      3   parameter
;pxList                                IX+6      3   parameter


; Stack Frame Size: 34 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvSearchForNameWithinSingleList",2521,"_prvSearchForNameWithinSingleList"
; 2522	
; 2523	#endif /* INCLUDE_xTaskGetHandle */
; 2524	/*-----------------------------------------------------------*/
; 2525	
; 2526	#if ( INCLUDE_xTaskGetHandle == 1 )
; 2527	
; 2528	    TaskHandle_t xTaskGetHandle( const char * pcNameToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
; 2529	    {
_xTaskGetHandle:
.DEFINE "_xTaskGetHandle"

.VALUE _xTaskGetHandle

.CLASS 2

.TAG "tskTaskControlBlock"

.TYPE 328

.ENDEF

.BEGFUNC "xTaskGetHandle",2529,"_xTaskGetHandle"

.LINE 2529

.DEFINE "pcNameToQuery"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "uxQueue"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
; 2530	        UBaseType_t uxQueue = configMAX_PRIORITIES;
.LINE 2530

	LD	BC,5
	LD	(IX+%FFFFFFFA),BC
; 2531	        TCB_t * pxTCB;
; 2532	
; 2533	        /* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
; 2534	        configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
; 2535	
; 2536	        vTaskSuspendAll();
.LINE 2536

	CALL	_vTaskSuspendAll
; 2537	        {
; 2538	            /* Search the ready lists. */
; 2539	            do
L_305:
.LINE 2539

; 2540	            {
; 2541	                uxQueue--;
.LINE 2541

	LD	IY,(IX+%FFFFFFFA)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFFA),IY
; 2542	                pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );
.LINE 2542

	LD	BC,(IX+%6)
	PUSH	BC
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	PUSH	HL
	CALL	_prvSearchForNameWithinSingleList
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 2543	
; 2544	                if( pxTCB != NULL )
.LINE 2544

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	NZ,L_308
; 2545	                {
; 2546	                    /* Found the handle. */
; 2547	                    break;
.LINE 2547

; 2548	                }
; 2549	            } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
.LINE 2549

	LD	BC,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	C,L_305
L_308:
; 2550	
; 2551	            /* Search the delayed lists. */
; 2552	            if( pxTCB == NULL )
.LINE 2552

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	NZ,L_310
; 2553	            {
; 2554	                pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
.LINE 2554

	LD	BC,(IX+%6)
	PUSH	BC
	LD	BC,(_pxDelayedTaskList)
	PUSH	BC
	CALL	_prvSearchForNameWithinSingleList
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 2555	            }
L_310:
.LINE 2555

; 2556	
; 2557	            if( pxTCB == NULL )
.LINE 2557

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	NZ,L_312
; 2558	            {
; 2559	                pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
.LINE 2559

	LD	BC,(IX+%6)
	PUSH	BC
	LD	BC,(_pxOverflowDelayedTaskList)
	PUSH	BC
	CALL	_prvSearchForNameWithinSingleList
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 2560	            }
L_312:
.LINE 2560

; 2561	
; 2562	            #if ( INCLUDE_vTaskSuspend == 1 )
; 2563	            {
; 2564	                if( pxTCB == NULL )
.LINE 2564

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	NZ,L_314
; 2565	                {
; 2566	                    /* Search the suspended list. */
; 2567	                    pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
.LINE 2567

	LD	BC,(IX+%6)
	PUSH	BC
	LD	BC,_xSuspendedTaskList
	PUSH	BC
	CALL	_prvSearchForNameWithinSingleList
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 2568	                }
; 2569	            }
L_314:
.LINE 2569

; 2570	            #endif
; 2571	
; 2572	            #if ( INCLUDE_vTaskDelete == 1 )
; 2573	            {
; 2574	                if( pxTCB == NULL )
.LINE 2574

	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	NZ,L_315
; 2575	                {
; 2576	                    /* Search the deleted list. */
; 2577	                    pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
.LINE 2577

	LD	BC,(IX+%6)
	PUSH	BC
	LD	BC,_xTasksWaitingTermination
	PUSH	BC
	CALL	_prvSearchForNameWithinSingleList
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 2578	                }
; 2579	            }
; 2580	            #endif
; 2581	        }
L_315:
.LINE 2581

; 2582	        ( void ) xTaskResumeAll();
.LINE 2582

	CALL	_xTaskResumeAll
; 2583	
; 2584	        return pxTCB;
.LINE 2584

	LD	HL,(IX+%FFFFFFFD)
; 2585	    }
.LINE 2585

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskGetHandle ***************************
;Name                         Addr/Register   Size   Type
;_xTaskResumeAll                     IMPORT  -----   function
;_xTasksWaitingTermination           STATIC     16   variable
;_xSuspendedTaskList                 STATIC     16   variable
;_pxOverflowDelayedTaskList          STATIC      3   variable
;_pxDelayedTaskList                  STATIC      3   variable
;_pxReadyTasksLists                  STATIC     80   variable
;_prvSearchForNameWithinSingleList      IMPORT  -----   function
;_vTaskSuspendAll                    IMPORT  -----   function
;uxQueue                               IX-6      3   variable
;pxTCB                                 IX-3      3   variable
;pcNameToQuery                         IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskGetHandle",2585,"_xTaskGetHandle"
; 2586	
; 2587	#endif /* INCLUDE_xTaskGetHandle */
; 2588	/*-----------------------------------------------------------*/
; 2589	
; 2590	#if ( configUSE_TRACE_FACILITY == 1 )
; 2591	
; 2592	    UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,
; 2593	                                      const UBaseType_t uxArraySize,
; 2594	                                      configRUN_TIME_COUNTER_TYPE * const pulTotalRunTime )
; 2595	    {
; 2596	        UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
; 2597	
; 2598	        vTaskSuspendAll();
; 2599	        {
; 2600	            /* Is there a space in the array for each task in the system? */
; 2601	            if( uxArraySize >= uxCurrentNumberOfTasks )
; 2602	            {
; 2603	                /* Fill in an TaskStatus_t structure with information on each
; 2604	                 * task in the Ready state. */
; 2605	                do
; 2606	                {
; 2607	                    uxQueue--;
; 2608	                    uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
; 2609	                } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
; 2610	
; 2611	                /* Fill in an TaskStatus_t structure with information on each
; 2612	                 * task in the Blocked state. */
; 2613	                uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
; 2614	                uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
; 2615	
; 2616	                #if ( INCLUDE_vTaskDelete == 1 )
; 2617	                {
; 2618	                    /* Fill in an TaskStatus_t structure with information on
; 2619	                     * each task that has been deleted but not yet cleaned up. */
; 2620	                    uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
; 2621	                }
; 2622	                #endif
; 2623	
; 2624	                #if ( INCLUDE_vTaskSuspend == 1 )
; 2625	                {
; 2626	                    /* Fill in an TaskStatus_t structure with information on
; 2627	                     * each task in the Suspended state. */
; 2628	                    uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
; 2629	                }
; 2630	                #endif
; 2631	
; 2632	                #if ( configGENERATE_RUN_TIME_STATS == 1 )
; 2633	                {
; 2634	                    if( pulTotalRunTime != NULL )
; 2635	                    {
; 2636	                        #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
; 2637	                            portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
; 2638	                        #else
; 2639	                            *pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
; 2640	                        #endif
; 2641	                    }
; 2642	                }
; 2643	                #else /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
; 2644	                {
; 2645	                    if( pulTotalRunTime != NULL )
; 2646	                    {
; 2647	                        *pulTotalRunTime = 0;
; 2648	                    }
; 2649	                }
; 2650	                #endif /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
; 2651	            }
; 2652	            else
; 2653	            {
; 2654	                mtCOVERAGE_TEST_MARKER();
; 2655	            }
; 2656	        }
; 2657	        ( void ) xTaskResumeAll();
; 2658	
; 2659	        return uxTask;
; 2660	    }
; 2661	
; 2662	#endif /* configUSE_TRACE_FACILITY */
; 2663	/*----------------------------------------------------------*/
; 2664	
; 2665	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
; 2666	
; 2667	    TaskHandle_t xTaskGetIdleTaskHandle( void )
; 2668	    {
_xTaskGetIdleTaskHandle:
.DEFINE "_xTaskGetIdleTaskHandle"

.VALUE _xTaskGetIdleTaskHandle

.CLASS 2

.TAG "tskTaskControlBlock"

.TYPE 328

.ENDEF

.BEGFUNC "xTaskGetIdleTaskHandle",2668,"_xTaskGetIdleTaskHandle"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 2669	        /* If xTaskGetIdleTaskHandle() is called before the scheduler has been
; 2670	         * started, then xIdleTaskHandle will be NULL. */
; 2671	        configASSERT( ( xIdleTaskHandle != NULL ) );
; 2672	        return xIdleTaskHandle;
.LINE 2672

	LD	HL,(_xIdleTaskHandle)
; 2673	    }
.LINE 2673

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskGetIdleTaskHandle ***************************
;Name                         Addr/Register   Size   Type
;_xIdleTaskHandle                    STATIC      3   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskGetIdleTaskHandle",2673,"_xTaskGetIdleTaskHandle"
; 2674	
; 2675	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
; 2676	/*----------------------------------------------------------*/
; 2677	
; 2678	/* This conditional compilation should use inequality to 0, not equality to 1.
; 2679	 * This is to ensure vTaskStepTick() is available when user defined low power mode
; 2680	 * implementations require configUSE_TICKLESS_IDLE to be set to a value other than
; 2681	 * 1. */
; 2682	#if ( configUSE_TICKLESS_IDLE != 0 )
; 2683	
; 2684	    void vTaskStepTick( TickType_t xTicksToJump )
; 2685	    {
; 2686	        /* Correct the tick count value after a period during which the tick
; 2687	         * was suppressed.  Note this does *not* call the tick hook function for
; 2688	         * each stepped tick. */
; 2689	        configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
; 2690	
; 2691	        if( ( xTickCount + xTicksToJump ) == xNextTaskUnblockTime )
; 2692	        {
; 2693	            /* Arrange for xTickCount to reach xNextTaskUnblockTime in
; 2694	             * xTaskIncrementTick() when the scheduler resumes.  This ensures
; 2695	             * that any delayed tasks are resumed at the correct time. */
; 2696	            configASSERT( uxSchedulerSuspended );
; 2697	            configASSERT( xTicksToJump != ( TickType_t ) 0 );
; 2698	
; 2699	            /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
; 2700	            taskENTER_CRITICAL();
; 2701	            {
; 2702	                xPendedTicks++;
; 2703	            }
; 2704	            taskEXIT_CRITICAL();
; 2705	            xTicksToJump--;
; 2706	        }
; 2707	        else
; 2708	        {
; 2709	            mtCOVERAGE_TEST_MARKER();
; 2710	        }
; 2711	
; 2712	        xTickCount += xTicksToJump;
; 2713	        traceINCREASE_TICK_COUNT( xTicksToJump );
; 2714	    }
; 2715	
; 2716	#endif /* configUSE_TICKLESS_IDLE */
; 2717	/*----------------------------------------------------------*/
; 2718	
; 2719	BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
; 2720	{
_xTaskCatchUpTicks:
.DEFINE "_xTaskCatchUpTicks"

.VALUE _xTaskCatchUpTicks

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xTaskCatchUpTicks",2720,"_xTaskCatchUpTicks"

.LINE 2720

.DEFINE "xTicksToCatchUp"

.CLASS 65

.VALUE 6

.TYPE 15

.ENDEF

.DEFINE "xYieldOccurred"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
; 2721	    BaseType_t xYieldOccurred;
; 2722	
; 2723	    /* Must not be called with the scheduler suspended as the implementation
; 2724	     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
; 2725	    configASSERT( uxSchedulerSuspended == 0 );
; 2726	
; 2727	    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
; 2728	     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
; 2729	    vTaskSuspendAll();
.LINE 2729

	CALL	_vTaskSuspendAll
; 2730	
; 2731	    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
; 2732	    taskENTER_CRITICAL();
.LINE 2732

	 di
; 2733	    {
; 2734	        xPendedTicks += xTicksToCatchUp;
.LINE 2734

	LD	HL,(_xPendedTicks)
	LD	A,(_xPendedTicks+3)
	LD	E,A
	LD	BC,(IX+%6)
	LD	A,(IX+%9)
	CALL	__ladd
	LD	(_xPendedTicks),HL
	LD	A,E
	LD	(_xPendedTicks+3),A
; 2735	    }
; 2736	    taskEXIT_CRITICAL();
.LINE 2736

	 ei
; 2737	    xYieldOccurred = xTaskResumeAll();
.LINE 2737

	CALL	_xTaskResumeAll
	LD	(IX+%FFFFFFFD),HL
; 2738	
; 2739	    return xYieldOccurred;
.LINE 2739

	LD	HL,(IX+%FFFFFFFD)
; 2740	}
.LINE 2740

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskCatchUpTicks ***************************
;Name                         Addr/Register   Size   Type
;_xTaskResumeAll                     IMPORT  -----   function
;_xPendedTicks                       STATIC      4   variable
;_vTaskSuspendAll                    IMPORT  -----   function
;xYieldOccurred                        IX-3      3   variable
;xTicksToCatchUp                       IX+6      4   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskCatchUpTicks",2740,"_xTaskCatchUpTicks"
; 2741	/*----------------------------------------------------------*/
; 2742	
; 2743	#if ( INCLUDE_xTaskAbortDelay == 1 )
; 2744	
; 2745	    BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
; 2746	    {
_xTaskAbortDelay:
.DEFINE "_xTaskAbortDelay"

.VALUE _xTaskAbortDelay

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xTaskAbortDelay",2746,"_xTaskAbortDelay"

.LINE 2746

.DEFINE "xTask"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -6

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -9

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
; 2747	        TCB_t * pxTCB = xTask;
.LINE 2747

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 2748	        BaseType_t xReturn;
; 2749	
; 2750	        configASSERT( pxTCB );
; 2751	
; 2752	        vTaskSuspendAll();
.LINE 2752

	CALL	_vTaskSuspendAll
; 2753	        {
; 2754	            /* A task can only be prematurely removed from the Blocked state if
; 2755	             * it is actually in the Blocked state. */
; 2756	            if( eTaskGetState( xTask ) == eBlocked )
.LINE 2756

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_eTaskGetState
	POP	BC
	LD	BC,2
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_328
; 2757	            {
; 2758	                xReturn = pdPASS;
.LINE 2758

	LD	BC,1
	LD	(IX+%FFFFFFF7),BC
; 2759	
; 2760	                /* Remove the reference to the task from the blocked list.  An
; 2761	                 * interrupt won't touch the xStateListItem because the
; 2762	                 * scheduler is suspended. */
; 2763	                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
.LINE 2763

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%3
	CALL	_uxListRemove
	POP	BC
; 2764	
; 2765	                /* Is the task waiting on an event also?  If so remove it from
; 2766	                 * the event list too.  Interrupts can touch the event list item,
; 2767	                 * even though the scheduler is suspended, so a critical section
; 2768	                 * is used. */
; 2769	                taskENTER_CRITICAL();
.LINE 2769

	 di
; 2770	                {
; 2771	                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
.LINE 2771

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%20)
	CALL	__icmpzero
	JR	Z,L_320
; 2772	                    {
; 2773	                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
.LINE 2773

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%13
	CALL	_uxListRemove
	POP	BC
; 2774	
; 2775	                        /* This lets the task know it was forcibly removed from the
; 2776	                         * blocked state so it should not re-evaluate its block time and
; 2777	                         * then block again. */
; 2778	                        pxTCB->ucDelayAborted = pdTRUE;
.LINE 2778

	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%44),%1
; 2779	                    }
; 2780	                    else
L_320:
.LINE 2780

; 2781	                    {
; 2782	                        mtCOVERAGE_TEST_MARKER();
; 2783	                    }
; 2784	                }
; 2785	                taskEXIT_CRITICAL();
.LINE 2785

	 ei
; 2786	
; 2787	                /* Place the unblocked task into the appropriate ready list. */
; 2788	                prvAddTaskToReadyList( pxTCB );
.LINE 2788

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,(_uxTopReadyPriority)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_323
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	(_uxTopReadyPriority),BC
L_323:
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFFA),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%A),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	DE,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,DE
	LD	(IY+%4),BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	(IY+%10),HL
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,_pxReadyTasksLists
	ADD	HL,DE
	LD	IY,BC
	LD	BC,(IY+%0)
	INC	BC
	LD	IY,HL
	LD	(IY+%0),BC
; 2789	
; 2790	                /* A task being unblocked cannot cause an immediate context
; 2791	                 * switch if preemption is turned off. */
; 2792	                #if ( configUSE_PREEMPTION == 1 )
; 2793	                {
; 2794	                    /* Preemption is on, but a context switch should only be
; 2795	                     * performed if the unblocked task has a priority that is
; 2796	                     * higher than the currently executing task. */
; 2797	                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
.LINE 2797

	LD	DE,(_pxCurrentTCB)
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	IY,DE
	LD	HL,(IY+%23)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_329
; 2798	                    {
; 2799	                        /* Pend the yield to be performed when the scheduler
; 2800	                         * is unsuspended. */
; 2801	                        xYieldPending = pdTRUE;
.LINE 2801

	LD	BC,1
	LD	(_xYieldPending),BC
; 2802	                    }
; 2803	                    else
.LINE 2803

	JR	L_329
; 2804	                    {
; 2805	                        mtCOVERAGE_TEST_MARKER();
; 2806	                    }
; 2807	                }
; 2808	                #endif /* configUSE_PREEMPTION */
; 2809	            }
; 2810	            else
.LINE 2810

L_328:
; 2811	            {
; 2812	                xReturn = pdFAIL;
.LINE 2812

	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
; 2813	            }
; 2814	        }
L_329:
.LINE 2814

; 2815	        ( void ) xTaskResumeAll();
.LINE 2815

	CALL	_xTaskResumeAll
; 2816	
; 2817	        return xReturn;
.LINE 2817

	LD	HL,(IX+%FFFFFFF7)
; 2818	    }
.LINE 2818

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskAbortDelay ***************************
;Name                         Addr/Register   Size   Type
;_xTaskResumeAll                     IMPORT  -----   function
;_xYieldPending                      STATIC      3   variable
;_pxCurrentTCB                       STATIC      3   variable
;_pxReadyTasksLists                  STATIC     80   variable
;_uxTopReadyPriority                 STATIC      3   variable
;_uxListRemove                       IMPORT  -----   function
;_eTaskGetState                      IMPORT  -----   function
;_vTaskSuspendAll                    IMPORT  -----   function
;xReturn                               IX-9      3   variable
;pxIndex                               IX-6      3   variable
;pxTCB                                 IX-3      3   variable
;xTask                                 IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskAbortDelay",2818,"_xTaskAbortDelay"
; 2819	
; 2820	#endif /* INCLUDE_xTaskAbortDelay */
; 2821	/*----------------------------------------------------------*/
; 2822	
; 2823	BaseType_t xTaskIncrementTick( void )
; 2824	{
_xTaskIncrementTick:
.DEFINE "_xTaskIncrementTick"

.VALUE _xTaskIncrementTick

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xTaskIncrementTick",2824,"_xTaskIncrementTick"

.LINE 2824

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxList"

.CLASS 65

.VALUE -6

.TAG "xLIST"

.TYPE 40

.ENDEF

.DEFINE "pxList"

.CLASS 65

.VALUE -9

.TAG "xLIST"

.TYPE 40

.ENDEF

.DEFINE "xSwitchRequired"

.CLASS 65

.VALUE -12

.TYPE 4

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -15

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

.DEFINE "xConstTickCount"

.CLASS 65

.VALUE -19

.TYPE 15

.ENDEF

.DEFINE "xItemValue"

.CLASS 65

.VALUE -26

.TYPE 15

.ENDEF

.DEFINE "pxTemp"

.CLASS 65

.VALUE -29

.TAG "xLIST"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE3
	LD	SP,HL
; 2825	    TCB_t * pxTCB;
; 2826	    TickType_t xItemValue;
; 2827	    BaseType_t xSwitchRequired = pdFALSE;
.LINE 2827

	LD	BC,0
	LD	(IX+%FFFFFFF4),BC
; 2828	
; 2829	    /* Called by the portable layer each time a tick interrupt occurs.
; 2830	     * Increments the tick then checks to see if the new tick value will cause any
; 2831	     * tasks to be unblocked. */
; 2832	    traceTASK_INCREMENT_TICK( xTickCount );
; 2833	
; 2834	    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
.LINE 2834

	LD	HL,(_uxSchedulerSuspended)
	CALL	__icmpzero
	JR	NZ,L_368
; 2835	    {
; 2836	        /* Minor optimisation.  The tick count cannot change in this
; 2837	         * block. */
; 2838	        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
.LINE 2838

	LD	HL,(_xTickCount)
	LD	A,(_xTickCount+3)
	LD	E,A
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFED),HL
	LD	(IX+%FFFFFFF0),E
; 2839	
; 2840	        /* Increment the RTOS tick, switching the delayed and overflowed
; 2841	         * delayed lists if it wraps to 0. */
; 2842	        xTickCount = xConstTickCount;
.LINE 2842

	LD	BC,(IX+%FFFFFFED)
	LD	(_xTickCount),BC
	LD	A,(IX+%FFFFFFF0)
	LD	(_xTickCount+3),A
; 2843	
; 2844	        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
.LINE 2844

	LD	HL,(IX+%FFFFFFED)
	LD	E,(IX+%FFFFFFF0)
	CALL	__lcmpzero
	JR	NZ,L_333
; 2845	        {
; 2846	            taskSWITCH_DELAYED_LISTS();
.LINE 2846

	LD	BC,(_pxDelayedTaskList)
	LD	(IX+%FFFFFFE3),BC
	LD	BC,(_pxOverflowDelayedTaskList)
	LD	(_pxDelayedTaskList),BC
	LD	BC,(IX+%FFFFFFE3)
	LD	(_pxOverflowDelayedTaskList),BC
	LD	BC,(_xNumOfOverflows)
	LD	BC,(_xNumOfOverflows)
	INC	BC
	LD	(_xNumOfOverflows),BC
	CALL	_prvResetNextTaskUnblockTime
; 2847	        }
; 2848	        else
L_333:
.LINE 2848

; 2849	        {
; 2850	            mtCOVERAGE_TEST_MARKER();
; 2851	        }
; 2852	
; 2853	        /* See if this tick has made a timeout expire.  Tasks are stored in
; 2854	         * the  queue in the order of their wake time - meaning once one task
; 2855	         * has been found whose block time has not expired there is no need to
; 2856	         * look any further down the list. */
; 2857	        if( xConstTickCount >= xNextTaskUnblockTime )
.LINE 2857

	LD	HL,(IX+%FFFFFFED)
	LD	E,(IX+%FFFFFFF0)
	LD	BC,(_xNextTaskUnblockTime)
	LD	A,(_xNextTaskUnblockTime+3)
	CALL	__lcmpu
	JR	C,L_363
; 2858	        {
; 2859	            for( ; ; )
L_357:
.LINE 2859

; 2860	            {
; 2861	                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
.LINE 2861

	LD	IY,(_pxDelayedTaskList)
	LD	HL,(IY+%0)
	CALL	__icmpzero
	JR	NZ,L_336
	LD	BC,1
	LD	(IX+%FFFFFFEA),BC
	JR	L_337
L_336:
	LD	BC,0
	LD	(IX+%FFFFFFEA),BC
L_337:
	LD	HL,(IX+%FFFFFFEA)
	CALL	__icmpzero
	JR	Z,L_356
; 2862	                {
; 2863	                    /* The delayed list is empty.  Set xNextTaskUnblockTime
; 2864	                     * to the maximum possible value so it is extremely
; 2865	                     * unlikely that the
; 2866	                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
; 2867	                     * next time through. */
; 2868	                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
.LINE 2868

	LD	BC,16777215
	LD	A,%FF
	LD	(_xNextTaskUnblockTime),BC
	LD	(_xNextTaskUnblockTime+3),A
; 2869	                    break;
.LINE 2869

	JR	L_363
; 2870	                }
; 2871	                else
L_356:
.LINE 2871

; 2872	                {
; 2873	                    /* The delayed list is not empty, get the value of the
; 2874	                     * item at the head of the delayed list.  This is the time
; 2875	                     * at which the task at the head of the delayed list must
; 2876	                     * be removed from the Blocked state. */
; 2877	                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
.LINE 2877

	LD	IY,(_pxDelayedTaskList)
	LD	IY,(IY+%A)
	LD	BC,(IY+%A)
	LD	(IX+%FFFFFFFD),BC
; 2878	                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
.LINE 2878

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%3)
	LD	A,(IY+%6)
	LD	(IX+%FFFFFFE6),BC
	LD	(IX+%FFFFFFE9),A
; 2879	
; 2880	                    if( xConstTickCount < xItemValue )
.LINE 2880

	LD	HL,(IX+%FFFFFFED)
	LD	E,(IX+%FFFFFFF0)
	LD	BC,(IX+%FFFFFFE6)
	LD	A,(IX+%FFFFFFE9)
	CALL	__lcmpu
	JR	NC,L_339
; 2881	                    {
; 2882	                        /* It is not time to unblock this item yet, but the
; 2883	                         * item value is the time at which the task at the head
; 2884	                         * of the blocked list must be removed from the Blocked
; 2885	                         * state -  so record the item value in
; 2886	                         * xNextTaskUnblockTime. */
; 2887	                        xNextTaskUnblockTime = xItemValue;
.LINE 2887

	LD	BC,(IX+%FFFFFFE6)
	LD	(_xNextTaskUnblockTime),BC
	LD	A,(IX+%FFFFFFE9)
	LD	(_xNextTaskUnblockTime+3),A
; 2888	                        break; /*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. */
.LINE 2888

	JR	L_363
; 2889	                    }
; 2890	                    else
L_339:
.LINE 2890

; 2891	                    {
; 2892	                        mtCOVERAGE_TEST_MARKER();
; 2893	                    }
; 2894	
; 2895	                    /* It is time to remove the item from the Blocked state. */
; 2896	                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
.LINE 2896

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%10)
	LD	(IX+%FFFFFFFA),BC
	LD	BC,(IY+%7)
	LD	DE,(IY+%A)
	LD	IY,BC
	LD	(IY+%7),DE
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%A)
	LD	DE,(IY+%7)
	LD	IY,BC
	LD	(IY+%4),DE
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%3)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_341
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%A)
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%3),BC
L_341:
	LD	BC,0
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%10),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%0)
	LD	IY,(IY+%0)
	LEA	BC,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%0),BC
; 2897	
; 2898	                    /* Is the task waiting on an event also?  If so remove
; 2899	                     * it from the event list. */
; 2900	                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
.LINE 2900

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%20)
	CALL	__icmpzero
	JR	Z,L_348
; 2901	                    {
; 2902	                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
.LINE 2902

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%20)
	LD	(IX+%FFFFFFF7),BC
	LD	BC,(IY+%17)
	LD	DE,(IY+%1A)
	LD	IY,BC
	LD	(IY+%7),DE
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%1A)
	LD	DE,(IY+%17)
	LD	IY,BC
	LD	(IY+%4),DE
	LD	IY,(IX+%FFFFFFF7)
	LD	BC,(IY+%3)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%13
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_345
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%1A)
	LD	IY,(IX+%FFFFFFF7)
	LD	(IY+%3),BC
L_345:
	LD	BC,0
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%20),BC
	LD	IY,(IX+%FFFFFFF7)
	LD	BC,(IY+%0)
	LD	IY,(IY+%0)
	LEA	BC,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFF7)
	LD	(IY+%0),BC
; 2903	                    }
; 2904	                    else
L_348:
.LINE 2904

; 2905	                    {
; 2906	                        mtCOVERAGE_TEST_MARKER();
; 2907	                    }
; 2908	
; 2909	                    /* Place the unblocked task into the appropriate ready
; 2910	                     * list. */
; 2911	                    prvAddTaskToReadyList( pxTCB );
.LINE 2911

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,(_uxTopReadyPriority)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_351
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	(_uxTopReadyPriority),BC
L_351:
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFF1),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFF1)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%A),BC
	LD	IY,(IX+%FFFFFFF1)
	LD	DE,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,DE
	LD	(IY+%4),BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,(IX+%FFFFFFF1)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	(IY+%10),HL
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,_pxReadyTasksLists
	ADD	HL,DE
	LD	IY,BC
	LD	BC,(IY+%0)
	INC	BC
	LD	IY,HL
	LD	(IY+%0),BC
; 2912	
; 2913	                    /* A task being unblocked cannot cause an immediate
; 2914	                     * context switch if preemption is turned off. */
; 2915	                    #if ( configUSE_PREEMPTION == 1 )
; 2916	                    {
; 2917	                        /* Preemption is on, but a context switch should
; 2918	                         * only be performed if the unblocked task's
; 2919	                         * priority is higher than the currently executing
; 2920	                         * task.
; 2921	                         * The case of equal priority tasks sharing
; 2922	                         * processing time (which happens when both
; 2923	                         * preemption and time slicing are on) is
; 2924	                         * handled below.*/
; 2925	                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
.LINE 2925

	LD	DE,(_pxCurrentTCB)
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	IY,DE
	LD	HL,(IY+%23)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_357
; 2926	                        {
; 2927	                            xSwitchRequired = pdTRUE;
.LINE 2927

	LD	BC,1
	LD	(IX+%FFFFFFF4),BC
; 2928	                        }
; 2929	                        else
.LINE 2929

; 2930	                        {
; 2931	                            mtCOVERAGE_TEST_MARKER();
; 2932	                        }
; 2933	                    }
; 2934	                    #endif /* configUSE_PREEMPTION */
; 2935	                }
; 2936	            }
.LINE 2936

	JR	L_357
; 2937	        }
L_363:
.LINE 2937

; 2938	
; 2939	        /* Tasks of equal priority to the currently running task will share
; 2940	         * processing time (time slice) if preemption is on, and the application
; 2941	         * writer has not explicitly turned time slicing off. */
; 2942	        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
; 2943	        {
; 2944	            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
.LINE 2944

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	LD	HL,1
	OR	A,A
	SBC	HL,BC
	JR	NC,L_362
; 2945	            {
; 2946	                xSwitchRequired = pdTRUE;
.LINE 2946

	LD	BC,1
	LD	(IX+%FFFFFFF4),BC
; 2947	            }
; 2948	            else
L_362:
.LINE 2948

; 2949	            {
; 2950	                mtCOVERAGE_TEST_MARKER();
; 2951	            }
; 2952	        }
; 2953	        #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
; 2954	
; 2955	        #if ( configUSE_TICK_HOOK == 1 )
; 2956	        {
; 2957	            /* Guard against the tick hook being called when the pended tick
; 2958	             * count is being unwound (when the scheduler is being unlocked). */
; 2959	            if( xPendedTicks == ( TickType_t ) 0 )
; 2960	            {
; 2961	                vApplicationTickHook();
; 2962	            }
; 2963	            else
; 2964	            {
; 2965	                mtCOVERAGE_TEST_MARKER();
; 2966	            }
; 2967	        }
; 2968	        #endif /* configUSE_TICK_HOOK */
; 2969	
; 2970	        #if ( configUSE_PREEMPTION == 1 )
; 2971	        {
; 2972	            if( xYieldPending != pdFALSE )
.LINE 2972

	LD	HL,(_xYieldPending)
	CALL	__icmpzero
	JR	Z,L_369
; 2973	            {
; 2974	                xSwitchRequired = pdTRUE;
.LINE 2974

	LD	BC,1
	LD	(IX+%FFFFFFF4),BC
; 2975	            }
; 2976	            else
.LINE 2976

	JR	L_369
; 2977	            {
; 2978	                mtCOVERAGE_TEST_MARKER();
; 2979	            }
; 2980	        }
; 2981	        #endif /* configUSE_PREEMPTION */
; 2982	    }
; 2983	    else
.LINE 2983

L_368:
; 2984	    {
; 2985	        ++xPendedTicks;
.LINE 2985

	LD	HL,(_xPendedTicks)
	LD	A,(_xPendedTicks+3)
	LD	E,A
	LD	A,%1
	CALL	__ladd_b
	LD	(_xPendedTicks),HL
	LD	A,E
	LD	(_xPendedTicks+3),A
; 2986	
; 2987	        /* The tick hook gets called at regular intervals, even if the
; 2988	         * scheduler is locked. */
; 2989	        #if ( configUSE_TICK_HOOK == 1 )
; 2990	        {
; 2991	            vApplicationTickHook();
; 2992	        }
; 2993	        #endif
; 2994	    }
L_369:
.LINE 2994

; 2995	
; 2996	    return xSwitchRequired;
.LINE 2996

	LD	HL,(IX+%FFFFFFF4)
; 2997	}
.LINE 2997

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskIncrementTick ***************************
;Name                         Addr/Register   Size   Type
;_xPendedTicks                       STATIC      4   variable
;_xYieldPending                      STATIC      3   variable
;_pxCurrentTCB                       STATIC      3   variable
;_pxReadyTasksLists                  STATIC     80   variable
;_uxTopReadyPriority                 STATIC      3   variable
;_xNextTaskUnblockTime               STATIC      4   variable
;_prvResetNextTaskUnblockTime        IMPORT  -----   function
;_xNumOfOverflows                    STATIC      3   variable
;_pxOverflowDelayedTaskList          STATIC      3   variable
;_pxDelayedTaskList                  STATIC      3   variable
;_xTickCount                         STATIC      4   variable
;_uxSchedulerSuspended               STATIC      3   variable
;pxTemp                               IX-29      3   variable
;xItemValue                           IX-26      4   variable
;temp334                              IX-22      3   variable
;xConstTickCount                      IX-19      4   variable
;pxIndex                              IX-15      3   variable
;xSwitchRequired                      IX-12      3   variable
;pxList                                IX-9      3   variable
;pxList                                IX-6      3   variable
;pxTCB                                 IX-3      3   variable


; Stack Frame Size: 35 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskIncrementTick",2997,"_xTaskIncrementTick"
; 2998	/*-----------------------------------------------------------*/
; 2999	
; 3000	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
; 3001	
; 3002	    void vTaskSetApplicationTaskTag( TaskHandle_t xTask,
; 3003	                                     TaskHookFunction_t pxHookFunction )
; 3004	    {
; 3005	        TCB_t * xTCB;
; 3006	
; 3007	        /* If xTask is NULL then it is the task hook of the calling task that is
; 3008	         * getting set. */
; 3009	        if( xTask == NULL )
; 3010	        {
; 3011	            xTCB = ( TCB_t * ) pxCurrentTCB;
; 3012	        }
; 3013	        else
; 3014	        {
; 3015	            xTCB = xTask;
; 3016	        }
; 3017	
; 3018	        /* Save the hook function in the TCB.  A critical section is required as
; 3019	         * the value can be accessed from an interrupt. */
; 3020	        taskENTER_CRITICAL();
; 3021	        {
; 3022	            xTCB->pxTaskTag = pxHookFunction;
; 3023	        }
; 3024	        taskEXIT_CRITICAL();
; 3025	    }
; 3026	
; 3027	#endif /* configUSE_APPLICATION_TASK_TAG */
; 3028	/*-----------------------------------------------------------*/
; 3029	
; 3030	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
; 3031	
; 3032	    TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
; 3033	    {
; 3034	        TCB_t * pxTCB;
; 3035	        TaskHookFunction_t xReturn;
; 3036	
; 3037	        /* If xTask is NULL then set the calling task's hook. */
; 3038	        pxTCB = prvGetTCBFromHandle( xTask );
; 3039	
; 3040	        /* Save the hook function in the TCB.  A critical section is required as
; 3041	         * the value can be accessed from an interrupt. */
; 3042	        taskENTER_CRITICAL();
; 3043	        {
; 3044	            xReturn = pxTCB->pxTaskTag;
; 3045	        }
; 3046	        taskEXIT_CRITICAL();
; 3047	
; 3048	        return xReturn;
; 3049	    }
; 3050	
; 3051	#endif /* configUSE_APPLICATION_TASK_TAG */
; 3052	/*-----------------------------------------------------------*/
; 3053	
; 3054	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
; 3055	
; 3056	    TaskHookFunction_t xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask )
; 3057	    {
; 3058	        TCB_t * pxTCB;
; 3059	        TaskHookFunction_t xReturn;
; 3060	        UBaseType_t uxSavedInterruptStatus;
; 3061	
; 3062	        /* If xTask is NULL then set the calling task's hook. */
; 3063	        pxTCB = prvGetTCBFromHandle( xTask );
; 3064	
; 3065	        /* Save the hook function in the TCB.  A critical section is required as
; 3066	         * the value can be accessed from an interrupt. */
; 3067	        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
; 3068	        {
; 3069	            xReturn = pxTCB->pxTaskTag;
; 3070	        }
; 3071	        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
; 3072	
; 3073	        return xReturn;
; 3074	    }
; 3075	
; 3076	#endif /* configUSE_APPLICATION_TASK_TAG */
; 3077	/*-----------------------------------------------------------*/
; 3078	
; 3079	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
; 3080	
; 3081	    BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask,
; 3082	                                             void * pvParameter )
; 3083	    {
; 3084	        TCB_t * xTCB;
; 3085	        BaseType_t xReturn;
; 3086	
; 3087	        /* If xTask is NULL then we are calling our own task hook. */
; 3088	        if( xTask == NULL )
; 3089	        {
; 3090	            xTCB = pxCurrentTCB;
; 3091	        }
; 3092	        else
; 3093	        {
; 3094	            xTCB = xTask;
; 3095	        }
; 3096	
; 3097	        if( xTCB->pxTaskTag != NULL )
; 3098	        {
; 3099	            xReturn = xTCB->pxTaskTag( pvParameter );
; 3100	        }
; 3101	        else
; 3102	        {
; 3103	            xReturn = pdFAIL;
; 3104	        }
; 3105	
; 3106	        return xReturn;
; 3107	    }
; 3108	
; 3109	#endif /* configUSE_APPLICATION_TASK_TAG */
; 3110	/*-----------------------------------------------------------*/
; 3111	
; 3112	void vTaskSwitchContext( void )
; 3113	{
_vTaskSwitchContext:
.DEFINE "_vTaskSwitchContext"

.VALUE _vTaskSwitchContext

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vTaskSwitchContext",3113,"_vTaskSwitchContext"

.LINE 3113

.DEFINE "pxConstList"

.CLASS 65

.VALUE -3

.TAG "xLIST"

.TYPE 40

.ENDEF

.DEFINE "uxTopPriority"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
; 3114	    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
.LINE 3114

	LD	HL,(_uxSchedulerSuspended)
	CALL	__icmpzero
	JR	Z,L_381
; 3115	    {
; 3116	        /* The scheduler is currently suspended - do not allow a context
; 3117	         * switch. */
; 3118	        xYieldPending = pdTRUE;
.LINE 3118

	LD	BC,1
	LD	(_xYieldPending),BC
; 3119	    }
; 3120	    else
.LINE 3120

	JR	L_382
L_381:
; 3121	    {
; 3122	        xYieldPending = pdFALSE;
.LINE 3122

	LD	BC,0
	LD	(_xYieldPending),BC
; 3123	        traceTASK_SWITCHED_OUT();
; 3124	
; 3125	        #if ( configGENERATE_RUN_TIME_STATS == 1 )
; 3126	        {
; 3127	            #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
; 3128	                portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
; 3129	            #else
; 3130	                ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
; 3131	            #endif
; 3132	
; 3133	            /* Add the amount of time the task has been running to the
; 3134	             * accumulated time so far.  The time the task started running was
; 3135	             * stored in ulTaskSwitchedInTime.  Note that there is no overflow
; 3136	             * protection here so count values are only valid until the timer
; 3137	             * overflows.  The guard against negative values is to protect
; 3138	             * against suspect run time stat counter implementations - which
; 3139	             * are provided by the application, not the kernel. */
; 3140	            if( ulTotalRunTime > ulTaskSwitchedInTime )
; 3141	            {
; 3142	                pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
; 3143	            }
; 3144	            else
; 3145	            {
; 3146	                mtCOVERAGE_TEST_MARKER();
; 3147	            }
; 3148	
; 3149	            ulTaskSwitchedInTime = ulTotalRunTime;
; 3150	        }
; 3151	        #endif /* configGENERATE_RUN_TIME_STATS */
; 3152	
; 3153	        /* Check for stack overflow, if configured. */
; 3154	        taskCHECK_FOR_STACK_OVERFLOW();
; 3155	
; 3156	        /* Before the currently running task is switched out, save its errno. */
; 3157	        #if ( configUSE_POSIX_ERRNO == 1 )
; 3158	        {
; 3159	            pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
; 3160	        }
; 3161	        #endif
; 3162	
; 3163	        /* Select a new task to run using either the generic C or port
; 3164	         * optimised asm code. */
; 3165	        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
.LINE 3165

	LD	BC,(_uxTopReadyPriority)
	LD	(IX+%FFFFFFFA),BC
L_375:
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IY+%0)
	CALL	__icmpzero
	JR	NZ,L_373
	LD	BC,1
	LD	(IX+%FFFFFFF7),BC
	JR	L_374
L_373:
	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
L_374:
	LD	HL,(IX+%FFFFFFF7)
	CALL	__icmpzero
	JR	Z,L_379
	LD	IY,(IX+%FFFFFFFA)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFFA),IY
	JR	L_375
L_379:
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	(IX+%FFFFFFFD),HL
	LD	IY,(IX+%FFFFFFFD)
	LD	IY,(IY+%3)
	LD	BC,(IY+%4)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%3),BC
	LD	BC,(IY+%3)
	LEA	HL,IY+%6
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_378
	LD	IY,(IX+%FFFFFFFD)
	LD	IY,(IY+%3)
	LD	BC,(IY+%4)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%3),BC
L_378:
	LD	IY,(IX+%FFFFFFFD)
	LD	IY,(IY+%3)
	LD	BC,(IY+%A)
	LD	(_pxCurrentTCB),BC
	LD	BC,(IX+%FFFFFFFA)
	LD	(_uxTopReadyPriority),BC
; 3166	        traceTASK_SWITCHED_IN();
; 3167	
; 3168	        /* After the new task is switched in, update the global errno. */
; 3169	        #if ( configUSE_POSIX_ERRNO == 1 )
; 3170	        {
; 3171	            FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
; 3172	        }
; 3173	        #endif
; 3174	
; 3175	        #if ( ( configUSE_NEWLIB_REENTRANT == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 ) )
; 3176	        {
; 3177	            /* Switch C-Runtime's TLS Block to point to the TLS
; 3178	             * Block specific to this task. */
; 3179	            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
; 3180	        }
; 3181	        #endif
; 3182	    }
; 3183	}
L_382:
.LINE 3183

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vTaskSwitchContext ***************************
;Name                         Addr/Register   Size   Type
;_pxCurrentTCB                       STATIC      3   variable
;_pxReadyTasksLists                  STATIC     80   variable
;_uxTopReadyPriority                 STATIC      3   variable
;_xYieldPending                      STATIC      3   variable
;_uxSchedulerSuspended               STATIC      3   variable
;temp371                               IX-9      3   variable
;uxTopPriority                         IX-6      3   variable
;pxConstList                           IX-3      3   variable


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vTaskSwitchContext",3183,"_vTaskSwitchContext"
; 3184	/*-----------------------------------------------------------*/
; 3185	
; 3186	void vTaskPlaceOnEventList( List_t * const pxEventList,
; 3187	                            const TickType_t xTicksToWait )
; 3188	{
_vTaskPlaceOnEventList:
.DEFINE "_vTaskPlaceOnEventList"

.VALUE _vTaskPlaceOnEventList

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vTaskPlaceOnEventList",3188,"_vTaskPlaceOnEventList"

.LINE 3188

.DEFINE "pxEventList"

.CLASS 65

.VALUE 6

.TAG "xLIST"

.TYPE 40

.ENDEF

.DEFINE "xTicksToWait"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 3189	    configASSERT( pxEventList );
; 3190	
; 3191	    /* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
; 3192	     * SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
; 3193	
; 3194	    /* Place the event list item of the TCB in the appropriate event list.
; 3195	     * This is placed in the list in priority order so the highest priority task
; 3196	     * is the first to be woken by the event.
; 3197	     *
; 3198	     * Note: Lists are sorted in ascending order by ListItem_t.xItemValue.
; 3199	     * Normally, the xItemValue of a TCB's ListItem_t members is:
; 3200	     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
; 3201	     * Therefore, the event list is sorted in descending priority order.
; 3202	     *
; 3203	     * The queue that contains the event list is locked, preventing
; 3204	     * simultaneous access from interrupts. */
; 3205	    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
.LINE 3205

	LD	IY,(_pxCurrentTCB)
	PEA	IY+%13
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_vListInsert
	POP	BC
	POP	BC
; 3206	
; 3207	    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
.LINE 3207

	LD	BC,1
	PUSH	BC
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	_prvAddCurrentTaskToDelayedList
	POP	BC
	POP	BC
	POP	BC
; 3208	}
.LINE 3208

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vTaskPlaceOnEventList ***************************
;Name                         Addr/Register   Size   Type
;_prvAddCurrentTaskToDelayedList      IMPORT  -----   function
;_pxCurrentTCB                       STATIC      3   variable
;_vListInsert                        IMPORT  -----   function
;xTicksToWait                          IX+9      4   parameter
;pxEventList                           IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vTaskPlaceOnEventList",3208,"_vTaskPlaceOnEventList"
; 3209	/*-----------------------------------------------------------*/
; 3210	
; 3211	void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
; 3212	                                     const TickType_t xItemValue,
; 3213	                                     const TickType_t xTicksToWait )
; 3214	{
_vTaskPlaceOnUnorderedEventList:
.DEFINE "_vTaskPlaceOnUnorderedEventList"

.VALUE _vTaskPlaceOnUnorderedEventList

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vTaskPlaceOnUnorderedEventList",3214,"_vTaskPlaceOnUnorderedEventList"

.LINE 3214

.DEFINE "pxEventList"

.CLASS 65

.VALUE 6

.TAG "xLIST"

.TYPE 40

.ENDEF

.DEFINE "xItemValue"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "xTicksToWait"

.CLASS 65

.VALUE 15

.TYPE 15

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -3

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
; 3215	    configASSERT( pxEventList );
; 3216	
; 3217	    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
; 3218	     * the event groups implementation. */
; 3219	    configASSERT( uxSchedulerSuspended != 0 );
; 3220	
; 3221	    /* Store the item value in the event list item.  It is safe to access the
; 3222	     * event list item here as interrupts won't access the event list item of a
; 3223	     * task that is not in the Blocked state. */
; 3224	    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
.LINE 3224

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,0
	LD	A,%80
	CALL	__lor
	LD	IY,(_pxCurrentTCB)
	LD	(IY+%13),HL
	LD	(IY+%16),E
; 3225	
; 3226	    /* Place the event list item of the TCB at the end of the appropriate event
; 3227	     * list.  It is safe to access the event list here because it is part of an
; 3228	     * event group implementation - and interrupts don't access event groups
; 3229	     * directly (instead they access them indirectly by pending function calls to
; 3230	     * the task level). */
; 3231	    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
.LINE 3231

	LD	IY,(IX+%6)
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFFD),BC
	LD	IY,(_pxCurrentTCB)
	LD	BC,(IX+%FFFFFFFD)
	LD	(IY+%17),BC
	LD	BC,(_pxCurrentTCB)
	LD	IY,(IX+%FFFFFFFD)
	LD	DE,(IY+%7)
	LD	IY,BC
	LD	(IY+%1A),DE
	LD	BC,(_pxCurrentTCB)
	LD	IY,(IX+%FFFFFFFD)
	LD	DE,(IY+%7)
	LD	IY,BC
	LEA	BC,IY+%13
	LD	IY,DE
	LD	(IY+%4),BC
	LD	IY,(_pxCurrentTCB)
	LEA	BC,IY+%13
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	IY,(_pxCurrentTCB)
	LD	BC,(IX+%6)
	LD	(IY+%20),BC
	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	BC,(IY+%0)
	INC	BC
	LD	(IY+%0),BC
; 3232	
; 3233	    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
.LINE 3233

	LD	BC,1
	PUSH	BC
	LD	C,(IX+%12)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%F)
	PUSH	BC
	CALL	_prvAddCurrentTaskToDelayedList
	POP	BC
	POP	BC
	POP	BC
; 3234	}
.LINE 3234

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vTaskPlaceOnUnorderedEventList ***************************
;Name                         Addr/Register   Size   Type
;_prvAddCurrentTaskToDelayedList      IMPORT  -----   function
;_pxCurrentTCB                       STATIC      3   variable
;pxIndex                               IX-3      3   variable
;xTicksToWait                         IX+15      4   parameter
;xItemValue                            IX+9      4   parameter
;pxEventList                           IX+6      3   parameter


; Stack Frame Size: 24 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vTaskPlaceOnUnorderedEventList",3234,"_vTaskPlaceOnUnorderedEventList"
; 3235	/*-----------------------------------------------------------*/
; 3236	
; 3237	#if ( configUSE_TIMERS == 1 )
; 3238	
; 3239	    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
; 3240	                                          TickType_t xTicksToWait,
; 3241	                                          const BaseType_t xWaitIndefinitely )
; 3242	    {
; 3243	        configASSERT( pxEventList );
; 3244	
; 3245	        /* This function should not be called by application code hence the
; 3246	         * 'Restricted' in its name.  It is not part of the public API.  It is
; 3247	         * designed for use by kernel code, and has special calling requirements -
; 3248	         * it should be called with the scheduler suspended. */
; 3249	
; 3250	
; 3251	        /* Place the event list item of the TCB in the appropriate event list.
; 3252	         * In this case it is assume that this is the only task that is going to
; 3253	         * be waiting on this event list, so the faster vListInsertEnd() function
; 3254	         * can be used in place of vListInsert. */
; 3255	        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
; 3256	
; 3257	        /* If the task should block indefinitely then set the block time to a
; 3258	         * value that will be recognised as an indefinite delay inside the
; 3259	         * prvAddCurrentTaskToDelayedList() function. */
; 3260	        if( xWaitIndefinitely != pdFALSE )
; 3261	        {
; 3262	            xTicksToWait = portMAX_DELAY;
; 3263	        }
; 3264	
; 3265	        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
; 3266	        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
; 3267	    }
; 3268	
; 3269	#endif /* configUSE_TIMERS */
; 3270	/*-----------------------------------------------------------*/
; 3271	
; 3272	BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
; 3273	{
_xTaskRemoveFromEventList:
.DEFINE "_xTaskRemoveFromEventList"

.VALUE _xTaskRemoveFromEventList

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xTaskRemoveFromEventList",3273,"_xTaskRemoveFromEventList"

.LINE 3273

.DEFINE "pxEventList"

.CLASS 65

.VALUE 6

.TAG "xLIST"

.TYPE 200

.ENDEF

.DEFINE "pxUnblockedTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxList"

.CLASS 65

.VALUE -6

.TAG "xLIST"

.TYPE 40

.ENDEF

.DEFINE "pxList"

.CLASS 65

.VALUE -9

.TAG "xLIST"

.TYPE 40

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -12

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -15

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -18

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEE
	LD	SP,HL
; 3274	    TCB_t * pxUnblockedTCB;
; 3275	    BaseType_t xReturn;
; 3276	
; 3277	    /* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
; 3278	     * called from a critical section within an ISR. */
; 3279	
; 3280	    /* The event list is sorted in priority order, so the first in the list can
; 3281	     * be removed as it is known to be the highest priority.  Remove the TCB from
; 3282	     * the delayed list, and add it to the ready list.
; 3283	     *
; 3284	     * If an event is for a queue that is locked then this function will never
; 3285	     * get called - the lock count on the queue will get modified instead.  This
; 3286	     * means exclusive access to the event list is guaranteed here.
; 3287	     *
; 3288	     * This function assumes that a check has already been made to ensure that
; 3289	     * pxEventList is not empty. */
; 3290	    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
.LINE 3290

	LD	IY,(IX+%6)
	LD	IY,(IY+%A)
	LD	BC,(IY+%A)
	LD	(IX+%FFFFFFFD),BC
; 3291	    configASSERT( pxUnblockedTCB );
; 3292	    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
.LINE 3292

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%20)
	LD	(IX+%FFFFFFFA),BC
	LD	BC,(IY+%17)
	LD	DE,(IY+%1A)
	LD	IY,BC
	LD	(IY+%7),DE
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%1A)
	LD	DE,(IY+%17)
	LD	IY,BC
	LD	(IY+%4),DE
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%3)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%13
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_387
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%1A)
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%3),BC
L_387:
	LD	BC,0
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%20),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%0)
	LD	IY,(IY+%0)
	LEA	BC,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%0),BC
; 3293	
; 3294	    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
.LINE 3294

	LD	HL,(_uxSchedulerSuspended)
	CALL	__icmpzero
	JR	NZ,L_397
; 3295	    {
; 3296	        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
.LINE 3296

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%10)
	LD	(IX+%FFFFFFF7),BC
	LD	BC,(IY+%7)
	LD	DE,(IY+%A)
	LD	IY,BC
	LD	(IY+%7),DE
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%A)
	LD	DE,(IY+%7)
	LD	IY,BC
	LD	(IY+%4),DE
	LD	IY,(IX+%FFFFFFF7)
	LD	BC,(IY+%3)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_390
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%A)
	LD	IY,(IX+%FFFFFFF7)
	LD	(IY+%3),BC
L_390:
	LD	BC,0
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%10),BC
	LD	IY,(IX+%FFFFFFF7)
	LD	BC,(IY+%0)
	LD	IY,(IY+%0)
	LEA	BC,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFF7)
	LD	(IY+%0),BC
; 3297	        prvAddTaskToReadyList( pxUnblockedTCB );
.LINE 3297

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,(_uxTopReadyPriority)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_393
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	(_uxTopReadyPriority),BC
L_393:
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFF4),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFF4)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%A),BC
	LD	IY,(IX+%FFFFFFF4)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LEA	DE,IY+%3
	LD	IY,BC
	LD	(IY+%4),DE
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,(IX+%FFFFFFF4)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	(IY+%10),HL
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,_pxReadyTasksLists
	ADD	HL,DE
	LD	IY,BC
	LD	BC,(IY+%0)
	INC	BC
	LD	IY,HL
	LD	(IY+%0),BC
; 3298	
; 3299	        #if ( configUSE_TICKLESS_IDLE != 0 )
; 3300	        {
; 3301	            /* If a task is blocked on a kernel object then xNextTaskUnblockTime
; 3302	             * might be set to the blocked task's time out time.  If the task is
; 3303	             * unblocked for a reason other than a timeout xNextTaskUnblockTime is
; 3304	             * normally left unchanged, because it is automatically reset to a new
; 3305	             * value when the tick count equals xNextTaskUnblockTime.  However if
; 3306	             * tickless idling is used it might be more important to enter sleep mode
; 3307	             * at the earliest possible time - so reset xNextTaskUnblockTime here to
; 3308	             * ensure it is updated at the earliest possible time. */
; 3309	            prvResetNextTaskUnblockTime();
; 3310	        }
; 3311	        #endif
; 3312	    }
; 3313	    else
.LINE 3313

	JR	L_400
L_397:
; 3314	    {
; 3315	        /* The delayed and ready lists cannot be accessed, so hold this task
; 3316	         * pending until the scheduler is resumed. */
; 3317	        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
.LINE 3317

	LD	BC,(_xPendingReadyList+3)
	LD	(IX+%FFFFFFF1),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%17),BC
	LD	IY,(IX+%FFFFFFF1)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%1A),BC
	LD	IY,(IX+%FFFFFFF1)
	LD	DE,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%13
	LD	IY,DE
	LD	(IY+%4),BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%13
	LD	IY,(IX+%FFFFFFF1)
	LD	(IY+%7),BC
	LD	BC,_xPendingReadyList
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%20),BC
	LD	BC,(_xPendingReadyList)
	LD	BC,(_xPendingReadyList)
	INC	BC
	LD	(_xPendingReadyList),BC
; 3318	    }
L_400:
.LINE 3318

; 3319	
; 3320	    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
.LINE 3320

	LD	DE,(_pxCurrentTCB)
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	IY,DE
	LD	HL,(IY+%23)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_399
; 3321	    {
; 3322	        /* Return true if the task removed from the event list has a higher
; 3323	         * priority than the calling task.  This allows the calling task to know if
; 3324	         * it should force a context switch now. */
; 3325	        xReturn = pdTRUE;
.LINE 3325

	LD	BC,1
	LD	(IX+%FFFFFFEE),BC
; 3326	
; 3327	        /* Mark that a yield is pending in case the user is not using the
; 3328	         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
; 3329	        xYieldPending = pdTRUE;
.LINE 3329

	LD	BC,1
	LD	(_xYieldPending),BC
; 3330	    }
; 3331	    else
.LINE 3331

	JR	L_401
L_399:
; 3332	    {
; 3333	        xReturn = pdFALSE;
.LINE 3333

	LD	BC,0
	LD	(IX+%FFFFFFEE),BC
; 3334	    }
L_401:
.LINE 3334

; 3335	
; 3336	    return xReturn;
.LINE 3336

	LD	HL,(IX+%FFFFFFEE)
; 3337	}
.LINE 3337

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskRemoveFromEventList ***************************
;Name                         Addr/Register   Size   Type
;_xYieldPending                      STATIC      3   variable
;_pxCurrentTCB                       STATIC      3   variable
;_xPendingReadyList                  STATIC     16   variable
;_pxReadyTasksLists                  STATIC     80   variable
;_uxTopReadyPriority                 STATIC      3   variable
;_uxSchedulerSuspended               STATIC      3   variable
;xReturn                              IX-18      3   variable
;pxIndex                              IX-15      3   variable
;pxIndex                              IX-12      3   variable
;pxList                                IX-9      3   variable
;pxList                                IX-6      3   variable
;pxUnblockedTCB                        IX-3      3   variable
;pxEventList                           IX+6      3   parameter


; Stack Frame Size: 27 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskRemoveFromEventList",3337,"_xTaskRemoveFromEventList"
; 3338	/*-----------------------------------------------------------*/
; 3339	
; 3340	void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
; 3341	                                        const TickType_t xItemValue )
; 3342	{
_vTaskRemoveFromUnorderedEventList:
.DEFINE "_vTaskRemoveFromUnorderedEventList"

.VALUE _vTaskRemoveFromUnorderedEventList

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vTaskRemoveFromUnorderedEventList",3342,"_vTaskRemoveFromUnorderedEventList"

.LINE 3342

.DEFINE "pxEventListItem"

.CLASS 65

.VALUE 6

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

.DEFINE "xItemValue"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "pxUnblockedTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxList"

.CLASS 65

.VALUE -6

.TAG "xLIST"

.TYPE 40

.ENDEF

.DEFINE "pxList"

.CLASS 65

.VALUE -9

.TAG "xLIST"

.TYPE 40

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -12

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF4
	LD	SP,HL
; 3343	    TCB_t * pxUnblockedTCB;
; 3344	
; 3345	    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
; 3346	     * the event flags implementation. */
; 3347	    configASSERT( uxSchedulerSuspended != pdFALSE );
; 3348	
; 3349	    /* Store the new item value in the event list. */
; 3350	    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
.LINE 3350

	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	LD	BC,0
	LD	A,%80
	CALL	__lor
	LD	IY,(IX+%6)
	LD	(IY+%0),HL
	LD	(IY+%3),E
; 3351	
; 3352	    /* Remove the event list form the event flag.  Interrupts do not access
; 3353	     * event flags. */
; 3354	    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
.LINE 3354

	LD	IY,(IX+%6)
	LD	BC,(IY+%A)
	LD	(IX+%FFFFFFFD),BC
; 3355	    configASSERT( pxUnblockedTCB );
; 3356	    listREMOVE_ITEM( pxEventListItem );
.LINE 3356

	LD	IY,(IX+%6)
	LD	BC,(IY+%D)
	LD	(IX+%FFFFFFFA),BC
	LD	BC,(IY+%4)
	LD	DE,(IY+%7)
	LD	IY,BC
	LD	(IY+%7),DE
	LD	IY,(IX+%6)
	LD	BC,(IY+%7)
	LD	DE,(IY+%4)
	LD	IY,BC
	LD	(IY+%4),DE
	LD	BC,(IX+%6)
	LD	IY,(IX+%FFFFFFFA)
	LD	HL,(IY+%3)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_404
	LD	IY,(IX+%6)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%3),BC
L_404:
	LD	BC,0
	LD	IY,(IX+%6)
	LD	(IY+%D),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%0)
	LD	IY,(IY+%0)
	LEA	BC,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%0),BC
; 3357	
; 3358	    #if ( configUSE_TICKLESS_IDLE != 0 )
; 3359	    {
; 3360	        /* If a task is blocked on a kernel object then xNextTaskUnblockTime
; 3361	         * might be set to the blocked task's time out time.  If the task is
; 3362	         * unblocked for a reason other than a timeout xNextTaskUnblockTime is
; 3363	         * normally left unchanged, because it is automatically reset to a new
; 3364	         * value when the tick count equals xNextTaskUnblockTime.  However if
; 3365	         * tickless idling is used it might be more important to enter sleep mode
; 3366	         * at the earliest possible time - so reset xNextTaskUnblockTime here to
; 3367	         * ensure it is updated at the earliest possible time. */
; 3368	        prvResetNextTaskUnblockTime();
; 3369	    }
; 3370	    #endif
; 3371	
; 3372	    /* Remove the task from the delayed list and add it to the ready list.  The
; 3373	     * scheduler is suspended so interrupts will not be accessing the ready
; 3374	     * lists. */
; 3375	    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
.LINE 3375

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%10)
	LD	(IX+%FFFFFFF7),BC
	LD	BC,(IY+%7)
	LD	DE,(IY+%A)
	LD	IY,BC
	LD	(IY+%7),DE
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%A)
	LD	DE,(IY+%7)
	LD	IY,BC
	LD	(IY+%4),DE
	LD	IY,(IX+%FFFFFFF7)
	LD	BC,(IY+%3)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_407
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%A)
	LD	IY,(IX+%FFFFFFF7)
	LD	(IY+%3),BC
L_407:
	LD	BC,0
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%10),BC
	LD	IY,(IX+%FFFFFFF7)
	LD	BC,(IY+%0)
	LD	IY,(IY+%0)
	LEA	BC,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFF7)
	LD	(IY+%0),BC
; 3376	    prvAddTaskToReadyList( pxUnblockedTCB );
.LINE 3376

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,(_uxTopReadyPriority)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_410
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	(_uxTopReadyPriority),BC
L_410:
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFF4),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFF4)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%A),BC
	LD	IY,(IX+%FFFFFFF4)
	LD	DE,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,DE
	LD	(IY+%4),BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,(IX+%FFFFFFF4)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	(IY+%10),HL
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,_pxReadyTasksLists
	ADD	HL,DE
	LD	IY,BC
	LD	BC,(IY+%0)
	INC	BC
	LD	IY,HL
	LD	(IY+%0),BC
; 3377	
; 3378	    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
.LINE 3378

	LD	DE,(_pxCurrentTCB)
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	IY,DE
	LD	HL,(IY+%23)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_413
; 3379	    {
; 3380	        /* The unblocked task has a priority above that of the calling task, so
; 3381	         * a context switch is required.  This function is called with the
; 3382	         * scheduler suspended so xYieldPending is set so the context switch
; 3383	         * occurs immediately that the scheduler is resumed (unsuspended). */
; 3384	        xYieldPending = pdTRUE;
.LINE 3384

	LD	BC,1
	LD	(_xYieldPending),BC
; 3385	    }
; 3386	}
L_413:
.LINE 3386

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vTaskRemoveFromUnorderedEventList ***************************
;Name                         Addr/Register   Size   Type
;_xYieldPending                      STATIC      3   variable
;_pxCurrentTCB                       STATIC      3   variable
;_pxReadyTasksLists                  STATIC     80   variable
;_uxTopReadyPriority                 STATIC      3   variable
;pxIndex                              IX-12      3   variable
;pxList                                IX-9      3   variable
;pxList                                IX-6      3   variable
;pxUnblockedTCB                        IX-3      3   variable
;xItemValue                            IX+9      4   parameter
;pxEventListItem                       IX+6      3   parameter


; Stack Frame Size: 27 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vTaskRemoveFromUnorderedEventList",3386,"_vTaskRemoveFromUnorderedEventList"
; 3387	/*-----------------------------------------------------------*/
; 3388	
; 3389	void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
; 3390	{
_vTaskSetTimeOutState:
.DEFINE "_vTaskSetTimeOutState"

.VALUE _vTaskSetTimeOutState

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vTaskSetTimeOutState",3390,"_vTaskSetTimeOutState"

.LINE 3390

.DEFINE "pxTimeOut"

.CLASS 65

.VALUE 6

.TAG "xTIME_OUT"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 3391	    configASSERT( pxTimeOut );
; 3392	    taskENTER_CRITICAL();
.LINE 3392

	 di
; 3393	    {
; 3394	        pxTimeOut->xOverflowCount = xNumOfOverflows;
.LINE 3394

	LD	BC,(_xNumOfOverflows)
	LD	IY,(IX+%6)
	LD	(IY+%0),BC
; 3395	        pxTimeOut->xTimeOnEntering = xTickCount;
.LINE 3395

	LD	BC,(_xTickCount)
	LD	A,(_xTickCount+3)
	LD	IY,(IX+%6)
	LD	(IY+%3),BC
	LD	(IY+%6),A
; 3396	    }
; 3397	    taskEXIT_CRITICAL();
.LINE 3397

	 ei
; 3398	}
.LINE 3398

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vTaskSetTimeOutState ***************************
;Name                         Addr/Register   Size   Type
;_xTickCount                         STATIC      4   variable
;_xNumOfOverflows                    STATIC      3   variable
;pxTimeOut                             IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vTaskSetTimeOutState",3398,"_vTaskSetTimeOutState"
; 3399	/*-----------------------------------------------------------*/
; 3400	
; 3401	void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
; 3402	{
_vTaskInternalSetTimeOutState:
.DEFINE "_vTaskInternalSetTimeOutState"

.VALUE _vTaskInternalSetTimeOutState

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vTaskInternalSetTimeOutState",3402,"_vTaskInternalSetTimeOutState"

.LINE 3402

.DEFINE "pxTimeOut"

.CLASS 65

.VALUE 6

.TAG "xTIME_OUT"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 3403	    /* For internal use only as it does not use a critical section. */
; 3404	    pxTimeOut->xOverflowCount = xNumOfOverflows;
.LINE 3404

	LD	BC,(_xNumOfOverflows)
	LD	IY,(IX+%6)
	LD	(IY+%0),BC
; 3405	    pxTimeOut->xTimeOnEntering = xTickCount;
.LINE 3405

	LD	BC,(_xTickCount)
	LD	A,(_xTickCount+3)
	LD	IY,(IX+%6)
	LD	(IY+%3),BC
	LD	(IY+%6),A
; 3406	}
.LINE 3406

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vTaskInternalSetTimeOutState ***************************
;Name                         Addr/Register   Size   Type
;_xTickCount                         STATIC      4   variable
;_xNumOfOverflows                    STATIC      3   variable
;pxTimeOut                             IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vTaskInternalSetTimeOutState",3406,"_vTaskInternalSetTimeOutState"
; 3407	/*-----------------------------------------------------------*/
; 3408	
; 3409	BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
; 3410	                                 TickType_t * const pxTicksToWait )
; 3411	{
_xTaskCheckForTimeOut:
.DEFINE "_xTaskCheckForTimeOut"

.VALUE _xTaskCheckForTimeOut

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xTaskCheckForTimeOut",3411,"_xTaskCheckForTimeOut"

.LINE 3411

.DEFINE "pxTimeOut"

.CLASS 65

.VALUE 6

.TAG "xTIME_OUT"

.TYPE 40

.ENDEF

.DEFINE "pxTicksToWait"

.CLASS 65

.VALUE 9

.TYPE 47

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "xConstTickCount"

.CLASS 65

.VALUE -7

.TYPE 15

.ENDEF

.DEFINE "xElapsedTime"

.CLASS 65

.VALUE -11

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF5
	LD	SP,HL
; 3412	    BaseType_t xReturn;
; 3413	
; 3414	    configASSERT( pxTimeOut );
; 3415	    configASSERT( pxTicksToWait );
; 3416	
; 3417	    taskENTER_CRITICAL();
.LINE 3417

	 di
; 3418	    {
; 3419	        /* Minor optimisation.  The tick count cannot change in this block. */
; 3420	        const TickType_t xConstTickCount = xTickCount;
.LINE 3420

	LD	BC,(_xTickCount)
	LD	A,(_xTickCount+3)
	LD	(IX+%FFFFFFF9),BC
	LD	(IX+%FFFFFFFC),A
; 3421	        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
.LINE 3421

	LD	HL,(IX+%FFFFFFF9)
	LD	E,(IX+%FFFFFFFC)
	LD	IY,(IX+%6)
	LD	BC,(IY+%3)
	LD	A,(IY+%6)
	CALL	__lsub
	LD	(IX+%FFFFFFF5),HL
	LD	(IX+%FFFFFFF8),E
; 3422	
; 3423	        #if ( INCLUDE_xTaskAbortDelay == 1 )
; 3424	            if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
.LINE 3424

	LD	IY,(_pxCurrentTCB)
	LD	A,(IY+%44)
	OR	A,A
	JR	Z,L_424
; 3425	            {
; 3426	                /* The delay was aborted, which is not the same as a time out,
; 3427	                 * but has the same result. */
; 3428	                pxCurrentTCB->ucDelayAborted = pdFALSE;
.LINE 3428

	LD	IY,(_pxCurrentTCB)
	LD	(IY+%44),%0
; 3429	                xReturn = pdTRUE;
.LINE 3429

	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
; 3430	            }
; 3431	            else
.LINE 3431

	JR	L_425
L_424:
; 3432	        #endif
; 3433	
; 3434	        #if ( INCLUDE_vTaskSuspend == 1 )
; 3435	            if( *pxTicksToWait == portMAX_DELAY )
.LINE 3435

	LD	IY,(IX+%9)
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_422
; 3436	            {
; 3437	                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
; 3438	                 * specified is the maximum block time then the task should block
; 3439	                 * indefinitely, and therefore never time out. */
; 3440	                xReturn = pdFALSE;
.LINE 3440

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 3441	            }
; 3442	            else
.LINE 3442

	JR	L_425
L_422:
; 3443	        #endif
; 3444	
; 3445	        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
.LINE 3445

	LD	BC,(_xNumOfOverflows)
	LD	IY,(IX+%6)
	LD	HL,(IY+%0)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_420
	LD	HL,(IX+%FFFFFFF9)
	LD	E,(IX+%FFFFFFFC)
	LD	IY,(IX+%6)
	LD	BC,(IY+%3)
	LD	A,(IY+%6)
	CALL	__lcmpu
	JR	C,L_420
; 3446	        {
; 3447	            /* The tick count is greater than the time at which
; 3448	             * vTaskSetTimeout() was called, but has also overflowed since
; 3449	             * vTaskSetTimeOut() was called.  It must have wrapped all the way
; 3450	             * around and gone past again. This passed since vTaskSetTimeout()
; 3451	             * was called. */
; 3452	            xReturn = pdTRUE;
.LINE 3452

	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
; 3453	            *pxTicksToWait = ( TickType_t ) 0;
.LINE 3453

	LD	HL,(IX+%9)
	LD	BC,0
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),%0
; 3454	        }
; 3455	        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
.LINE 3455

	JR	L_425
L_420:
	LD	IY,(IX+%9)
	LD	HL,(IX+%FFFFFFF5)
	LD	E,(IX+%FFFFFFF8)
	LD	BC,(IY)
	LD	A,(IY+%3)
	CALL	__lcmpu
	JR	NC,L_418
; 3456	        {
; 3457	            /* Not a genuine timeout. Adjust parameters for time remaining. */
; 3458	            *pxTicksToWait -= xElapsedTime;
.LINE 3458

	LD	IY,(IX+%9)
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	CALL	__lsub
	LD	(IY),HL
	LD	(IY+%3),E
; 3459	            vTaskInternalSetTimeOutState( pxTimeOut );
.LINE 3459

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_vTaskInternalSetTimeOutState
	POP	BC
; 3460	            xReturn = pdFALSE;
.LINE 3460

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 3461	        }
; 3462	        else
.LINE 3462

	JR	L_425
L_418:
; 3463	        {
; 3464	            *pxTicksToWait = ( TickType_t ) 0;
.LINE 3464

	LD	HL,(IX+%9)
	LD	BC,0
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),%0
; 3465	            xReturn = pdTRUE;
.LINE 3465

	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
; 3466	        }
; 3467	    }
L_425:
.LINE 3467

; 3468	    taskEXIT_CRITICAL();
.LINE 3468

	 ei
; 3469	
; 3470	    return xReturn;
.LINE 3470

	LD	HL,(IX+%FFFFFFFD)
; 3471	}
.LINE 3471

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskCheckForTimeOut ***************************
;Name                         Addr/Register   Size   Type
;_vTaskInternalSetTimeOutState       IMPORT  -----   function
;_xNumOfOverflows                    STATIC      3   variable
;_pxCurrentTCB                       STATIC      3   variable
;_xTickCount                         STATIC      4   variable
;xElapsedTime                         IX-11      4   variable
;xConstTickCount                       IX-7      4   variable
;xReturn                               IX-3      3   variable
;pxTicksToWait                         IX+9      3   parameter
;pxTimeOut                             IX+6      3   parameter


; Stack Frame Size: 23 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskCheckForTimeOut",3471,"_xTaskCheckForTimeOut"
; 3472	/*-----------------------------------------------------------*/
; 3473	
; 3474	void vTaskMissedYield( void )
; 3475	{
_vTaskMissedYield:
.DEFINE "_vTaskMissedYield"

.VALUE _vTaskMissedYield

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vTaskMissedYield",3475,"_vTaskMissedYield"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 3476	    xYieldPending = pdTRUE;
.LINE 3476

	LD	BC,1
	LD	(_xYieldPending),BC
; 3477	}
.LINE 3477

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vTaskMissedYield ***************************
;Name                         Addr/Register   Size   Type
;_xYieldPending                      STATIC      3   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vTaskMissedYield",3477,"_vTaskMissedYield"
; 3478	/*-----------------------------------------------------------*/
; 3479	
; 3480	#if ( configUSE_TRACE_FACILITY == 1 )
; 3481	
; 3482	    UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
; 3483	    {
; 3484	        UBaseType_t uxReturn;
; 3485	        TCB_t const * pxTCB;
; 3486	
; 3487	        if( xTask != NULL )
; 3488	        {
; 3489	            pxTCB = xTask;
; 3490	            uxReturn = pxTCB->uxTaskNumber;
; 3491	        }
; 3492	        else
; 3493	        {
; 3494	            uxReturn = 0U;
; 3495	        }
; 3496	
; 3497	        return uxReturn;
; 3498	    }
; 3499	
; 3500	#endif /* configUSE_TRACE_FACILITY */
; 3501	/*-----------------------------------------------------------*/
; 3502	
; 3503	#if ( configUSE_TRACE_FACILITY == 1 )
; 3504	
; 3505	    void vTaskSetTaskNumber( TaskHandle_t xTask,
; 3506	                             const UBaseType_t uxHandle )
; 3507	    {
; 3508	        TCB_t * pxTCB;
; 3509	
; 3510	        if( xTask != NULL )
; 3511	        {
; 3512	            pxTCB = xTask;
; 3513	            pxTCB->uxTaskNumber = uxHandle;
; 3514	        }
; 3515	    }
; 3516	
; 3517	#endif /* configUSE_TRACE_FACILITY */
; 3518	
; 3519	/*
; 3520	 * -----------------------------------------------------------
; 3521	 * The Idle task.
; 3522	 * ----------------------------------------------------------
; 3523	 *
; 3524	 * The portTASK_FUNCTION() macro is used to allow port/compiler specific
; 3525	 * language extensions.  The equivalent prototype for this function is:
; 3526	 *
; 3527	 * void prvIdleTask( void *pvParameters );
; 3528	 *
; 3529	 */
; 3530	static portTASK_FUNCTION( prvIdleTask, pvParameters )
; 3531	{
_prvIdleTask:
.DEFINE "_prvIdleTask"

.VALUE _prvIdleTask

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "prvIdleTask",3531,"_prvIdleTask"

.LINE 3531

.DEFINE "pvParameters"

.CLASS 65

.VALUE 6

.TYPE 33

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
.ENDEF

; 3532	    /* Stop warnings. */
; 3533	    ( void ) pvParameters;
; 3534	
; 3535	    /** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
; 3536	     * SCHEDULER IS STARTED. **/
; 3537	
; 3538	    /* In case a task that has a secure context deletes itself, in which case
; 3539	     * the idle task is responsible for deleting the task's secure context, if
; 3540	     * any. */
; 3541	    portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );
; 3542	
; 3543	    for( ; ; )
L_431:
.LINE 3543

; 3544	    {
; 3545	        /* See if any tasks have deleted themselves - if so then the idle task
; 3546	         * is responsible for freeing the deleted task's TCB and stack. */
; 3547	        prvCheckTasksWaitingTermination();
.LINE 3547

	CALL	_prvCheckTasksWaitingTermination
; 3548	
; 3549	        #if ( configUSE_PREEMPTION == 0 )
; 3550	        {
; 3551	            /* If we are not using preemption we keep forcing a task switch to
; 3552	             * see if any other task has become available.  If we are using
; 3553	             * preemption we don't need to do this as any task becoming available
; 3554	             * will automatically get the processor anyway. */
; 3555	            taskYIELD();
; 3556	        }
; 3557	        #endif /* configUSE_PREEMPTION */
; 3558	
; 3559	        #if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
; 3560	        {
; 3561	            /* When using preemption tasks of equal priority will be
; 3562	             * timesliced.  If a task that is sharing the idle priority is ready
; 3563	             * to run then the idle task should yield before the end of the
; 3564	             * timeslice.
; 3565	             *
; 3566	             * A critical region is not required here as we are just reading from
; 3567	             * the list, and an occasional incorrect value will not matter.  If
; 3568	             * the ready list at the idle priority contains more than one task
; 3569	             * then a task other than the idle task is ready to execute. */
; 3570	            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
.LINE 3570

	LD	BC,(_pxReadyTasksLists)
	LD	HL,1
	OR	A,A
	SBC	HL,BC
	JR	NC,L_429
; 3571	            {
; 3572	                taskYIELD();
.LINE 3572

	CALL	_vPortYield
; 3573	            }
; 3574	            else
L_429:
.LINE 3574

; 3575	            {
; 3576	                mtCOVERAGE_TEST_MARKER();
; 3577	            }
; 3578	        }
; 3579	        #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
; 3580	
; 3581	        #if ( configUSE_IDLE_HOOK == 1 )
; 3582	        {
; 3583	            extern void vApplicationIdleHook( void );
; 3584	
; 3585	            /* Call the user defined function from within the idle task.  This
; 3586	             * allows the application designer to add background functionality
; 3587	             * without the overhead of a separate task.
; 3588	             * NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
; 3589	             * CALL A FUNCTION THAT MIGHT BLOCK. */
; 3590	            vApplicationIdleHook();
.LINE 3590

	CALL	_vApplicationIdleHook
; 3591	        }
; 3592	        #endif /* configUSE_IDLE_HOOK */
; 3593	
; 3594	        /* This conditional compilation should use inequality to 0, not equality
; 3595	         * to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
; 3596	         * user defined low power mode  implementations require
; 3597	         * configUSE_TICKLESS_IDLE to be set to a value other than 1. */
; 3598	        #if ( configUSE_TICKLESS_IDLE != 0 )
; 3599	        {
; 3600	            TickType_t xExpectedIdleTime;
; 3601	
; 3602	            /* It is not desirable to suspend then resume the scheduler on
; 3603	             * each iteration of the idle task.  Therefore, a preliminary
; 3604	             * test of the expected idle time is performed without the
; 3605	             * scheduler suspended.  The result here is not necessarily
; 3606	             * valid. */
; 3607	            xExpectedIdleTime = prvGetExpectedIdleTime();
; 3608	
; 3609	            if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
; 3610	            {
; 3611	                vTaskSuspendAll();
; 3612	                {
; 3613	                    /* Now the scheduler is suspended, the expected idle
; 3614	                     * time can be sampled again, and this time its value can
; 3615	                     * be used. */
; 3616	                    configASSERT( xNextTaskUnblockTime >= xTickCount );
; 3617	                    xExpectedIdleTime = prvGetExpectedIdleTime();
; 3618	
; 3619	                    /* Define the following macro to set xExpectedIdleTime to 0
; 3620	                     * if the application does not want
; 3621	                     * portSUPPRESS_TICKS_AND_SLEEP() to be called. */
; 3622	                    configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
; 3623	
; 3624	                    if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
; 3625	                    {
; 3626	                        traceLOW_POWER_IDLE_BEGIN();
; 3627	                        portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
; 3628	                        traceLOW_POWER_IDLE_END();
; 3629	                    }
; 3630	                    else
; 3631	                    {
; 3632	                        mtCOVERAGE_TEST_MARKER();
; 3633	                    }
; 3634	                }
; 3635	                ( void ) xTaskResumeAll();
; 3636	            }
; 3637	            else
; 3638	            {
; 3639	                mtCOVERAGE_TEST_MARKER();
; 3640	            }
; 3641	        }
; 3642	        #endif /* configUSE_TICKLESS_IDLE */
; 3643	    }
.LINE 3643

	JR	L_431
; 3644	}
.LINE 3644

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvIdleTask ***************************
;Name                         Addr/Register   Size   Type
;_vApplicationIdleHook               IMPORT  -----   function
;_vPortYield                         IMPORT  -----   function
;_pxReadyTasksLists                  STATIC     80   variable
;_prvCheckTasksWaitingTermination      IMPORT  -----   function
;pvParameters                          IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvIdleTask",3644,"_prvIdleTask"
; 3645	/*-----------------------------------------------------------*/
; 3646	
; 3647	#if ( configUSE_TICKLESS_IDLE != 0 )
; 3648	
; 3649	    eSleepModeStatus eTaskConfirmSleepModeStatus( void )
; 3650	    {
; 3651	        #if ( INCLUDE_vTaskSuspend == 1 )
; 3652	            /* The idle task exists in addition to the application tasks. */
; 3653	            const UBaseType_t uxNonApplicationTasks = 1;
; 3654	        #endif /* INCLUDE_vTaskSuspend */
; 3655	
; 3656	        eSleepModeStatus eReturn = eStandardSleep;
; 3657	
; 3658	        /* This function must be called from a critical section. */
; 3659	
; 3660	        if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
; 3661	        {
; 3662	            /* A task was made ready while the scheduler was suspended. */
; 3663	            eReturn = eAbortSleep;
; 3664	        }
; 3665	        else if( xYieldPending != pdFALSE )
; 3666	        {
; 3667	            /* A yield was pended while the scheduler was suspended. */
; 3668	            eReturn = eAbortSleep;
; 3669	        }
; 3670	        else if( xPendedTicks != 0 )
; 3671	        {
; 3672	            /* A tick interrupt has already occurred but was held pending
; 3673	             * because the scheduler is suspended. */
; 3674	            eReturn = eAbortSleep;
; 3675	        }
; 3676	
; 3677	        #if ( INCLUDE_vTaskSuspend == 1 )
; 3678	            else if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
; 3679	            {
; 3680	                /* If all the tasks are in the suspended list (which might mean they
; 3681	                 * have an infinite block time rather than actually being suspended)
; 3682	                 * then it is safe to turn all clocks off and just wait for external
; 3683	                 * interrupts. */
; 3684	                eReturn = eNoTasksWaitingTimeout;
; 3685	            }
; 3686	        #endif /* INCLUDE_vTaskSuspend */
; 3687	        else
; 3688	        {
; 3689	            mtCOVERAGE_TEST_MARKER();
; 3690	        }
; 3691	
; 3692	        return eReturn;
; 3693	    }
; 3694	
; 3695	#endif /* configUSE_TICKLESS_IDLE */
; 3696	/*-----------------------------------------------------------*/
; 3697	
; 3698	#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
; 3699	
; 3700	    void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,
; 3701	                                            BaseType_t xIndex,
; 3702	                                            void * pvValue )
; 3703	    {
; 3704	        TCB_t * pxTCB;
; 3705	
; 3706	        if( ( xIndex >= 0 ) &&
; 3707	            ( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS ) )
; 3708	        {
; 3709	            pxTCB = prvGetTCBFromHandle( xTaskToSet );
; 3710	            configASSERT( pxTCB != NULL );
; 3711	            pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
; 3712	        }
; 3713	    }
; 3714	
; 3715	#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
; 3716	/*-----------------------------------------------------------*/
; 3717	
; 3718	#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
; 3719	
; 3720	    void * pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,
; 3721	                                               BaseType_t xIndex )
; 3722	    {
; 3723	        void * pvReturn = NULL;
; 3724	        TCB_t * pxTCB;
; 3725	
; 3726	        if( ( xIndex >= 0 ) &&
; 3727	            ( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS ) )
; 3728	        {
; 3729	            pxTCB = prvGetTCBFromHandle( xTaskToQuery );
; 3730	            pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
; 3731	        }
; 3732	        else
; 3733	        {
; 3734	            pvReturn = NULL;
; 3735	        }
; 3736	
; 3737	        return pvReturn;
; 3738	    }
; 3739	
; 3740	#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
; 3741	/*-----------------------------------------------------------*/
; 3742	
; 3743	#if ( portUSING_MPU_WRAPPERS == 1 )
; 3744	
; 3745	    void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify,
; 3746	                                  const MemoryRegion_t * const xRegions )
; 3747	    {
; 3748	        TCB_t * pxTCB;
; 3749	
; 3750	        /* If null is passed in here then we are modifying the MPU settings of
; 3751	         * the calling task. */
; 3752	        pxTCB = prvGetTCBFromHandle( xTaskToModify );
; 3753	
; 3754	        vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
; 3755	    }
; 3756	
; 3757	#endif /* portUSING_MPU_WRAPPERS */
; 3758	/*-----------------------------------------------------------*/
; 3759	
; 3760	static void prvInitialiseTaskLists( void )
; 3761	{
_prvInitialiseTaskLists:
.DEFINE "_prvInitialiseTaskLists"

.VALUE _prvInitialiseTaskLists

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "prvInitialiseTaskLists",3761,"_prvInitialiseTaskLists"

.LINE 3761

.DEFINE "uxPriority"

.CLASS 65

.VALUE -3

.TYPE 14

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
.ENDEF

	JR	L_435
; 3762	    UBaseType_t uxPriority;
; 3763	
; 3764	#	if defined( _DEBUG )&& 0
; 3765			( void )printf( "%s : %d\r\n", "tasks.c", __LINE__ );
; 3766	#	endif
; 3767	
; 3768	    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
L_436:
.LINE 3768

	LD	BC,5
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_438
	JR	L_439
L_435:
	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_436
L_438:
; 3769	    {
; 3770	        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
.LINE 3770

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	PUSH	HL
	CALL	_vListInitialise
	POP	BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
; 3771	    }
.LINE 3771

	JR	L_436
L_439:
; 3772	
; 3773	    vListInitialise( &xDelayedTaskList1 );
.LINE 3773

	LD	BC,_xDelayedTaskList1
	PUSH	BC
	CALL	_vListInitialise
	POP	BC
; 3774	    vListInitialise( &xDelayedTaskList2 );
.LINE 3774

	LD	BC,_xDelayedTaskList2
	PUSH	BC
	CALL	_vListInitialise
	POP	BC
; 3775	    vListInitialise( &xPendingReadyList );
.LINE 3775

	LD	BC,_xPendingReadyList
	PUSH	BC
	CALL	_vListInitialise
	POP	BC
; 3776	
; 3777	    #if ( INCLUDE_vTaskDelete == 1 )
; 3778	    {
; 3779	        vListInitialise( &xTasksWaitingTermination );
.LINE 3779

	LD	BC,_xTasksWaitingTermination
	PUSH	BC
	CALL	_vListInitialise
	POP	BC
; 3780	    }
; 3781	    #endif /* INCLUDE_vTaskDelete */
; 3782	
; 3783	    #if ( INCLUDE_vTaskSuspend == 1 )
; 3784	    {
; 3785	        vListInitialise( &xSuspendedTaskList );
.LINE 3785

	LD	BC,_xSuspendedTaskList
	PUSH	BC
	CALL	_vListInitialise
	POP	BC
; 3786	    }
; 3787	    #endif /* INCLUDE_vTaskSuspend */
; 3788	
; 3789	    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
; 3790	     * using list2. */
; 3791	    pxDelayedTaskList = &xDelayedTaskList1;
.LINE 3791

	LD	BC,_xDelayedTaskList1
	LD	(_pxDelayedTaskList),BC
; 3792	    pxOverflowDelayedTaskList = &xDelayedTaskList2;
.LINE 3792

	LD	BC,_xDelayedTaskList2
	LD	(_pxOverflowDelayedTaskList),BC
; 3793	}
.LINE 3793

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvInitialiseTaskLists ***************************
;Name                         Addr/Register   Size   Type
;_pxOverflowDelayedTaskList          STATIC      3   variable
;_pxDelayedTaskList                  STATIC      3   variable
;_xSuspendedTaskList                 STATIC     16   variable
;_xTasksWaitingTermination           STATIC     16   variable
;_xPendingReadyList                  STATIC     16   variable
;_xDelayedTaskList2                  STATIC     16   variable
;_xDelayedTaskList1                  STATIC     16   variable
;_pxReadyTasksLists                  STATIC     80   variable
;_vListInitialise                    IMPORT  -----   function
;uxPriority                            IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvInitialiseTaskLists",3793,"_prvInitialiseTaskLists"
; 3794	/*-----------------------------------------------------------*/
; 3795	
; 3796	static void prvCheckTasksWaitingTermination( void )
; 3797	{
_prvCheckTasksWaitingTermination:
.DEFINE "_prvCheckTasksWaitingTermination"

.VALUE _prvCheckTasksWaitingTermination

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "prvCheckTasksWaitingTermination",3797,"_prvCheckTasksWaitingTermination"

.LINE 3797

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
.ENDEF

; 3798	    /** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
; 3799	
; 3800	    #if ( INCLUDE_vTaskDelete == 1 )
; 3801	    {
; 3802	        TCB_t * pxTCB;
; 3803	
; 3804	        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
; 3805	         * being called too often in the idle task. */
; 3806	        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
L_441:
.LINE 3806

	LD	BC,(_uxDeletedTasksWaitingCleanUp)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	NC,L_443
; 3807	        {
; 3808	            taskENTER_CRITICAL();
.LINE 3808

	 di
; 3809	            {
; 3810	                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
.LINE 3810

	LD	IY,(_xTasksWaitingTermination+10)
	LD	BC,(IY+%A)
	LD	(IX+%FFFFFFFD),BC
; 3811	                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
.LINE 3811

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%3
	CALL	_uxListRemove
	POP	BC
; 3812	                --uxCurrentNumberOfTasks;
.LINE 3812

	LD	IY,(_uxCurrentNumberOfTasks)
	LEA	BC,IY+%FFFFFFFF
	LD	(_uxCurrentNumberOfTasks),BC
; 3813	                --uxDeletedTasksWaitingCleanUp;
.LINE 3813

	LD	IY,(_uxDeletedTasksWaitingCleanUp)
	LEA	BC,IY+%FFFFFFFF
	LD	(_uxDeletedTasksWaitingCleanUp),BC
; 3814	            }
; 3815	            taskEXIT_CRITICAL();
.LINE 3815

	 ei
; 3816	
; 3817	            prvDeleteTCB( pxTCB );
.LINE 3817

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_prvDeleteTCB
	POP	BC
; 3818	        }
.LINE 3818

	JR	L_441
; 3819	    }
; 3820	    #endif /* INCLUDE_vTaskDelete */
; 3821	}
L_443:
.LINE 3821

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvCheckTasksWaitingTermination ***************************
;Name                         Addr/Register   Size   Type
;_prvDeleteTCB                       IMPORT  -----   function
;_uxCurrentNumberOfTasks             STATIC      3   variable
;_uxListRemove                       IMPORT  -----   function
;_xTasksWaitingTermination           STATIC     16   variable
;_uxDeletedTasksWaitingCleanUp       STATIC      3   variable
;pxTCB                                 IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvCheckTasksWaitingTermination",3821,"_prvCheckTasksWaitingTermination"
; 3822	/*-----------------------------------------------------------*/
; 3823	
; 3824	#if ( configUSE_TRACE_FACILITY == 1 )
; 3825	
; 3826	    void vTaskGetInfo( TaskHandle_t xTask,
; 3827	                       TaskStatus_t * pxTaskStatus,
; 3828	                       BaseType_t xGetFreeStackSpace,
; 3829	                       eTaskState eState )
; 3830	    {
; 3831	        TCB_t * pxTCB;
; 3832	
; 3833	        /* xTask is NULL then get the state of the calling task. */
; 3834	        pxTCB = prvGetTCBFromHandle( xTask );
; 3835	
; 3836	        pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
; 3837	        pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
; 3838	        pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
; 3839	        pxTaskStatus->pxStackBase = pxTCB->pxStack;
; 3840	        #if ( ( portSTACK_GROWTH > 0 ) && ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
; 3841	            pxTaskStatus->pxTopOfStack = pxTCB->pxTopOfStack;
; 3842	            pxTaskStatus->pxEndOfStack = pxTCB->pxEndOfStack;
; 3843	        #endif
; 3844	        pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
; 3845	
; 3846	        #if ( configUSE_MUTEXES == 1 )
; 3847	        {
; 3848	            pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
; 3849	        }
; 3850	        #else
; 3851	        {
; 3852	            pxTaskStatus->uxBasePriority = 0;
; 3853	        }
; 3854	        #endif
; 3855	
; 3856	        #if ( configGENERATE_RUN_TIME_STATS == 1 )
; 3857	        {
; 3858	            pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
; 3859	        }
; 3860	        #else
; 3861	        {
; 3862	            pxTaskStatus->ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) 0;
; 3863	        }
; 3864	        #endif
; 3865	
; 3866	        /* Obtaining the task state is a little fiddly, so is only done if the
; 3867	         * value of eState passed into this function is eInvalid - otherwise the
; 3868	         * state is just set to whatever is passed in. */
; 3869	        if( eState != eInvalid )
; 3870	        {
; 3871	            if( pxTCB == pxCurrentTCB )
; 3872	            {
; 3873	                pxTaskStatus->eCurrentState = eRunning;
; 3874	            }
; 3875	            else
; 3876	            {
; 3877	                pxTaskStatus->eCurrentState = eState;
; 3878	
; 3879	                #if ( INCLUDE_vTaskSuspend == 1 )
; 3880	                {
; 3881	                    /* If the task is in the suspended list then there is a
; 3882	                     *  chance it is actually just blocked indefinitely - so really
; 3883	                     *  it should be reported as being in the Blocked state. */
; 3884	                    if( eState == eSuspended )
; 3885	                    {
; 3886	                        vTaskSuspendAll();
; 3887	                        {
; 3888	                            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
; 3889	                            {
; 3890	                                pxTaskStatus->eCurrentState = eBlocked;
; 3891	                            }
; 3892	                        }
; 3893	                        ( void ) xTaskResumeAll();
; 3894	                    }
; 3895	                }
; 3896	                #endif /* INCLUDE_vTaskSuspend */
; 3897	            }
; 3898	        }
; 3899	        else
; 3900	        {
; 3901	            pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
; 3902	        }
; 3903	
; 3904	        /* Obtaining the stack space takes some time, so the xGetFreeStackSpace
; 3905	         * parameter is provided to allow it to be skipped. */
; 3906	        if( xGetFreeStackSpace != pdFALSE )
; 3907	        {
; 3908	            #if ( portSTACK_GROWTH > 0 )
; 3909	            {
; 3910	                pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
; 3911	            }
; 3912	            #else
; 3913	            {
; 3914	                pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
; 3915	            }
; 3916	            #endif
; 3917	        }
; 3918	        else
; 3919	        {
; 3920	            pxTaskStatus->usStackHighWaterMark = 0;
; 3921	        }
; 3922	    }
; 3923	
; 3924	#endif /* configUSE_TRACE_FACILITY */
; 3925	/*-----------------------------------------------------------*/
; 3926	
; 3927	#if ( configUSE_TRACE_FACILITY == 1 )
; 3928	
; 3929	    static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
; 3930	                                                     List_t * pxList,
; 3931	                                                     eTaskState eState )
; 3932	    {
; 3933	        configLIST_VOLATILE TCB_t * pxNextTCB;
; 3934	        configLIST_VOLATILE TCB_t * pxFirstTCB;
; 3935	        UBaseType_t uxTask = 0;
; 3936	
; 3937	        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
; 3938	        {
; 3939	            listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
; 3940	
; 3941	            /* Populate an TaskStatus_t structure within the
; 3942	             * pxTaskStatusArray array for each task that is referenced from
; 3943	             * pxList.  See the definition of TaskStatus_t in task.h for the
; 3944	             * meaning of each TaskStatus_t structure member. */
; 3945	            do
; 3946	            {
; 3947	                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
; 3948	                vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
; 3949	                uxTask++;
; 3950	            } while( pxNextTCB != pxFirstTCB );
; 3951	        }
; 3952	        else
; 3953	        {
; 3954	            mtCOVERAGE_TEST_MARKER();
; 3955	        }
; 3956	
; 3957	        return uxTask;
; 3958	    }
; 3959	
; 3960	#endif /* configUSE_TRACE_FACILITY */
; 3961	/*-----------------------------------------------------------*/
; 3962	
; 3963	#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )
; 3964	
; 3965	    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
; 3966	    {
_prvTaskCheckFreeStackSpace:
.DEFINE "_prvTaskCheckFreeStackSpace"

.VALUE _prvTaskCheckFreeStackSpace

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "prvTaskCheckFreeStackSpace",3966,"_prvTaskCheckFreeStackSpace"

.LINE 3966

.DEFINE "pucStackByte"

.CLASS 65

.VALUE 6

.TYPE 204

.ENDEF

.DEFINE "ulCount"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
; 3967	        uint32_t ulCount = 0U;
.LINE 3967

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
; 3968	
; 3969	        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
L_445:
.LINE 3969

	LD	HL,(IX+%6)
	LD	A,(HL)
	CP	A,%A5
	JR	NZ,L_447
; 3970	        {
; 3971	            pucStackByte -= portSTACK_GROWTH;
.LINE 3971

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
; 3972	            ulCount++;
.LINE 3972

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
; 3973	        }
.LINE 3973

	JR	L_445
L_447:
; 3974	
; 3975	        ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
.LINE 3975

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,3
	XOR	A,A
	CALL	__ldivu
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
; 3976	
; 3977	        return ( configSTACK_DEPTH_TYPE ) ulCount;
.LINE 3977

	LD	HL,(IX+%FFFFFFFC)
; 3978	    }
.LINE 3978

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvTaskCheckFreeStackSpace ***************************
;Name                         Addr/Register   Size   Type
;ulCount                               IX-4      4   variable
;pucStackByte                          IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvTaskCheckFreeStackSpace",3978,"_prvTaskCheckFreeStackSpace"
; 3979	
; 3980	#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) ) */
; 3981	/*-----------------------------------------------------------*/
; 3982	
; 3983	#if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )
; 3984	
; 3985	/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
; 3986	 * same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
; 3987	 * user to determine the return type.  It gets around the problem of the value
; 3988	 * overflowing on 8-bit types without breaking backward compatibility for
; 3989	 * applications that expect an 8-bit return type. */
; 3990	    configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )
; 3991	    {
_uxTaskGetStackHighWaterMark2:
.DEFINE "_uxTaskGetStackHighWaterMark2"

.VALUE _uxTaskGetStackHighWaterMark2

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "uxTaskGetStackHighWaterMark2",3991,"_uxTaskGetStackHighWaterMark2"

.LINE 3991

.DEFINE "xTask"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pucEndOfStack"

.CLASS 65

.VALUE -9

.TYPE 44

.ENDEF

.DEFINE "uxReturn"

.CLASS 65

.VALUE -12

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF4
	LD	SP,HL
; 3992	        TCB_t * pxTCB;
; 3993	        uint8_t * pucEndOfStack;
; 3994	        configSTACK_DEPTH_TYPE uxReturn;
; 3995	
; 3996	        /* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are
; 3997	         * the same except for their return type.  Using configSTACK_DEPTH_TYPE
; 3998	         * allows the user to determine the return type.  It gets around the
; 3999	         * problem of the value overflowing on 8-bit types without breaking
; 4000	         * backward compatibility for applications that expect an 8-bit return
; 4001	         * type. */
; 4002	
; 4003	        pxTCB = prvGetTCBFromHandle( xTask );
.LINE 4003

	LD	HL,(IX+%6)
	CALL	__icmpzero
	JR	NZ,L_451
	LD	BC,(_pxCurrentTCB)
	LD	(IX+%FFFFFFFD),BC
	JR	L_452
L_451:
	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
L_452:
	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFFA),BC
; 4004	
; 4005	        #if portSTACK_GROWTH < 0
; 4006	        {
; 4007	            pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
.LINE 4007

	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%26)
	LD	(IX+%FFFFFFF7),BC
; 4008	        }
; 4009	        #else
; 4010	        {
; 4011	            pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
; 4012	        }
; 4013	        #endif
; 4014	
; 4015	        uxReturn = prvTaskCheckFreeStackSpace( pucEndOfStack );
.LINE 4015

	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	CALL	_prvTaskCheckFreeStackSpace
	POP	BC
	LD	(IX+%FFFFFFF4),HL
; 4016	
; 4017	        return uxReturn;
.LINE 4017

	LD	HL,(IX+%FFFFFFF4)
; 4018	    }
.LINE 4018

	LD	SP,IX
	POP	IX
	RET	


;**************************** _uxTaskGetStackHighWaterMark2 ***************************
;Name                         Addr/Register   Size   Type
;_prvTaskCheckFreeStackSpace         IMPORT  -----   function
;_pxCurrentTCB                       STATIC      3   variable
;uxReturn                             IX-12      3   variable
;pucEndOfStack                         IX-9      3   variable
;pxTCB                                 IX-6      3   variable
;temp449                               IX-3      3   variable
;xTask                                 IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "uxTaskGetStackHighWaterMark2",4018,"_uxTaskGetStackHighWaterMark2"
; 4019	
; 4020	#endif /* INCLUDE_uxTaskGetStackHighWaterMark2 */
; 4021	/*-----------------------------------------------------------*/
; 4022	
; 4023	#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
; 4024	
; 4025	    UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
; 4026	    {
_uxTaskGetStackHighWaterMark:
.DEFINE "_uxTaskGetStackHighWaterMark"

.VALUE _uxTaskGetStackHighWaterMark

.CLASS 2

.TYPE 78

.ENDEF

.BEGFUNC "uxTaskGetStackHighWaterMark",4026,"_uxTaskGetStackHighWaterMark"

.LINE 4026

.DEFINE "xTask"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pucEndOfStack"

.CLASS 65

.VALUE -9

.TYPE 44

.ENDEF

.DEFINE "uxReturn"

.CLASS 65

.VALUE -12

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF4
	LD	SP,HL
; 4027	        TCB_t * pxTCB;
; 4028	        uint8_t * pucEndOfStack;
; 4029	        UBaseType_t uxReturn;
; 4030	
; 4031	        pxTCB = prvGetTCBFromHandle( xTask );
.LINE 4031

	LD	HL,(IX+%6)
	CALL	__icmpzero
	JR	NZ,L_456
	LD	BC,(_pxCurrentTCB)
	LD	(IX+%FFFFFFFD),BC
	JR	L_457
L_456:
	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
L_457:
	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFFA),BC
; 4032	
; 4033	        #if portSTACK_GROWTH < 0
; 4034	        {
; 4035	            pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
.LINE 4035

	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%26)
	LD	(IX+%FFFFFFF7),BC
; 4036	        }
; 4037	        #else
; 4038	        {
; 4039	            pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
; 4040	        }
; 4041	        #endif
; 4042	
; 4043	        uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
.LINE 4043

	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	CALL	_prvTaskCheckFreeStackSpace
	POP	BC
	LD	(IX+%FFFFFFF4),HL
; 4044	
; 4045	        return uxReturn;
.LINE 4045

	LD	HL,(IX+%FFFFFFF4)
; 4046	    }
.LINE 4046

	LD	SP,IX
	POP	IX
	RET	


;**************************** _uxTaskGetStackHighWaterMark ***************************
;Name                         Addr/Register   Size   Type
;_prvTaskCheckFreeStackSpace         IMPORT  -----   function
;_pxCurrentTCB                       STATIC      3   variable
;uxReturn                             IX-12      3   variable
;pucEndOfStack                         IX-9      3   variable
;pxTCB                                 IX-6      3   variable
;temp454                               IX-3      3   variable
;xTask                                 IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "uxTaskGetStackHighWaterMark",4046,"_uxTaskGetStackHighWaterMark"
; 4047	
; 4048	#endif /* INCLUDE_uxTaskGetStackHighWaterMark */
; 4049	/*-----------------------------------------------------------*/
; 4050	
; 4051	#if ( INCLUDE_vTaskDelete == 1 )
; 4052	
; 4053	    static void prvDeleteTCB( TCB_t * pxTCB )
; 4054	    {
_prvDeleteTCB:
.DEFINE "_prvDeleteTCB"

.VALUE _prvDeleteTCB

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "prvDeleteTCB",4054,"_prvDeleteTCB"

.LINE 4054

.DEFINE "pxTCB"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 4055	        /* This call is required specifically for the TriCore port.  It must be
; 4056	         * above the vPortFree() calls.  The call is also used by ports/demos that
; 4057	         * want to allocate and clean RAM statically. */
; 4058	        portCLEAN_UP_TCB( pxTCB );
; 4059	
; 4060	        #if ( ( configUSE_NEWLIB_REENTRANT == 1 ) || ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 ) )
; 4061	        {
; 4062	            /* Free up the memory allocated for the task's TLS Block. */
; 4063	            configDEINIT_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
; 4064	        }
; 4065	        #endif
; 4066	
; 4067	        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
; 4068	        {
; 4069	            /* The task can only have been allocated dynamically - free both
; 4070	             * the stack and TCB. */
; 4071	            vPortFreeStack( pxTCB->pxStack );
.LINE 4071

	LD	IY,(IX+%6)
	LD	BC,(IY+%26)
	PUSH	BC
	CALL	_vPortFree
	POP	BC
; 4072	            vPortFree( pxTCB );
.LINE 4072

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_vPortFree
	POP	BC
; 4073	        }
; 4074	        #elif ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
; 4075	        {
; 4076	            /* The task could have been allocated statically or dynamically, so
; 4077	             * check what was statically allocated before trying to free the
; 4078	             * memory. */
; 4079	            if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
; 4080	            {
; 4081	                /* Both the stack and TCB were allocated dynamically, so both
; 4082	                 * must be freed. */
; 4083	                vPortFreeStack( pxTCB->pxStack );
; 4084	                vPortFree( pxTCB );
; 4085	            }
; 4086	            else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
; 4087	            {
; 4088	                /* Only the stack was statically allocated, so the TCB is the
; 4089	                 * only memory that must be freed. */
; 4090	                vPortFree( pxTCB );
; 4091	            }
; 4092	            else
; 4093	            {
; 4094	                /* Neither the stack nor the TCB were allocated dynamically, so
; 4095	                 * nothing needs to be freed. */
; 4096	                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
; 4097	                mtCOVERAGE_TEST_MARKER();
; 4098	            }
; 4099	        }
; 4100	        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
; 4101	    }
.LINE 4101

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvDeleteTCB ***************************
;Name                         Addr/Register   Size   Type
;_vPortFree                          IMPORT  -----   function
;pxTCB                                 IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvDeleteTCB",4101,"_prvDeleteTCB"
; 4102	
; 4103	#endif /* INCLUDE_vTaskDelete */
; 4104	/*-----------------------------------------------------------*/
; 4105	
; 4106	static void prvResetNextTaskUnblockTime( void )
; 4107	{
_prvResetNextTaskUnblockTime:
.DEFINE "_prvResetNextTaskUnblockTime"

.VALUE _prvResetNextTaskUnblockTime

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "prvResetNextTaskUnblockTime",4107,"_prvResetNextTaskUnblockTime"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
; 4108	    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
.LINE 4108

	LD	IY,(_pxDelayedTaskList)
	LD	HL,(IY+%0)
	CALL	__icmpzero
	JR	NZ,L_462
	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
	JR	L_463
L_462:
	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
L_463:
	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	Z,L_465
; 4109	    {
; 4110	        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
; 4111	         * the maximum possible value so it is  extremely unlikely that the
; 4112	         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
; 4113	         * there is an item in the delayed list. */
; 4114	        xNextTaskUnblockTime = portMAX_DELAY;
.LINE 4114

	LD	BC,16777215
	LD	A,%FF
	LD	(_xNextTaskUnblockTime),BC
	LD	(_xNextTaskUnblockTime+3),A
; 4115	    }
; 4116	    else
.LINE 4116

	JR	L_466
L_465:
; 4117	    {
; 4118	        /* The new current delayed list is not empty, get the value of
; 4119	         * the item at the head of the delayed list.  This is the time at
; 4120	         * which the task at the head of the delayed list should be removed
; 4121	         * from the Blocked state. */
; 4122	        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
.LINE 4122

	LD	IY,(_pxDelayedTaskList)
	LD	IY,(IY+%A)
	LD	BC,(IY+%0)
	LD	A,(IY+%3)
	LD	(_xNextTaskUnblockTime),BC
	LD	(_xNextTaskUnblockTime+3),A
; 4123	    }
; 4124	}
L_466:
.LINE 4124

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvResetNextTaskUnblockTime ***************************
;Name                         Addr/Register   Size   Type
;_xNextTaskUnblockTime               STATIC      4   variable
;_pxDelayedTaskList                  STATIC      3   variable
;temp460                               IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prvResetNextTaskUnblockTime",4124,"_prvResetNextTaskUnblockTime"
; 4125	/*-----------------------------------------------------------*/
; 4126	
; 4127	#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
; 4128	
; 4129	    TaskHandle_t xTaskGetCurrentTaskHandle( void )
; 4130	    {
_xTaskGetCurrentTaskHandle:
.DEFINE "_xTaskGetCurrentTaskHandle"

.VALUE _xTaskGetCurrentTaskHandle

.CLASS 2

.TAG "tskTaskControlBlock"

.TYPE 328

.ENDEF

.BEGFUNC "xTaskGetCurrentTaskHandle",4130,"_xTaskGetCurrentTaskHandle"

.LINE 4130

.DEFINE "xReturn"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
; 4131	        TaskHandle_t xReturn;
; 4132	
; 4133	        /* A critical section is not required as this is not called from
; 4134	         * an interrupt and the current TCB will always be the same for any
; 4135	         * individual execution thread. */
; 4136	        xReturn = pxCurrentTCB;
.LINE 4136

	LD	BC,(_pxCurrentTCB)
	LD	(IX+%FFFFFFFD),BC
; 4137	
; 4138	        return xReturn;
.LINE 4138

	LD	HL,(IX+%FFFFFFFD)
; 4139	    }
.LINE 4139

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskGetCurrentTaskHandle ***************************
;Name                         Addr/Register   Size   Type
;_pxCurrentTCB                       STATIC      3   variable
;xReturn                               IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskGetCurrentTaskHandle",4139,"_xTaskGetCurrentTaskHandle"
; 4140	
; 4141	#endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
; 4142	/*-----------------------------------------------------------*/
; 4143	
; 4144	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
; 4145	
; 4146	    BaseType_t xTaskGetSchedulerState( void )
; 4147	    {
_xTaskGetSchedulerState:
.DEFINE "_xTaskGetSchedulerState"

.VALUE _xTaskGetSchedulerState

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xTaskGetSchedulerState",4147,"_xTaskGetSchedulerState"

.LINE 4147

.DEFINE "xReturn"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
; 4148	        BaseType_t xReturn;
; 4149	
; 4150	        if( xSchedulerRunning == pdFALSE )
.LINE 4150

	LD	HL,(_xSchedulerRunning)
	CALL	__icmpzero
	JR	NZ,L_471
; 4151	        {
; 4152	            xReturn = taskSCHEDULER_NOT_STARTED;
.LINE 4152

	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
; 4153	        }
; 4154	        else
.LINE 4154

	JR	L_472
L_471:
; 4155	        {
; 4156	            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
.LINE 4156

	LD	HL,(_uxSchedulerSuspended)
	CALL	__icmpzero
	JR	NZ,L_469
; 4157	            {
; 4158	                xReturn = taskSCHEDULER_RUNNING;
.LINE 4158

	LD	BC,2
	LD	(IX+%FFFFFFFD),BC
; 4159	            }
; 4160	            else
.LINE 4160

	JR	L_472
L_469:
; 4161	            {
; 4162	                xReturn = taskSCHEDULER_SUSPENDED;
.LINE 4162

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 4163	            }
; 4164	        }
L_472:
.LINE 4164

; 4165	
; 4166	        return xReturn;
.LINE 4166

	LD	HL,(IX+%FFFFFFFD)
; 4167	    }
.LINE 4167

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskGetSchedulerState ***************************
;Name                         Addr/Register   Size   Type
;_uxSchedulerSuspended               STATIC      3   variable
;_xSchedulerRunning                  STATIC      3   variable
;xReturn                               IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskGetSchedulerState",4167,"_xTaskGetSchedulerState"
; 4168	
; 4169	#endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
; 4170	/*-----------------------------------------------------------*/
; 4171	
; 4172	#if ( configUSE_MUTEXES == 1 )
; 4173	
; 4174	    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
; 4175	    {
_xTaskPriorityInherit:
.DEFINE "_xTaskPriorityInherit"

.VALUE _xTaskPriorityInherit

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xTaskPriorityInherit",4175,"_xTaskPriorityInherit"

.LINE 4175

.DEFINE "pxMutexHolder"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxMutexHolderTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -6

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -9

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF4
	LD	SP,HL
; 4176	        TCB_t * const pxMutexHolderTCB = pxMutexHolder;
.LINE 4176

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 4177	        BaseType_t xReturn = pdFALSE;
.LINE 4177

	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
; 4178	
; 4179	        /* If the mutex was given back by an interrupt while the queue was
; 4180	         * locked then the mutex holder might now be NULL.  _RB_ Is this still
; 4181	         * needed as interrupts can no longer use mutexes? */
; 4182	        if( pxMutexHolder != NULL )
.LINE 4182

	LD	HL,(IX+%6)
	CALL	__icmpzero
	JR	Z,L_495
; 4183	        {
; 4184	            /* If the holder of the mutex has a priority below the priority of
; 4185	             * the task attempting to obtain the mutex then it will temporarily
; 4186	             * inherit the priority of the task attempting to obtain the mutex. */
; 4187	            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
.LINE 4187

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IY+%23)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_493
; 4188	            {
; 4189	                /* Adjust the mutex holder state to account for its new
; 4190	                 * priority.  Only reset the event list item value if the value is
; 4191	                 * not being used for anything else. */
; 4192	                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
.LINE 4192

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%13)
	LD	E,(IY+%16)
	LD	BC,0
	LD	A,%80
	CALL	__land
	CALL	__lcmpzero
	JR	NZ,L_475
; 4193	                {
; 4194	                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
.LINE 4194

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IY+%23)
	XOR	A,A
	LD	HL,5
	LD	E,%0
	CALL	__lsub
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%13),HL
	LD	(IY+%16),E
; 4195	                }
; 4196	                else
L_475:
.LINE 4196

; 4197	                {
; 4198	                    mtCOVERAGE_TEST_MARKER();
; 4199	                }
; 4200	
; 4201	                /* If the task being modified is in the ready state it will need
; 4202	                 * to be moved into a new list. */
; 4203	                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
.LINE 4203

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	BC,(IY+%10)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_478
	LD	BC,1
	LD	(IX+%FFFFFFF4),BC
	JR	L_479
L_478:
	LD	BC,0
	LD	(IX+%FFFFFFF4),BC
L_479:
	LD	HL,(IX+%FFFFFFF4)
	CALL	__icmpzero
	JR	Z,L_487
; 4204	                {
; 4205	                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
.LINE 4205

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%3
	CALL	_uxListRemove
	POP	BC
	CALL	__icmpzero
; 4206	                    {
; 4207	                        /* It is known that the task is in its ready list so
; 4208	                         * there is no need to check again and the port level
; 4209	                         * reset macro can be called directly. */
; 4210	                        portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
; 4211	                    }
; 4212	                    else
.LINE 4212

; 4213	                    {
; 4214	                        mtCOVERAGE_TEST_MARKER();
; 4215	                    }
; 4216	
; 4217	                    /* Inherit the priority before being moved into the new list. */
; 4218	                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
.LINE 4218

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IY+%23)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%23),BC
; 4219	                    prvAddTaskToReadyList( pxMutexHolderTCB );
.LINE 4219

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,(_uxTopReadyPriority)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_484
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	(_uxTopReadyPriority),BC
L_484:
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFFA),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%A),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	DE,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,DE
	LD	(IY+%4),BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	(IY+%10),HL
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,_pxReadyTasksLists
	ADD	HL,DE
	LD	IY,BC
	LD	BC,(IY+%0)
	INC	BC
	LD	IY,HL
	LD	(IY+%0),BC
; 4220	                }
; 4221	                else
.LINE 4221

	JR	L_489
L_487:
; 4222	                {
; 4223	                    /* Just inherit the priority. */
; 4224	                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
.LINE 4224

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IY+%23)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%23),BC
; 4225	                }
L_489:
.LINE 4225

; 4226	
; 4227	                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
; 4228	
; 4229	                /* Inheritance occurred. */
; 4230	                xReturn = pdTRUE;
.LINE 4230

	LD	BC,1
	LD	(IX+%FFFFFFF7),BC
; 4231	            }
; 4232	            else
.LINE 4232

	JR	L_496
L_493:
; 4233	            {
; 4234	                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
.LINE 4234

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IY+%23)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%39)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_491
; 4235	                {
; 4236	                    /* The base priority of the mutex holder is lower than the
; 4237	                     * priority of the task attempting to take the mutex, but the
; 4238	                     * current priority of the mutex holder is not lower than the
; 4239	                     * priority of the task attempting to take the mutex.
; 4240	                     * Therefore the mutex holder must have already inherited a
; 4241	                     * priority, but inheritance would have occurred if that had
; 4242	                     * not been the case. */
; 4243	                    xReturn = pdTRUE;
.LINE 4243

	LD	BC,1
	LD	(IX+%FFFFFFF7),BC
; 4244	                }
; 4245	                else
L_491:
.LINE 4245

; 4246	                {
; 4247	                    mtCOVERAGE_TEST_MARKER();
; 4248	                }
; 4249	            }
; 4250	        }
; 4251	        else
L_495:
.LINE 4251

; 4252	        {
; 4253	            mtCOVERAGE_TEST_MARKER();
; 4254	        }
L_496:
.LINE 4254

; 4255	
; 4256	        return xReturn;
.LINE 4256

	LD	HL,(IX+%FFFFFFF7)
; 4257	    }
.LINE 4257

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskPriorityInherit ***************************
;Name                         Addr/Register   Size   Type
;_uxTopReadyPriority                 STATIC      3   variable
;_uxListRemove                       IMPORT  -----   function
;_pxReadyTasksLists                  STATIC     80   variable
;_pxCurrentTCB                       STATIC      3   variable
;temp476                              IX-12      3   variable
;xReturn                               IX-9      3   variable
;pxIndex                               IX-6      3   variable
;pxMutexHolderTCB                      IX-3      3   variable
;pxMutexHolder                         IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskPriorityInherit",4257,"_xTaskPriorityInherit"
; 4258	
; 4259	#endif /* configUSE_MUTEXES */
; 4260	/*-----------------------------------------------------------*/
; 4261	
; 4262	#if ( configUSE_MUTEXES == 1 )
; 4263	
; 4264	    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
; 4265	    {
_xTaskPriorityDisinherit:
.DEFINE "_xTaskPriorityDisinherit"

.VALUE _xTaskPriorityDisinherit

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xTaskPriorityDisinherit",4265,"_xTaskPriorityDisinherit"

.LINE 4265

.DEFINE "pxMutexHolder"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -6

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -9

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
; 4266	        TCB_t * const pxTCB = pxMutexHolder;
.LINE 4266

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 4267	        BaseType_t xReturn = pdFALSE;
.LINE 4267

	LD	BC,0
	LD	(IX+%FFFFFFF7),BC
; 4268	
; 4269	        if( pxMutexHolder != NULL )
.LINE 4269

	LD	HL,(IX+%6)
	CALL	__icmpzero
	JR	Z,L_510
; 4270	        {
; 4271	            /* A task can only have an inherited priority if it holds the mutex.
; 4272	             * If the mutex is held by a task then it cannot be given from an
; 4273	             * interrupt, and if a mutex is given by the holding task then it must
; 4274	             * be the running state task. */
; 4275	            configASSERT( pxTCB == pxCurrentTCB );
; 4276	            configASSERT( pxTCB->uxMutexesHeld );
; 4277	            ( pxTCB->uxMutexesHeld )--;
.LINE 4277

	LD	IY,(IX+%FFFFFFFD)
	LD	IY,(IY+%3C)
	LEA	BC,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%3C),BC
; 4278	
; 4279	            /* Has the holder of the mutex inherited the priority of another
; 4280	             * task? */
; 4281	            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
.LINE 4281

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%39)
	LD	HL,(IY+%23)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_508
; 4282	            {
; 4283	                /* Only disinherit if no other mutexes are held. */
; 4284	                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
.LINE 4284

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%3C)
	CALL	__icmpzero
	JR	NZ,L_506
; 4285	                {
; 4286	                    /* A task can only have an inherited priority if it holds
; 4287	                     * the mutex.  If the mutex is held by a task then it cannot be
; 4288	                     * given from an interrupt, and if a mutex is given by the
; 4289	                     * holding task then it must be the running state task.  Remove
; 4290	                     * the holding task from the ready list. */
; 4291	                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
.LINE 4291

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%3
	CALL	_uxListRemove
	POP	BC
	CALL	__icmpzero
; 4292	                    {
; 4293	                        portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
; 4294	                    }
; 4295	                    else
.LINE 4295

; 4296	                    {
; 4297	                        mtCOVERAGE_TEST_MARKER();
; 4298	                    }
; 4299	
; 4300	                    /* Disinherit the priority before adding the task into the
; 4301	                     * new  ready list. */
; 4302	                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
; 4303	                    pxTCB->uxPriority = pxTCB->uxBasePriority;
.LINE 4303

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%39)
	LD	(IY+%23),BC
; 4304	
; 4305	                    /* Reset the event list item value.  It cannot be in use for
; 4306	                     * any other purpose if this task is running, and it must be
; 4307	                     * running to give back the mutex. */
; 4308	                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
.LINE 4308

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	XOR	A,A
	LD	HL,5
	LD	E,%0
	CALL	__lsub
	LD	(IY+%13),HL
	LD	(IY+%16),E
; 4309	                    prvAddTaskToReadyList( pxTCB );
.LINE 4309

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,(_uxTopReadyPriority)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_503
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	(_uxTopReadyPriority),BC
L_503:
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFFA),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%A),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	DE,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,DE
	LD	(IY+%4),BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	(IY+%10),HL
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,_pxReadyTasksLists
	ADD	HL,DE
	LD	IY,BC
	LD	BC,(IY+%0)
	INC	BC
	LD	IY,HL
	LD	(IY+%0),BC
; 4310	
; 4311	                    /* Return true to indicate that a context switch is required.
; 4312	                     * This is only actually required in the corner case whereby
; 4313	                     * multiple mutexes were held and the mutexes were given back
; 4314	                     * in an order different to that in which they were taken.
; 4315	                     * If a context switch did not occur when the first mutex was
; 4316	                     * returned, even if a task was waiting on it, then a context
; 4317	                     * switch should occur when the last mutex is returned whether
; 4318	                     * a task is waiting on it or not. */
; 4319	                    xReturn = pdTRUE;
.LINE 4319

	LD	BC,1
	LD	(IX+%FFFFFFF7),BC
; 4320	                }
; 4321	                else
L_506:
.LINE 4321

; 4322	                {
; 4323	                    mtCOVERAGE_TEST_MARKER();
; 4324	                }
; 4325	            }
; 4326	            else
L_508:
.LINE 4326

; 4327	            {
; 4328	                mtCOVERAGE_TEST_MARKER();
; 4329	            }
; 4330	        }
; 4331	        else
L_510:
.LINE 4331

; 4332	        {
; 4333	            mtCOVERAGE_TEST_MARKER();
; 4334	        }
; 4335	
; 4336	        return xReturn;
.LINE 4336

	LD	HL,(IX+%FFFFFFF7)
; 4337	    }
.LINE 4337

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskPriorityDisinherit ***************************
;Name                         Addr/Register   Size   Type
;_pxReadyTasksLists                  STATIC     80   variable
;_uxTopReadyPriority                 STATIC      3   variable
;_uxListRemove                       IMPORT  -----   function
;xReturn                               IX-9      3   variable
;pxIndex                               IX-6      3   variable
;pxTCB                                 IX-3      3   variable
;pxMutexHolder                         IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskPriorityDisinherit",4337,"_xTaskPriorityDisinherit"
; 4338	
; 4339	#endif /* configUSE_MUTEXES */
; 4340	/*-----------------------------------------------------------*/
; 4341	
; 4342	#if ( configUSE_MUTEXES == 1 )
; 4343	
; 4344	    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
; 4345	                                              UBaseType_t uxHighestPriorityWaitingTask )
; 4346	    {
_vTaskPriorityDisinheritAfterTimeout:
.DEFINE "_vTaskPriorityDisinheritAfterTimeout"

.VALUE _vTaskPriorityDisinheritAfterTimeout

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vTaskPriorityDisinheritAfterTimeout",4346,"_vTaskPriorityDisinheritAfterTimeout"

.LINE 4346

.DEFINE "pxMutexHolder"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "uxHighestPriorityWaitingTask"

.CLASS 65

.VALUE 9

.TYPE 14

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "uxPriorityToUse"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -9

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

.DEFINE "uxOnlyOneMutexHeld"

.CLASS 65

.VALUE -15

.TYPE 14

.ENDEF

.DEFINE "uxPriorityUsedOnEntry"

.CLASS 65

.VALUE -18

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEE
	LD	SP,HL
; 4347	        TCB_t * const pxTCB = pxMutexHolder;
.LINE 4347

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 4348	        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
; 4349	        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
.LINE 4349

	LD	BC,1
	LD	(IX+%FFFFFFF1),BC
; 4350	
; 4351	        if( pxMutexHolder != NULL )
.LINE 4351

	LD	HL,(IX+%6)
	CALL	__icmpzero
	JR	Z,L_536
; 4352	        {
; 4353	            /* If pxMutexHolder is not NULL then the holder must hold at least
; 4354	             * one mutex. */
; 4355	            configASSERT( pxTCB->uxMutexesHeld );
; 4356	
; 4357	            /* Determine the priority to which the priority of the task that
; 4358	             * holds the mutex should be set.  This will be the greater of the
; 4359	             * holding task's base priority and the priority of the highest
; 4360	             * priority task that is waiting to obtain the mutex. */
; 4361	            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
.LINE 4361

	LD	BC,(IX+%9)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%39)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_514
; 4362	            {
; 4363	                uxPriorityToUse = uxHighestPriorityWaitingTask;
.LINE 4363

	LD	BC,(IX+%9)
	LD	(IX+%FFFFFFFA),BC
; 4364	            }
; 4365	            else
.LINE 4365

	JR	L_534
L_514:
; 4366	            {
; 4367	                uxPriorityToUse = pxTCB->uxBasePriority;
.LINE 4367

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%39)
	LD	(IX+%FFFFFFFA),BC
; 4368	            }
L_534:
.LINE 4368

; 4369	
; 4370	            /* Does the priority need to change? */
; 4371	            if( pxTCB->uxPriority != uxPriorityToUse )
.LINE 4371

	LD	BC,(IX+%FFFFFFFA)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_533
; 4372	            {
; 4373	                /* Only disinherit if no other mutexes are held.  This is a
; 4374	                 * simplification in the priority inheritance implementation.  If
; 4375	                 * the task that holds the mutex is also holding other mutexes then
; 4376	                 * the other mutexes may have caused the priority inheritance. */
; 4377	                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
.LINE 4377

	LD	BC,(IX+%FFFFFFF1)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%3C)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_531
; 4378	                {
; 4379	                    /* If a task has timed out because it already holds the
; 4380	                     * mutex it was trying to obtain then it cannot of inherited
; 4381	                     * its own priority. */
; 4382	                    configASSERT( pxTCB != pxCurrentTCB );
; 4383	
; 4384	                    /* Disinherit the priority, remembering the previous
; 4385	                     * priority to facilitate determining the subject task's
; 4386	                     * state. */
; 4387	                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
; 4388	                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
.LINE 4388

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	(IX+%FFFFFFEE),BC
; 4389	                    pxTCB->uxPriority = uxPriorityToUse;
.LINE 4389

	LD	BC,(IX+%FFFFFFFA)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%23),BC
; 4390	
; 4391	                    /* Only reset the event list item value if the value is not
; 4392	                     * being used for anything else. */
; 4393	                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
.LINE 4393

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%13)
	LD	E,(IY+%16)
	LD	BC,0
	LD	A,%80
	CALL	__land
	CALL	__lcmpzero
	JR	NZ,L_516
; 4394	                    {
; 4395	                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
.LINE 4395

	LD	BC,(IX+%FFFFFFFA)
	XOR	A,A
	LD	HL,5
	LD	E,%0
	CALL	__lsub
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%13),HL
	LD	(IY+%16),E
; 4396	                    }
; 4397	                    else
L_516:
.LINE 4397

; 4398	                    {
; 4399	                        mtCOVERAGE_TEST_MARKER();
; 4400	                    }
; 4401	
; 4402	                    /* If the running task is not the task that holds the mutex
; 4403	                     * then the task that holds the mutex could be in either the
; 4404	                     * Ready, Blocked or Suspended states.  Only remove the task
; 4405	                     * from its current state list if it is in the Ready state as
; 4406	                     * the task's priority is going to change and there is one
; 4407	                     * Ready list per priority. */
; 4408	                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
.LINE 4408

	LD	HL,(IX+%FFFFFFEE)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%10)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_519
	LD	BC,1
	LD	(IX+%FFFFFFF4),BC
	JR	L_520
L_519:
	LD	BC,0
	LD	(IX+%FFFFFFF4),BC
L_520:
	LD	HL,(IX+%FFFFFFF4)
	CALL	__icmpzero
	JR	Z,L_528
; 4409	                    {
; 4410	                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
.LINE 4410

	LD	IY,(IX+%FFFFFFFD)
	PEA	IY+%3
	CALL	_uxListRemove
	POP	BC
	CALL	__icmpzero
; 4411	                        {
; 4412	                            /* It is known that the task is in its ready list so
; 4413	                             * there is no need to check again and the port level
; 4414	                             * reset macro can be called directly. */
; 4415	                            portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
; 4416	                        }
; 4417	                        else
.LINE 4417

; 4418	                        {
; 4419	                            mtCOVERAGE_TEST_MARKER();
; 4420	                        }
; 4421	
; 4422	                        prvAddTaskToReadyList( pxTCB );
.LINE 4422

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,(_uxTopReadyPriority)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_525
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	(_uxTopReadyPriority),BC
L_525:
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFF7),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFF7)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%A),BC
	LD	IY,(IX+%FFFFFFF7)
	LD	DE,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,DE
	LD	(IY+%4),BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,(IX+%FFFFFFF7)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	(IY+%10),HL
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,_pxReadyTasksLists
	ADD	HL,DE
	LD	IY,BC
	LD	BC,(IY+%0)
	INC	BC
	LD	IY,HL
	LD	(IY+%0),BC
; 4423	                    }
; 4424	                    else
L_528:
.LINE 4424

; 4425	                    {
; 4426	                        mtCOVERAGE_TEST_MARKER();
; 4427	                    }
; 4428	                }
; 4429	                else
L_531:
.LINE 4429

; 4430	                {
; 4431	                    mtCOVERAGE_TEST_MARKER();
; 4432	                }
; 4433	            }
; 4434	            else
L_533:
.LINE 4434

; 4435	            {
; 4436	                mtCOVERAGE_TEST_MARKER();
; 4437	            }
; 4438	        }
; 4439	        else
L_536:
.LINE 4439

; 4440	        {
; 4441	            mtCOVERAGE_TEST_MARKER();
; 4442	        }
; 4443	    }
.LINE 4443

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vTaskPriorityDisinheritAfterTimeout ***************************
;Name                         Addr/Register   Size   Type
;_uxTopReadyPriority                 STATIC      3   variable
;_uxListRemove                       IMPORT  -----   function
;_pxReadyTasksLists                  STATIC     80   variable
;uxPriorityUsedOnEntry                IX-18      3   variable
;uxOnlyOneMutexHeld                   IX-15      3   variable
;temp517                              IX-12      3   variable
;pxIndex                               IX-9      3   variable
;uxPriorityToUse                       IX-6      3   variable
;pxTCB                                 IX-3      3   variable
;uxHighestPriorityWaitingTask          IX+9      3   parameter
;pxMutexHolder                         IX+6      3   parameter


; Stack Frame Size: 30 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vTaskPriorityDisinheritAfterTimeout",4443,"_vTaskPriorityDisinheritAfterTimeout"
; 4444	
; 4445	#endif /* configUSE_MUTEXES */
; 4446	/*-----------------------------------------------------------*/
; 4447	
; 4448	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
; 4449	
; 4450	    void vTaskEnterCritical( void )
; 4451	    {
; 4452	        portDISABLE_INTERRUPTS();
; 4453	
; 4454	        if( xSchedulerRunning != pdFALSE )
; 4455	        {
; 4456	            ( pxCurrentTCB->uxCriticalNesting )++;
; 4457	
; 4458	            /* This is not the interrupt safe version of the enter critical
; 4459	             * function so  assert() if it is being called from an interrupt
; 4460	             * context.  Only API functions that end in "FromISR" can be used in an
; 4461	             * interrupt.  Only assert if the critical nesting count is 1 to
; 4462	             * protect against recursive calls if the assert function also uses a
; 4463	             * critical section. */
; 4464	            if( pxCurrentTCB->uxCriticalNesting == 1 )
; 4465	            {
; 4466	                portASSERT_IF_IN_ISR();
; 4467	            }
; 4468	        }
; 4469	        else
; 4470	        {
; 4471	            mtCOVERAGE_TEST_MARKER();
; 4472	        }
; 4473	    }
; 4474	
; 4475	#endif /* portCRITICAL_NESTING_IN_TCB */
; 4476	/*-----------------------------------------------------------*/
; 4477	
; 4478	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
; 4479	
; 4480	    void vTaskExitCritical( void )
; 4481	    {
; 4482	        if( xSchedulerRunning != pdFALSE )
; 4483	        {
; 4484	            if( pxCurrentTCB->uxCriticalNesting > 0U )
; 4485	            {
; 4486	                ( pxCurrentTCB->uxCriticalNesting )--;
; 4487	
; 4488	                if( pxCurrentTCB->uxCriticalNesting == 0U )
; 4489	                {
; 4490	                    portENABLE_INTERRUPTS();
; 4491	                }
; 4492	                else
; 4493	                {
; 4494	                    mtCOVERAGE_TEST_MARKER();
; 4495	                }
; 4496	            }
; 4497	            else
; 4498	            {
; 4499	                mtCOVERAGE_TEST_MARKER();
; 4500	            }
; 4501	        }
; 4502	        else
; 4503	        {
; 4504	            mtCOVERAGE_TEST_MARKER();
; 4505	        }
; 4506	    }
; 4507	
; 4508	#endif /* portCRITICAL_NESTING_IN_TCB */
; 4509	/*-----------------------------------------------------------*/
; 4510	
; 4511	#if ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 )
; 4512	
; 4513	    static char * prvWriteNameToBuffer( char * pcBuffer,
; 4514	                                        const char * pcTaskName )
; 4515	    {
; 4516	        size_t x;
; 4517	
; 4518	        /* Start by copying the entire string. */
; 4519	        strcpy( pcBuffer, pcTaskName );
; 4520	
; 4521	        /* Pad the end of the string with spaces to ensure columns line up when
; 4522	         * printed out. */
; 4523	        for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
; 4524	        {
; 4525	            pcBuffer[ x ] = ' ';
; 4526	        }
; 4527	
; 4528	        /* Terminate. */
; 4529	        pcBuffer[ x ] = ( char ) 0x00;
; 4530	
; 4531	        /* Return the new end of string. */
; 4532	        return &( pcBuffer[ x ] );
; 4533	    }
; 4534	
; 4535	#endif /* ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
; 4536	/*-----------------------------------------------------------*/
; 4537	
; 4538	#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
; 4539	
; 4540	    void vTaskList( char * pcWriteBuffer )
; 4541	    {
; 4542	        TaskStatus_t * pxTaskStatusArray;
; 4543	        UBaseType_t uxArraySize, x;
; 4544	        char cStatus;
; 4545	
; 4546	        /*
; 4547	         * PLEASE NOTE:
; 4548	         *
; 4549	         * This function is provided for convenience only, and is used by many
; 4550	         * of the demo applications.  Do not consider it to be part of the
; 4551	         * scheduler.
; 4552	         *
; 4553	         * vTaskList() calls uxTaskGetSystemState(), then formats part of the
; 4554	         * uxTaskGetSystemState() output into a human readable table that
; 4555	         * displays task: names, states, priority, stack usage and task number.
; 4556	         * Stack usage specified as the number of unused StackType_t words stack can hold
; 4557	         * on top of stack - not the number of bytes.
; 4558	         *
; 4559	         * vTaskList() has a dependency on the sprintf() C library function that
; 4560	         * might bloat the code size, use a lot of stack, and provide different
; 4561	         * results on different platforms.  An alternative, tiny, third party,
; 4562	         * and limited functionality implementation of sprintf() is provided in
; 4563	         * many of the FreeRTOS/Demo sub-directories in a file called
; 4564	         * printf-stdarg.c (note printf-stdarg.c does not provide a full
; 4565	         * snprintf() implementation!).
; 4566	         *
; 4567	         * It is recommended that production systems call uxTaskGetSystemState()
; 4568	         * directly to get access to raw stats data, rather than indirectly
; 4569	         * through a call to vTaskList().
; 4570	         */
; 4571	
; 4572	
; 4573	        /* Make sure the write buffer does not contain a string. */
; 4574	        *pcWriteBuffer = ( char ) 0x00;
; 4575	
; 4576	        /* Take a snapshot of the number of tasks in case it changes while this
; 4577	         * function is executing. */
; 4578	        uxArraySize = uxCurrentNumberOfTasks;
; 4579	
; 4580	        /* Allocate an array index for each task.  NOTE!  if
; 4581	         * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
; 4582	         * equate to NULL. */
; 4583	        pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
; 4584	
; 4585	        if( pxTaskStatusArray != NULL )
; 4586	        {
; 4587	            /* Generate the (binary) data. */
; 4588	            uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
; 4589	
; 4590	            /* Create a human readable table from the binary data. */
; 4591	            for( x = 0; x < uxArraySize; x++ )
; 4592	            {
; 4593	                switch( pxTaskStatusArray[ x ].eCurrentState )
; 4594	                {
; 4595	                    case eRunning:
; 4596	                        cStatus = tskRUNNING_CHAR;
; 4597	                        break;
; 4598	
; 4599	                    case eReady:
; 4600	                        cStatus = tskREADY_CHAR;
; 4601	                        break;
; 4602	
; 4603	                    case eBlocked:
; 4604	                        cStatus = tskBLOCKED_CHAR;
; 4605	                        break;
; 4606	
; 4607	                    case eSuspended:
; 4608	                        cStatus = tskSUSPENDED_CHAR;
; 4609	                        break;
; 4610	
; 4611	                    case eDeleted:
; 4612	                        cStatus = tskDELETED_CHAR;
; 4613	                        break;
; 4614	
; 4615	                    case eInvalid: /* Fall through. */
; 4616	                    default:       /* Should not get here, but it is included
; 4617	                                    * to prevent static checking errors. */
; 4618	                        cStatus = ( char ) 0x00;
; 4619	                        break;
; 4620	                }
; 4621	
; 4622	                /* Write the task name to the string, padding with spaces so it
; 4623	                 * can be printed in tabular form more easily. */
; 4624	                pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
; 4625	
; 4626	                /* Write the rest of the string. */
; 4627	                sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
; 4628	                pcWriteBuffer += strlen( pcWriteBuffer );                                                                                                                                                                                                /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
; 4629	            }
; 4630	
; 4631	            /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
; 4632	             * is 0 then vPortFree() will be #defined to nothing. */
; 4633	            vPortFree( pxTaskStatusArray );
; 4634	        }
; 4635	        else
; 4636	        {
; 4637	            mtCOVERAGE_TEST_MARKER();
; 4638	        }
; 4639	    }
; 4640	
; 4641	#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
; 4642	/*----------------------------------------------------------*/
; 4643	
; 4644	#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configUSE_TRACE_FACILITY == 1 ) )
; 4645	
; 4646	    void vTaskGetRunTimeStats( char * pcWriteBuffer )
; 4647	    {
; 4648	        TaskStatus_t * pxTaskStatusArray;
; 4649	        UBaseType_t uxArraySize, x;
; 4650	        configRUN_TIME_COUNTER_TYPE ulTotalTime, ulStatsAsPercentage;
; 4651	
; 4652	        /*
; 4653	         * PLEASE NOTE:
; 4654	         *
; 4655	         * This function is provided for convenience only, and is used by many
; 4656	         * of the demo applications.  Do not consider it to be part of the
; 4657	         * scheduler.
; 4658	         *
; 4659	         * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
; 4660	         * of the uxTaskGetSystemState() output into a human readable table that
; 4661	         * displays the amount of time each task has spent in the Running state
; 4662	         * in both absolute and percentage terms.
; 4663	         *
; 4664	         * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
; 4665	         * function that might bloat the code size, use a lot of stack, and
; 4666	         * provide different results on different platforms.  An alternative,
; 4667	         * tiny, third party, and limited functionality implementation of
; 4668	         * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
; 4669	         * a file called printf-stdarg.c (note printf-stdarg.c does not provide
; 4670	         * a full snprintf() implementation!).
; 4671	         *
; 4672	         * It is recommended that production systems call uxTaskGetSystemState()
; 4673	         * directly to get access to raw stats data, rather than indirectly
; 4674	         * through a call to vTaskGetRunTimeStats().
; 4675	         */
; 4676	
; 4677	        /* Make sure the write buffer does not contain a string. */
; 4678	        *pcWriteBuffer = ( char ) 0x00;
; 4679	
; 4680	        /* Take a snapshot of the number of tasks in case it changes while this
; 4681	         * function is executing. */
; 4682	        uxArraySize = uxCurrentNumberOfTasks;
; 4683	
; 4684	        /* Allocate an array index for each task.  NOTE!  If
; 4685	         * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
; 4686	         * equate to NULL. */
; 4687	        pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
; 4688	
; 4689	        if( pxTaskStatusArray != NULL )
; 4690	        {
; 4691	            /* Generate the (binary) data. */
; 4692	            uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
; 4693	
; 4694	            /* For percentage calculations. */
; 4695	            ulTotalTime /= 100UL;
; 4696	
; 4697	            /* Avoid divide by zero errors. */
; 4698	            if( ulTotalTime > 0UL )
; 4699	            {
; 4700	                /* Create a human readable table from the binary data. */
; 4701	                for( x = 0; x < uxArraySize; x++ )
; 4702	                {
; 4703	                    /* What percentage of the total run time has the task used?
; 4704	                     * This will always be rounded down to the nearest integer.
; 4705	                     * ulTotalRunTime has already been divided by 100. */
; 4706	                    ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
; 4707	
; 4708	                    /* Write the task name to the string, padding with
; 4709	                     * spaces so it can be printed in tabular form more
; 4710	                     * easily. */
; 4711	                    pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
; 4712	
; 4713	                    if( ulStatsAsPercentage > 0UL )
; 4714	                    {
; 4715	                        #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
; 4716	                        {
; 4717	                            sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
; 4718	                        }
; 4719	                        #else
; 4720	                        {
; 4721	                            /* sizeof( int ) == sizeof( long ) so a smaller
; 4722	                             * printf() library can be used. */
; 4723	                            sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
; 4724	                        }
; 4725	                        #endif
; 4726	                    }
; 4727	                    else
; 4728	                    {
; 4729	                        /* If the percentage is zero here then the task has
; 4730	                         * consumed less than 1% of the total run time. */
; 4731	                        #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
; 4732	                        {
; 4733	                            sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
; 4734	                        }
; 4735	                        #else
; 4736	                        {
; 4737	                            /* sizeof( int ) == sizeof( long ) so a smaller
; 4738	                             * printf() library can be used. */
; 4739	                            sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
; 4740	                        }
; 4741	                        #endif
; 4742	                    }
; 4743	
; 4744	                    pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
; 4745	                }
; 4746	            }
; 4747	            else
; 4748	            {
; 4749	                mtCOVERAGE_TEST_MARKER();
; 4750	            }
; 4751	
; 4752	            /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
; 4753	             * is 0 then vPortFree() will be #defined to nothing. */
; 4754	            vPortFree( pxTaskStatusArray );
; 4755	        }
; 4756	        else
; 4757	        {
; 4758	            mtCOVERAGE_TEST_MARKER();
; 4759	        }
; 4760	    }
; 4761	
; 4762	#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
; 4763	/*-----------------------------------------------------------*/
; 4764	
; 4765	TickType_t uxTaskResetEventItemValue( void )
; 4766	{
_uxTaskResetEventItemValue:
.DEFINE "_uxTaskResetEventItemValue"

.VALUE _uxTaskResetEventItemValue

.CLASS 2

.TYPE 79

.ENDEF

.BEGFUNC "uxTaskResetEventItemValue",4766,"_uxTaskResetEventItemValue"

.LINE 4766

.DEFINE "uxReturn"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
; 4767	    TickType_t uxReturn;
; 4768	
; 4769	    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
.LINE 4769

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IY+%13)
	LD	A,(IY+%16)
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
; 4770	
; 4771	    /* Reset the event list item to its normal value - so it can be used with
; 4772	     * queues and semaphores. */
; 4773	    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
.LINE 4773

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IY+%23)
	XOR	A,A
	LD	IY,(_pxCurrentTCB)
	LD	HL,5
	LD	E,%0
	CALL	__lsub
	LD	(IY+%13),HL
	LD	(IY+%16),E
; 4774	
; 4775	    return uxReturn;
.LINE 4775

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
; 4776	}
.LINE 4776

	LD	SP,IX
	POP	IX
	RET	


;**************************** _uxTaskResetEventItemValue ***************************
;Name                         Addr/Register   Size   Type
;_pxCurrentTCB                       STATIC      3   variable
;uxReturn                              IX-4      4   variable


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "uxTaskResetEventItemValue",4776,"_uxTaskResetEventItemValue"
; 4777	/*-----------------------------------------------------------*/
; 4778	
; 4779	#if ( configUSE_MUTEXES == 1 )
; 4780	
; 4781	    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
; 4782	    {
_pvTaskIncrementMutexHeldCount:
.DEFINE "_pvTaskIncrementMutexHeldCount"

.VALUE _pvTaskIncrementMutexHeldCount

.CLASS 2

.TAG "tskTaskControlBlock"

.TYPE 328

.ENDEF

.BEGFUNC "pvTaskIncrementMutexHeldCount",4782,"_pvTaskIncrementMutexHeldCount"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 4783	        /* If xSemaphoreCreateMutex() is called before any tasks have been created
; 4784	         * then pxCurrentTCB will be NULL. */
; 4785	        if( pxCurrentTCB != NULL )
.LINE 4785

	LD	HL,(_pxCurrentTCB)
	CALL	__icmpzero
	JR	Z,L_541
; 4786	        {
; 4787	            ( pxCurrentTCB->uxMutexesHeld )++;
.LINE 4787

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IY+%3C)
	LD	IY,(_pxCurrentTCB)
	LD	DE,(_pxCurrentTCB)
	LD	BC,(IY+%3C)
	INC	BC
	LD	IY,DE
	LD	(IY+%3C),BC
; 4788	        }
L_541:
.LINE 4788

; 4789	
; 4790	        return pxCurrentTCB;
.LINE 4790

	LD	HL,(_pxCurrentTCB)
; 4791	    }
.LINE 4791

	LD	SP,IX
	POP	IX
	RET	


;**************************** _pvTaskIncrementMutexHeldCount ***************************
;Name                         Addr/Register   Size   Type
;_pxCurrentTCB                       STATIC      3   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "pvTaskIncrementMutexHeldCount",4791,"_pvTaskIncrementMutexHeldCount"
; 4792	
; 4793	#endif /* configUSE_MUTEXES */
; 4794	/*-----------------------------------------------------------*/
; 4795	
; 4796	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
; 4797	
; 4798	    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
; 4799	                                      BaseType_t xClearCountOnExit,
; 4800	                                      TickType_t xTicksToWait )
; 4801	    {
_ulTaskGenericNotifyTake:
.DEFINE "_ulTaskGenericNotifyTake"

.VALUE _ulTaskGenericNotifyTake

.CLASS 2

.TYPE 79

.ENDEF

.BEGFUNC "ulTaskGenericNotifyTake",4801,"_ulTaskGenericNotifyTake"

.LINE 4801

.DEFINE "uxIndexToWait"

.CLASS 65

.VALUE 6

.TYPE 14

.ENDEF

.DEFINE "xClearCountOnExit"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

.DEFINE "xTicksToWait"

.CLASS 65

.VALUE 12

.TYPE 15

.ENDEF

.DEFINE "ulReturn"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
; 4802	        uint32_t ulReturn;
; 4803	
; 4804	        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
; 4805	
; 4806	        taskENTER_CRITICAL();
.LINE 4806

	 di
; 4807	        {
; 4808	            /* Only block if the notification count is not already non-zero. */
; 4809	            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
.LINE 4809

	LD	IY,(_pxCurrentTCB)
	LD	HL,(IX+%6)
	ADD	HL,HL
	ADD	HL,HL
	LEA	BC,IY+%3F
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IY)
	LD	E,(IY+%3)
	CALL	__lcmpzero
	JR	NZ,L_546
; 4810	            {
; 4811	                /* Mark this task as waiting for a notification. */
; 4812	                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
.LINE 4812

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IX+%6)
	LEA	HL,IY+%43
	ADD	HL,BC
	LD	IY,HL
	LD	(HL),%1
; 4813	
; 4814	                if( xTicksToWait > ( TickType_t ) 0 )
.LINE 4814

	OR	A,A
	SBC	HL,HL
	LD	E,%0
	LD	BC,(IX+%C)
	LD	A,(IX+%F)
	CALL	__lcmpu
	JR	NC,L_544
; 4815	                {
; 4816	                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
.LINE 4816

	LD	BC,1
	PUSH	BC
	LD	C,(IX+%F)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%C)
	PUSH	BC
	CALL	_prvAddCurrentTaskToDelayedList
	POP	BC
	POP	BC
	POP	BC
; 4817	                    traceTASK_NOTIFY_TAKE_BLOCK( uxIndexToWait );
; 4818	
; 4819	                    /* All ports are written to allow a yield in a critical
; 4820	                     * section (some will yield immediately, others wait until the
; 4821	                     * critical section exits) - but it is not something that
; 4822	                     * application code should ever do. */
; 4823	                    portYIELD_WITHIN_API();
.LINE 4823

	CALL	_vPortYield
; 4824	                }
; 4825	                else
L_544:
.LINE 4825

; 4826	                {
; 4827	                    mtCOVERAGE_TEST_MARKER();
; 4828	                }
; 4829	            }
; 4830	            else
L_546:
.LINE 4830

; 4831	            {
; 4832	                mtCOVERAGE_TEST_MARKER();
; 4833	            }
; 4834	        }
; 4835	        taskEXIT_CRITICAL();
.LINE 4835

	 ei
; 4836	
; 4837	        taskENTER_CRITICAL();
.LINE 4837

	 di
; 4838	        {
; 4839	            traceTASK_NOTIFY_TAKE( uxIndexToWait );
; 4840	            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
.LINE 4840

	LD	IY,(_pxCurrentTCB)
	LD	HL,(IX+%6)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LEA	HL,IY+%3F
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
; 4841	
; 4842	            if( ulReturn != 0UL )
.LINE 4842

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	CALL	__lcmpzero
	JR	Z,L_551
; 4843	            {
; 4844	                if( xClearCountOnExit != pdFALSE )
.LINE 4844

	LD	HL,(IX+%9)
	CALL	__icmpzero
	JR	Z,L_549
; 4845	                {
; 4846	                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
.LINE 4846

	LD	IY,(_pxCurrentTCB)
	LD	HL,(IX+%6)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LEA	HL,IY+%3F
	ADD	HL,BC
	LD	BC,0
	LD	IY,HL
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),%0
; 4847	                }
; 4848	                else
.LINE 4848

	JR	L_552
L_549:
; 4849	                {
; 4850	                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
.LINE 4850

	LD	IY,(_pxCurrentTCB)
	LD	HL,(IX+%6)
	ADD	HL,HL
	ADD	HL,HL
	LEA	BC,IY+%3F
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,1
	XOR	A,A
	CALL	__lsub
	LD	(IY),HL
	LD	(IY+%3),E
; 4851	                }
; 4852	            }
; 4853	            else
L_551:
.LINE 4853

; 4854	            {
; 4855	                mtCOVERAGE_TEST_MARKER();
; 4856	            }
L_552:
.LINE 4856

; 4857	
; 4858	            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
.LINE 4858

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IX+%6)
	LEA	HL,IY+%43
	ADD	HL,BC
	LD	IY,HL
	LD	(HL),%0
; 4859	        }
; 4860	        taskEXIT_CRITICAL();
.LINE 4860

	 ei
; 4861	
; 4862	        return ulReturn;
.LINE 4862

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
; 4863	    }
.LINE 4863

	LD	SP,IX
	POP	IX
	RET	


;**************************** _ulTaskGenericNotifyTake ***************************
;Name                         Addr/Register   Size   Type
;_vPortYield                         IMPORT  -----   function
;_prvAddCurrentTaskToDelayedList      IMPORT  -----   function
;_pxCurrentTCB                       STATIC      3   variable
;ulReturn                              IX-4      4   variable
;xTicksToWait                         IX+12      4   parameter
;xClearCountOnExit                     IX+9      3   parameter
;uxIndexToWait                         IX+6      3   parameter


; Stack Frame Size: 22 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "ulTaskGenericNotifyTake",4863,"_ulTaskGenericNotifyTake"
; 4864	
; 4865	#endif /* configUSE_TASK_NOTIFICATIONS */
; 4866	/*-----------------------------------------------------------*/
; 4867	
; 4868	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
; 4869	
; 4870	    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
; 4871	                                       uint32_t ulBitsToClearOnEntry,
; 4872	                                       uint32_t ulBitsToClearOnExit,
; 4873	                                       uint32_t * pulNotificationValue,
; 4874	                                       TickType_t xTicksToWait )
; 4875	    {
_xTaskGenericNotifyWait:
.DEFINE "_xTaskGenericNotifyWait"

.VALUE _xTaskGenericNotifyWait

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xTaskGenericNotifyWait",4875,"_xTaskGenericNotifyWait"

.LINE 4875

.DEFINE "uxIndexToWait"

.CLASS 65

.VALUE 6

.TYPE 14

.ENDEF

.DEFINE "ulBitsToClearOnEntry"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "ulBitsToClearOnExit"

.CLASS 65

.VALUE 15

.TYPE 15

.ENDEF

.DEFINE "pulNotificationValue"

.CLASS 65

.VALUE 21

.TYPE 47

.ENDEF

.DEFINE "xTicksToWait"

.CLASS 65

.VALUE 24

.TYPE 15

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEE
	LD	SP,HL
; 4876	        BaseType_t xReturn;
; 4877	
; 4878	        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
; 4879	
; 4880	        taskENTER_CRITICAL();
.LINE 4880

	 di
; 4881	        {
; 4882	            /* Only block if a notification is not already pending. */
; 4883	            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
.LINE 4883

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IX+%6)
	LEA	HL,IY+%43
	ADD	HL,BC
	LD	IY,HL
	LD	A,(HL)
	CP	A,%2
	JR	Z,L_557
; 4884	            {
; 4885	                /* Clear bits in the task's notification value as bits may get
; 4886	                 * set  by the notifying task or interrupt.  This can be used to
; 4887	                 * clear the value to zero. */
; 4888	                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
.LINE 4888

	LD	IY,(_pxCurrentTCB)
	LD	HL,(IX+%6)
	ADD	HL,HL
	ADD	HL,HL
	LEA	BC,IY+%3F
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%9)
	LD	E,(IX+%C)
	CALL	__lnot
	LD	A,E
	LD	BC,HL
	LD	HL,(IY)
	LD	E,(IY+%3)
	CALL	__land
	LD	BC,HL
	LD	IY,(_pxCurrentTCB)
	LD	HL,(IX+%6)
	ADD	HL,HL
	ADD	HL,HL
	LD	(IX+%FFFFFFF4),BC	; spill
	LEA	BC,IY+%3F
	LD	(IX+%FFFFFFF1),BC	; spill
	LD	BC,(IX+%FFFFFFF4)	; unspill
	LD	(IX+%FFFFFFF4),BC	; spill
	LD	BC,(IX+%FFFFFFF1)	; unspill
	ADD	HL,BC
	LD	BC,(IX+%FFFFFFF4)	; unspill
	LD	IY,HL
	LD	(IY),BC
	LD	A,E
	LD	(IY+%3),E
; 4889	
; 4890	                /* Mark this task as waiting for a notification. */
; 4891	                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
.LINE 4891

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IX+%6)
	LEA	HL,IY+%43
	ADD	HL,BC
	LD	IY,HL
	LD	(HL),%1
; 4892	
; 4893	                if( xTicksToWait > ( TickType_t ) 0 )
.LINE 4893

	OR	A,A
	SBC	HL,HL
	LD	E,%0
	LD	BC,(IX+%18)
	LD	A,(IX+%1B)
	CALL	__lcmpu
	JR	NC,L_555
; 4894	                {
; 4895	                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
.LINE 4895

	LD	BC,1
	PUSH	BC
	LD	C,(IX+%1B)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%18)
	PUSH	BC
	CALL	_prvAddCurrentTaskToDelayedList
	POP	BC
	POP	BC
	POP	BC
; 4896	                    traceTASK_NOTIFY_WAIT_BLOCK( uxIndexToWait );
; 4897	
; 4898	                    /* All ports are written to allow a yield in a critical
; 4899	                     * section (some will yield immediately, others wait until the
; 4900	                     * critical section exits) - but it is not something that
; 4901	                     * application code should ever do. */
; 4902	                    portYIELD_WITHIN_API();
.LINE 4902

	CALL	_vPortYield
; 4903	                }
; 4904	                else
L_555:
.LINE 4904

; 4905	                {
; 4906	                    mtCOVERAGE_TEST_MARKER();
; 4907	                }
; 4908	            }
; 4909	            else
L_557:
.LINE 4909

; 4910	            {
; 4911	                mtCOVERAGE_TEST_MARKER();
; 4912	            }
; 4913	        }
; 4914	        taskEXIT_CRITICAL();
.LINE 4914

	 ei
; 4915	
; 4916	        taskENTER_CRITICAL();
.LINE 4916

	 di
; 4917	        {
; 4918	            traceTASK_NOTIFY_WAIT( uxIndexToWait );
; 4919	
; 4920	            if( pulNotificationValue != NULL )
.LINE 4920

	LD	HL,(IX+%15)
	CALL	__icmpzero
	JR	Z,L_562
; 4921	            {
; 4922	                /* Output the current notification value, which may or may not
; 4923	                 * have changed. */
; 4924	                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
.LINE 4924

	LD	IY,(_pxCurrentTCB)
	LD	HL,(IX+%6)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LEA	HL,IY+%3F
	ADD	HL,BC
	LD	IY,(IX+%15)
	LD	(IX+%FFFFFFEE),HL
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IY),BC
	LD	(IY+%3),A
; 4925	            }
L_562:
.LINE 4925

; 4926	
; 4927	            /* If ucNotifyValue is set then either the task never entered the
; 4928	             * blocked state (because a notification was already pending) or the
; 4929	             * task unblocked because of a notification.  Otherwise the task
; 4930	             * unblocked because of a timeout. */
; 4931	            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
.LINE 4931

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IX+%6)
	LEA	HL,IY+%43
	ADD	HL,BC
	LD	IY,HL
	LD	A,(HL)
	CP	A,%2
	JR	Z,L_561
; 4932	            {
; 4933	                /* A notification was not received. */
; 4934	                xReturn = pdFALSE;
.LINE 4934

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
; 4935	            }
; 4936	            else
.LINE 4936

	JR	L_563
L_561:
; 4937	            {
; 4938	                /* A notification was already pending or a notification was
; 4939	                 * received while the task was waiting. */
; 4940	                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
.LINE 4940

	LD	IY,(_pxCurrentTCB)
	LD	HL,(IX+%6)
	ADD	HL,HL
	ADD	HL,HL
	LEA	BC,IY+%3F
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%F)
	LD	E,(IX+%12)
	CALL	__lnot
	LD	A,E
	LD	BC,HL
	LD	HL,(IY)
	LD	E,(IY+%3)
	CALL	__land
	LD	(IX+%FFFFFFF7),HL	; spill
	LD	IY,(_pxCurrentTCB)
	LD	HL,(IX+%6)
	ADD	HL,HL
	ADD	HL,HL
	LEA	BC,IY+%3F
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%FFFFFFF7)	; unspill
	LD	(IY),HL
	LD	A,E
	LD	(IY+%3),E
; 4941	                xReturn = pdTRUE;
.LINE 4941

	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
; 4942	            }
L_563:
.LINE 4942

; 4943	
; 4944	            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
.LINE 4944

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IX+%6)
	LEA	HL,IY+%43
	ADD	HL,BC
	LD	IY,HL
	LD	(HL),%0
; 4945	        }
; 4946	        taskEXIT_CRITICAL();
.LINE 4946

	 ei
; 4947	
; 4948	        return xReturn;
.LINE 4948

	LD	HL,(IX+%FFFFFFFD)
; 4949	    }
.LINE 4949

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskGenericNotifyWait ***************************
;Name                         Addr/Register   Size   Type
;_vPortYield                         IMPORT  -----   function
;_prvAddCurrentTaskToDelayedList      IMPORT  -----   function
;_pxCurrentTCB                       STATIC      3   variable
;xReturn                               IX-3      3   variable
;xTicksToWait                         IX+24      4   parameter
;pulNotificationValue                 IX+21      3   parameter
;ulBitsToClearOnExit                  IX+15      4   parameter
;ulBitsToClearOnEntry                  IX+9      4   parameter
;uxIndexToWait                         IX+6      3   parameter


; Stack Frame Size: 48 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskGenericNotifyWait",4949,"_xTaskGenericNotifyWait"
; 4950	
; 4951	#endif /* configUSE_TASK_NOTIFICATIONS */
; 4952	/*-----------------------------------------------------------*/
; 4953	
; 4954	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
; 4955	
; 4956	    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
; 4957	                                   UBaseType_t uxIndexToNotify,
; 4958	                                   uint32_t ulValue,
; 4959	                                   eNotifyAction eAction,
; 4960	                                   uint32_t * pulPreviousNotificationValue )
; 4961	    {
_xTaskGenericNotify:
.DEFINE "_xTaskGenericNotify"

.VALUE _xTaskGenericNotify

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xTaskGenericNotify",4961,"_xTaskGenericNotify"

.LINE 4961

.DEFINE "xTaskToNotify"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "uxIndexToNotify"

.CLASS 65

.VALUE 9

.TYPE 14

.ENDEF

.DEFINE "ulValue"

.CLASS 65

.VALUE 12

.TYPE 15

.ENDEF

.DEFINE "eAction"

.CLASS 65

.VALUE 18

.TYPE 4

.ENDEF

.DEFINE "pulPreviousNotificationValue"

.CLASS 65

.VALUE 21

.TYPE 47

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxList"

.CLASS 65

.VALUE -6

.TAG "xLIST"

.TYPE 40

.ENDEF

.DEFINE "ucOriginalNotifyState"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -10

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -13

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE7
	LD	SP,HL
; 4962	        TCB_t * pxTCB;
; 4963	        BaseType_t xReturn = pdPASS;
.LINE 4963

	LD	BC,1
	LD	(IX+%FFFFFFF3),BC
; 4964	        uint8_t ucOriginalNotifyState;
; 4965	
; 4966	        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
; 4967	        configASSERT( xTaskToNotify );
; 4968	        pxTCB = xTaskToNotify;
.LINE 4968

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 4969	
; 4970	        taskENTER_CRITICAL();
.LINE 4970

	 di
; 4971	        {
; 4972	            if( pulPreviousNotificationValue != NULL )
.LINE 4972

	LD	HL,(IX+%15)
	CALL	__icmpzero
	JR	Z,L_566
; 4973	            {
; 4974	                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
.LINE 4974

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3F
	ADD	HL,BC
	LD	IY,(IX+%15)
	LD	(IX+%FFFFFFE7),HL
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IY),BC
	LD	(IY+%3),A
; 4975	            }
L_566:
.LINE 4975

; 4976	
; 4977	            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
.LINE 4977

	LD	BC,(IX+%9)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%43
	ADD	HL,BC
	LD	IY,HL
	LD	A,(HL)
	LD	(IX+%FFFFFFF9),A
; 4978	
; 4979	            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
.LINE 4979

	LD	BC,(IX+%9)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%43
	ADD	HL,BC
	LD	IY,HL
	LD	(HL),%2
; 4980	
; 4981	            switch( eAction )
.LINE 4981

	LD	HL,(IX+%12)
	CALL	__seqcaseD
	JP	(HL)
L__242:
	DW	5
	DW	0
	DB	0
	DW24	L_577	

	DW24	L_567	

	DW24	L_568	

	DW24	L_570	

	DW24	L_571	

	DW24	L_576	

; 4982	            {
; 4983	                case eSetBits:
L_567:
.LINE 4983

; 4984	                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
.LINE 4984

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3F
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,(IX+%C)
	LD	A,(IX+%F)
	CALL	__lor
	LD	BC,HL
	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	IY,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFED),BC	; spill
	LEA	BC,IY+%3F
	LD	(IX+%FFFFFFEA),BC	; spill
	LD	BC,(IX+%FFFFFFED)	; unspill
	LD	(IX+%FFFFFFED),BC	; spill
	LD	BC,(IX+%FFFFFFEA)	; unspill
	ADD	HL,BC
	LD	BC,(IX+%FFFFFFED)	; unspill
	LD	IY,HL
	LD	(IY),BC
	LD	A,E
	LD	(IY+%3),E
; 4985	                    break;
.LINE 4985

	JR	L_577
; 4986	
; 4987	                case eIncrement:
L_568:
.LINE 4987

; 4988	                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
.LINE 4988

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3F
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3F
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LEA	HL,IY+%3F
	ADD	HL,DE
	LD	(IX+%FFFFFFF0),HL
	LD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	A,%1
	CALL	__ladd_b
	LD	IY,(IX+%FFFFFFF0)
	LD	(IY),HL
	LD	(IY+%3),E
; 4989	                    break;
.LINE 4989

	JR	L_577
; 4990	
; 4991	                case eSetValueWithOverwrite:
L_570:
.LINE 4991

; 4992	                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
.LINE 4992

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3F
	ADD	HL,BC
	LD	BC,(IX+%C)
	LD	A,(IX+%F)
	LD	IY,HL
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
; 4993	                    break;
.LINE 4993

	JR	L_577
; 4994	
; 4995	                case eSetValueWithoutOverwrite:
L_571:
.LINE 4995

; 4996	
; 4997	                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
.LINE 4997

	LD	A,(IX+%FFFFFFF9)
	CP	A,%2
	JR	Z,L_573
; 4998	                    {
; 4999	                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
.LINE 4999

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3F
	ADD	HL,BC
	LD	BC,(IX+%C)
	LD	A,(IX+%F)
	LD	IY,HL
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
; 5000	                    }
; 5001	                    else
.LINE 5001

	JR	L_574
L_573:
; 5002	                    {
; 5003	                        /* The value could not be written to the task. */
; 5004	                        xReturn = pdFAIL;
.LINE 5004

	LD	BC,0
	LD	(IX+%FFFFFFF3),BC
; 5005	                    }
L_574:
.LINE 5005

; 5006	
; 5007	                    break;
; 5008	
; 5009	                case eNoAction:
; 5010	
; 5011	                    /* The task is being notified without its notify value being
; 5012	                     * updated. */
; 5013	                    break;
; 5014	
; 5015	                default:
L_576:
.LINE 5015

; 5016	
; 5017	                    /* Should not get here if all enums are handled.
; 5018	                     * Artificially force an assert by testing a value the
; 5019	                     * compiler can't assume is const. */
; 5020	                    configASSERT( xTickCount == ( TickType_t ) 0 );
; 5021	
; 5022	                    break;
; 5023	            }
L_577:
.LINE 5023

; 5024	
; 5025	            traceTASK_NOTIFY( uxIndexToNotify );
; 5026	
; 5027	            /* If the task is in the blocked state specifically to wait for a
; 5028	             * notification then unblock it now. */
; 5029	            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
.LINE 5029

	LD	A,(IX+%FFFFFFF9)
	CP	A,%1
	JR	NZ,L_587
; 5030	            {
; 5031	                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
.LINE 5031

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%10)
	LD	(IX+%FFFFFFFA),BC
	LD	BC,(IY+%7)
	LD	DE,(IY+%A)
	LD	IY,BC
	LD	(IY+%7),DE
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%A)
	LD	DE,(IY+%7)
	LD	IY,BC
	LD	(IY+%4),DE
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%3)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_579
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%A)
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%3),BC
L_579:
	LD	BC,0
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%10),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%0)
	LD	IY,(IY+%0)
	LEA	BC,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%0),BC
; 5032	                prvAddTaskToReadyList( pxTCB );
.LINE 5032

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,(_uxTopReadyPriority)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_582
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	(_uxTopReadyPriority),BC
L_582:
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFF6),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFF6)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%A),BC
	LD	IY,(IX+%FFFFFFF6)
	LD	DE,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,DE
	LD	(IY+%4),BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,(IX+%FFFFFFF6)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	(IY+%10),HL
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,_pxReadyTasksLists
	ADD	HL,DE
	LD	IY,BC
	LD	BC,(IY+%0)
	INC	BC
	LD	IY,HL
	LD	(IY+%0),BC
; 5033	
; 5034	                /* The task should not have been on an event list. */
; 5035	                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
; 5036	
; 5037	                #if ( configUSE_TICKLESS_IDLE != 0 )
; 5038	                {
; 5039	                    /* If a task is blocked waiting for a notification then
; 5040	                     * xNextTaskUnblockTime might be set to the blocked task's time
; 5041	                     * out time.  If the task is unblocked for a reason other than
; 5042	                     * a timeout xNextTaskUnblockTime is normally left unchanged,
; 5043	                     * because it will automatically get reset to a new value when
; 5044	                     * the tick count equals xNextTaskUnblockTime.  However if
; 5045	                     * tickless idling is used it might be more important to enter
; 5046	                     * sleep mode at the earliest possible time - so reset
; 5047	                     * xNextTaskUnblockTime here to ensure it is updated at the
; 5048	                     * earliest possible time. */
; 5049	                    prvResetNextTaskUnblockTime();
; 5050	                }
; 5051	                #endif
; 5052	
; 5053	                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
.LINE 5053

	LD	DE,(_pxCurrentTCB)
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	IY,DE
	LD	HL,(IY+%23)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_585
; 5054	                {
; 5055	                    /* The notified task has a priority above the currently
; 5056	                     * executing task so a yield is required. */
; 5057	                    taskYIELD_IF_USING_PREEMPTION();
.LINE 5057

	CALL	_vPortYield
; 5058	                }
; 5059	                else
L_585:
.LINE 5059

; 5060	                {
; 5061	                    mtCOVERAGE_TEST_MARKER();
; 5062	                }
; 5063	            }
; 5064	            else
L_587:
.LINE 5064

; 5065	            {
; 5066	                mtCOVERAGE_TEST_MARKER();
; 5067	            }
; 5068	        }
; 5069	        taskEXIT_CRITICAL();
.LINE 5069

	 ei
; 5070	
; 5071	        return xReturn;
.LINE 5071

	LD	HL,(IX+%FFFFFFF3)
; 5072	    }
.LINE 5072

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskGenericNotify ***************************
;Name                         Addr/Register   Size   Type
;_vPortYield                         IMPORT  -----   function
;_pxCurrentTCB                       STATIC      3   variable
;_pxReadyTasksLists                  STATIC     80   variable
;_uxTopReadyPriority                 STATIC      3   variable
;xReturn                              IX-13      3   variable
;pxIndex                              IX-10      3   variable
;ucOriginalNotifyState                 IX-7      1   variable
;pxList                                IX-6      3   variable
;pxTCB                                 IX-3      3   variable
;pulPreviousNotificationValue         IX+21      3   parameter
;eAction                              IX+18      3   parameter
;ulValue                              IX+12      4   parameter
;uxIndexToNotify                       IX+9      3   parameter
;xTaskToNotify                         IX+6      3   parameter


; Stack Frame Size: 49 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskGenericNotify",5072,"_xTaskGenericNotify"
; 5073	
; 5074	#endif /* configUSE_TASK_NOTIFICATIONS */
; 5075	/*-----------------------------------------------------------*/
; 5076	
; 5077	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
; 5078	
; 5079	    BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify,
; 5080	                                          UBaseType_t uxIndexToNotify,
; 5081	                                          uint32_t ulValue,
; 5082	                                          eNotifyAction eAction,
; 5083	                                          uint32_t * pulPreviousNotificationValue,
; 5084	                                          BaseType_t * pxHigherPriorityTaskWoken )
; 5085	    {
_xTaskGenericNotifyFromISR:
.DEFINE "_xTaskGenericNotifyFromISR"

.VALUE _xTaskGenericNotifyFromISR

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xTaskGenericNotifyFromISR",5085,"_xTaskGenericNotifyFromISR"

.LINE 5085

.DEFINE "xTaskToNotify"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "uxIndexToNotify"

.CLASS 65

.VALUE 9

.TYPE 14

.ENDEF

.DEFINE "ulValue"

.CLASS 65

.VALUE 12

.TYPE 15

.ENDEF

.DEFINE "eAction"

.CLASS 65

.VALUE 18

.TYPE 4

.ENDEF

.DEFINE "pulPreviousNotificationValue"

.CLASS 65

.VALUE 21

.TYPE 47

.ENDEF

.DEFINE "pxHigherPriorityTaskWoken"

.CLASS 65

.VALUE 24

.TYPE 36

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxList"

.CLASS 65

.VALUE -6

.TAG "xLIST"

.TYPE 40

.ENDEF

.DEFINE "ucOriginalNotifyState"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -10

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -13

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -16

.TYPE 4

.ENDEF

.DEFINE "uxSavedInterruptStatus"

.CLASS 65

.VALUE -19

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE1
	LD	SP,HL
; 5086	        TCB_t * pxTCB;
; 5087	        uint8_t ucOriginalNotifyState;
; 5088	        BaseType_t xReturn = pdPASS;
.LINE 5088

	LD	BC,1
	LD	(IX+%FFFFFFF0),BC
; 5089	        UBaseType_t uxSavedInterruptStatus;
; 5090	
; 5091	        configASSERT( xTaskToNotify );
; 5092	        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
; 5093	
; 5094	        /* RTOS ports that support interrupt nesting have the concept of a
; 5095	         * maximum  system call (or maximum API call) interrupt priority.
; 5096	         * Interrupts that are  above the maximum system call priority are keep
; 5097	         * permanently enabled, even when the RTOS kernel is in a critical section,
; 5098	         * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
; 5099	         * is defined in FreeRTOSConfig.h then
; 5100	         * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
; 5101	         * failure if a FreeRTOS API function is called from an interrupt that has
; 5102	         * been assigned a priority above the configured maximum system call
; 5103	         * priority.  Only FreeRTOS functions that end in FromISR can be called
; 5104	         * from interrupts  that have been assigned a priority at or (logically)
; 5105	         * below the maximum system call interrupt priority.  FreeRTOS maintains a
; 5106	         * separate interrupt safe API to ensure interrupt entry is as fast and as
; 5107	         * simple as possible.  More information (albeit Cortex-M specific) is
; 5108	         * provided on the following link:
; 5109	         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
; 5110	        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
; 5111	
; 5112	        pxTCB = xTaskToNotify;
.LINE 5112

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 5113	
; 5114	        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
.LINE 5114

	LD	BC,0
	LD	(IX+%FFFFFFED),BC
; 5115	        {
; 5116	            if( pulPreviousNotificationValue != NULL )
.LINE 5116

	LD	HL,(IX+%15)
	CALL	__icmpzero
	JR	Z,L_591
; 5117	            {
; 5118	                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
.LINE 5118

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3F
	ADD	HL,BC
	LD	IY,(IX+%15)
	LD	(IX+%FFFFFFE1),HL
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IY),BC
	LD	(IY+%3),A
; 5119	            }
L_591:
.LINE 5119

; 5120	
; 5121	            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
.LINE 5121

	LD	BC,(IX+%9)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%43
	ADD	HL,BC
	LD	IY,HL
	LD	A,(HL)
	LD	(IX+%FFFFFFF9),A
; 5122	            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
.LINE 5122

	LD	BC,(IX+%9)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%43
	ADD	HL,BC
	LD	IY,HL
	LD	(HL),%2
; 5123	
; 5124	            switch( eAction )
.LINE 5124

	LD	HL,(IX+%12)
	CALL	__seqcaseD
	JP	(HL)
L__250:
	DW	5
	DW	0
	DB	0
	DW24	L_602	

	DW24	L_592	

	DW24	L_593	

	DW24	L_595	

	DW24	L_596	

	DW24	L_601	

; 5125	            {
; 5126	                case eSetBits:
L_592:
.LINE 5126

; 5127	                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
.LINE 5127

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3F
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	BC,(IX+%C)
	LD	A,(IX+%F)
	CALL	__lor
	LD	BC,HL
	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	IY,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFE7),BC	; spill
	LEA	BC,IY+%3F
	LD	(IX+%FFFFFFE4),BC	; spill
	LD	BC,(IX+%FFFFFFE7)	; unspill
	LD	(IX+%FFFFFFE7),BC	; spill
	LD	BC,(IX+%FFFFFFE4)	; unspill
	ADD	HL,BC
	LD	BC,(IX+%FFFFFFE7)	; unspill
	LD	IY,HL
	LD	(IY),BC
	LD	A,E
	LD	(IY+%3),E
; 5128	                    break;
.LINE 5128

	JR	L_602
; 5129	
; 5130	                case eIncrement:
L_593:
.LINE 5130

; 5131	                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
.LINE 5131

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3F
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3F
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LEA	HL,IY+%3F
	ADD	HL,DE
	LD	(IX+%FFFFFFEA),HL
	LD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	A,%1
	CALL	__ladd_b
	LD	IY,(IX+%FFFFFFEA)
	LD	(IY),HL
	LD	(IY+%3),E
; 5132	                    break;
.LINE 5132

	JR	L_602
; 5133	
; 5134	                case eSetValueWithOverwrite:
L_595:
.LINE 5134

; 5135	                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
.LINE 5135

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3F
	ADD	HL,BC
	LD	BC,(IX+%C)
	LD	A,(IX+%F)
	LD	IY,HL
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
; 5136	                    break;
.LINE 5136

	JR	L_602
; 5137	
; 5138	                case eSetValueWithoutOverwrite:
L_596:
.LINE 5138

; 5139	
; 5140	                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
.LINE 5140

	LD	A,(IX+%FFFFFFF9)
	CP	A,%2
	JR	Z,L_598
; 5141	                    {
; 5142	                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
.LINE 5142

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3F
	ADD	HL,BC
	LD	BC,(IX+%C)
	LD	A,(IX+%F)
	LD	IY,HL
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
; 5143	                    }
; 5144	                    else
.LINE 5144

	JR	L_599
L_598:
; 5145	                    {
; 5146	                        /* The value could not be written to the task. */
; 5147	                        xReturn = pdFAIL;
.LINE 5147

	LD	BC,0
	LD	(IX+%FFFFFFF0),BC
; 5148	                    }
L_599:
.LINE 5148

; 5149	
; 5150	                    break;
; 5151	
; 5152	                case eNoAction:
; 5153	
; 5154	                    /* The task is being notified without its notify value being
; 5155	                     * updated. */
; 5156	                    break;
; 5157	
; 5158	                default:
L_601:
.LINE 5158

; 5159	
; 5160	                    /* Should not get here if all enums are handled.
; 5161	                     * Artificially force an assert by testing a value the
; 5162	                     * compiler can't assume is const. */
; 5163	                    configASSERT( xTickCount == ( TickType_t ) 0 );
; 5164	                    break;
; 5165	            }
L_602:
.LINE 5165

; 5166	
; 5167	            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );
; 5168	
; 5169	            /* If the task is in the blocked state specifically to wait for a
; 5170	             * notification then unblock it now. */
; 5171	            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
.LINE 5171

	LD	A,(IX+%FFFFFFF9)
	CP	A,%1
	JR	NZ,L_618
; 5172	            {
; 5173	                /* The task should not have been on an event list. */
; 5174	                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
; 5175	
; 5176	                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
.LINE 5176

	LD	HL,(_uxSchedulerSuspended)
	CALL	__icmpzero
	JR	NZ,L_611
; 5177	                {
; 5178	                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
.LINE 5178

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%10)
	LD	(IX+%FFFFFFFA),BC
	LD	BC,(IY+%7)
	LD	DE,(IY+%A)
	LD	IY,BC
	LD	(IY+%7),DE
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%A)
	LD	DE,(IY+%7)
	LD	IY,BC
	LD	(IY+%4),DE
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%3)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_604
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%A)
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%3),BC
L_604:
	LD	BC,0
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%10),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%0)
	LD	IY,(IY+%0)
	LEA	BC,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%0),BC
; 5179	                    prvAddTaskToReadyList( pxTCB );
.LINE 5179

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,(_uxTopReadyPriority)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_607
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	(_uxTopReadyPriority),BC
L_607:
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFF6),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFF6)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%A),BC
	LD	IY,(IX+%FFFFFFF6)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LEA	DE,IY+%3
	LD	IY,BC
	LD	(IY+%4),DE
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,(IX+%FFFFFFF6)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	(IY+%10),HL
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,_pxReadyTasksLists
	ADD	HL,DE
	LD	IY,BC
	LD	BC,(IY+%0)
	INC	BC
	LD	IY,HL
	LD	(IY+%0),BC
; 5180	                }
; 5181	                else
.LINE 5181

	JR	L_616
L_611:
; 5182	                {
; 5183	                    /* The delayed and ready lists cannot be accessed, so hold
; 5184	                     * this task pending until the scheduler is resumed. */
; 5185	                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
.LINE 5185

	LD	BC,(_xPendingReadyList+3)
	LD	(IX+%FFFFFFF3),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%17),BC
	LD	IY,(IX+%FFFFFFF3)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%1A),BC
	LD	IY,(IX+%FFFFFFF3)
	LD	DE,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%13
	LD	IY,DE
	LD	(IY+%4),BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%13
	LD	IY,(IX+%FFFFFFF3)
	LD	(IY+%7),BC
	LD	BC,_xPendingReadyList
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%20),BC
	LD	BC,(_xPendingReadyList)
	LD	BC,(_xPendingReadyList)
	INC	BC
	LD	(_xPendingReadyList),BC
; 5186	                }
L_616:
.LINE 5186

; 5187	
; 5188	                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
.LINE 5188

	LD	DE,(_pxCurrentTCB)
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	IY,DE
	LD	HL,(IY+%23)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_615
; 5189	                {
; 5190	                    /* The notified task has a priority above the currently
; 5191	                     * executing task so a yield is required. */
; 5192	                    if( pxHigherPriorityTaskWoken != NULL )
.LINE 5192

	LD	HL,(IX+%18)
	CALL	__icmpzero
	JR	Z,L_613
; 5193	                    {
; 5194	                        *pxHigherPriorityTaskWoken = pdTRUE;
.LINE 5194

	LD	HL,(IX+%18)
	LD	BC,1
	LD	(HL),BC
; 5195	                    }
L_613:
.LINE 5195

; 5196	
; 5197	                    /* Mark that a yield is pending in case the user is not
; 5198	                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
; 5199	                     * safe FreeRTOS function. */
; 5200	                    xYieldPending = pdTRUE;
.LINE 5200

	LD	BC,1
	LD	(_xYieldPending),BC
; 5201	                }
; 5202	                else
L_615:
.LINE 5202

; 5203	                {
; 5204	                    mtCOVERAGE_TEST_MARKER();
; 5205	                }
; 5206	            }
; 5207	        }
L_618:
.LINE 5207

; 5208	        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
; 5209	
; 5210	        return xReturn;
.LINE 5210

	LD	HL,(IX+%FFFFFFF0)
; 5211	    }
.LINE 5211

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskGenericNotifyFromISR ***************************
;Name                         Addr/Register   Size   Type
;_xYieldPending                      STATIC      3   variable
;_pxCurrentTCB                       STATIC      3   variable
;_xPendingReadyList                  STATIC     16   variable
;_pxReadyTasksLists                  STATIC     80   variable
;_uxTopReadyPriority                 STATIC      3   variable
;_uxSchedulerSuspended               STATIC      3   variable
;uxSavedInterruptStatus               IX-19      3   variable
;xReturn                              IX-16      3   variable
;pxIndex                              IX-13      3   variable
;pxIndex                              IX-10      3   variable
;ucOriginalNotifyState                 IX-7      1   variable
;pxList                                IX-6      3   variable
;pxTCB                                 IX-3      3   variable
;pxHigherPriorityTaskWoken            IX+24      3   parameter
;pulPreviousNotificationValue         IX+21      3   parameter
;eAction                              IX+18      3   parameter
;ulValue                              IX+12      4   parameter
;uxIndexToNotify                       IX+9      3   parameter
;xTaskToNotify                         IX+6      3   parameter


; Stack Frame Size: 58 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskGenericNotifyFromISR",5211,"_xTaskGenericNotifyFromISR"
; 5212	
; 5213	#endif /* configUSE_TASK_NOTIFICATIONS */
; 5214	/*-----------------------------------------------------------*/
; 5215	
; 5216	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
; 5217	
; 5218	    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
; 5219	                                        UBaseType_t uxIndexToNotify,
; 5220	                                        BaseType_t * pxHigherPriorityTaskWoken )
; 5221	    {
_vTaskGenericNotifyGiveFromISR:
.DEFINE "_vTaskGenericNotifyGiveFromISR"

.VALUE _vTaskGenericNotifyGiveFromISR

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "vTaskGenericNotifyGiveFromISR",5221,"_vTaskGenericNotifyGiveFromISR"

.LINE 5221

.DEFINE "xTaskToNotify"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "uxIndexToNotify"

.CLASS 65

.VALUE 9

.TYPE 14

.ENDEF

.DEFINE "pxHigherPriorityTaskWoken"

.CLASS 65

.VALUE 12

.TYPE 36

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "pxList"

.CLASS 65

.VALUE -6

.TAG "xLIST"

.TYPE 40

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -9

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -12

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

.DEFINE "ucOriginalNotifyState"

.CLASS 65

.VALUE -13

.TYPE 12

.ENDEF

.DEFINE "uxSavedInterruptStatus"

.CLASS 65

.VALUE -16

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFED
	LD	SP,HL
; 5222	        TCB_t * pxTCB;
; 5223	        uint8_t ucOriginalNotifyState;
; 5224	        UBaseType_t uxSavedInterruptStatus;
; 5225	
; 5226	        configASSERT( xTaskToNotify );
; 5227	        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
; 5228	
; 5229	        /* RTOS ports that support interrupt nesting have the concept of a
; 5230	         * maximum  system call (or maximum API call) interrupt priority.
; 5231	         * Interrupts that are  above the maximum system call priority are keep
; 5232	         * permanently enabled, even when the RTOS kernel is in a critical section,
; 5233	         * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
; 5234	         * is defined in FreeRTOSConfig.h then
; 5235	         * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
; 5236	         * failure if a FreeRTOS API function is called from an interrupt that has
; 5237	         * been assigned a priority above the configured maximum system call
; 5238	         * priority.  Only FreeRTOS functions that end in FromISR can be called
; 5239	         * from interrupts  that have been assigned a priority at or (logically)
; 5240	         * below the maximum system call interrupt priority.  FreeRTOS maintains a
; 5241	         * separate interrupt safe API to ensure interrupt entry is as fast and as
; 5242	         * simple as possible.  More information (albeit Cortex-M specific) is
; 5243	         * provided on the following link:
; 5244	         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
; 5245	        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
; 5246	
; 5247	        pxTCB = xTaskToNotify;
.LINE 5247

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
; 5248	
; 5249	        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
.LINE 5249

	LD	BC,0
	LD	(IX+%FFFFFFF0),BC
; 5250	        {
; 5251	            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
.LINE 5251

	LD	BC,(IX+%9)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%43
	ADD	HL,BC
	LD	IY,HL
	LD	A,(HL)
	LD	(IX+%FFFFFFF3),A
; 5252	            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
.LINE 5252

	LD	BC,(IX+%9)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%43
	ADD	HL,BC
	LD	IY,HL
	LD	(HL),%2
; 5253	
; 5254	            /* 'Giving' is equivalent to incrementing a count in a counting
; 5255	             * semaphore. */
; 5256	            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
.LINE 5256

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3F
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3F
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LEA	HL,IY+%3F
	ADD	HL,DE
	LD	(IX+%FFFFFFED),HL
	LD	IY,BC
	LD	HL,(IY)
	LD	E,(IY+%3)
	LD	A,%1
	CALL	__ladd_b
	LD	IY,(IX+%FFFFFFED)
	LD	(IY),HL
	LD	(IY+%3),E
; 5257	
; 5258	            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );
; 5259	
; 5260	            /* If the task is in the blocked state specifically to wait for a
; 5261	             * notification then unblock it now. */
; 5262	            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
.LINE 5262

	LD	A,(IX+%FFFFFFF3)
	CP	A,%1
	JR	NZ,L_636
; 5263	            {
; 5264	                /* The task should not have been on an event list. */
; 5265	                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
; 5266	
; 5267	                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
.LINE 5267

	LD	HL,(_uxSchedulerSuspended)
	CALL	__icmpzero
	JR	NZ,L_629
; 5268	                {
; 5269	                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
.LINE 5269

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%10)
	LD	(IX+%FFFFFFFA),BC
	LD	BC,(IY+%7)
	LD	DE,(IY+%A)
	LD	IY,BC
	LD	(IY+%7),DE
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%A)
	LD	DE,(IY+%7)
	LD	IY,BC
	LD	(IY+%4),DE
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%3)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_622
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%A)
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%3),BC
L_622:
	LD	BC,0
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%10),BC
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%0)
	LD	IY,(IY+%0)
	LEA	BC,IY+%FFFFFFFF
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%0),BC
; 5270	                    prvAddTaskToReadyList( pxTCB );
.LINE 5270

	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,(_uxTopReadyPriority)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_625
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	(_uxTopReadyPriority),BC
L_625:
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFF7),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFF7)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%A),BC
	LD	IY,(IX+%FFFFFFF7)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LEA	DE,IY+%3
	LD	IY,BC
	LD	(IY+%4),DE
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3
	LD	IY,(IX+%FFFFFFF7)
	LD	(IY+%7),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	(IY+%10),HL
	LD	BC,(IY+%23)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_pxReadyTasksLists
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IY+%23)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,_pxReadyTasksLists
	ADD	HL,DE
	LD	IY,BC
	LD	BC,(IY+%0)
	INC	BC
	LD	IY,HL
	LD	(IY+%0),BC
; 5271	                }
; 5272	                else
.LINE 5272

	JR	L_634
L_629:
; 5273	                {
; 5274	                    /* The delayed and ready lists cannot be accessed, so hold
; 5275	                     * this task pending until the scheduler is resumed. */
; 5276	                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
.LINE 5276

	LD	BC,(_xPendingReadyList+3)
	LD	(IX+%FFFFFFF4),BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%17),BC
	LD	IY,(IX+%FFFFFFF4)
	LD	BC,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%1A),BC
	LD	IY,(IX+%FFFFFFF4)
	LD	DE,(IY+%7)
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%13
	LD	IY,DE
	LD	(IY+%4),BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%13
	LD	IY,(IX+%FFFFFFF4)
	LD	(IY+%7),BC
	LD	BC,_xPendingReadyList
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%20),BC
	LD	BC,(_xPendingReadyList)
	LD	BC,(_xPendingReadyList)
	INC	BC
	LD	(_xPendingReadyList),BC
; 5277	                }
L_634:
.LINE 5277

; 5278	
; 5279	                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
.LINE 5279

	LD	DE,(_pxCurrentTCB)
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%23)
	LD	IY,DE
	LD	HL,(IY+%23)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_633
; 5280	                {
; 5281	                    /* The notified task has a priority above the currently
; 5282	                     * executing task so a yield is required. */
; 5283	                    if( pxHigherPriorityTaskWoken != NULL )
.LINE 5283

	LD	HL,(IX+%C)
	CALL	__icmpzero
	JR	Z,L_631
; 5284	                    {
; 5285	                        *pxHigherPriorityTaskWoken = pdTRUE;
.LINE 5285

	LD	HL,(IX+%C)
	LD	BC,1
	LD	(HL),BC
; 5286	                    }
L_631:
.LINE 5286

; 5287	
; 5288	                    /* Mark that a yield is pending in case the user is not
; 5289	                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
; 5290	                     * safe FreeRTOS function. */
; 5291	                    xYieldPending = pdTRUE;
.LINE 5291

	LD	BC,1
	LD	(_xYieldPending),BC
; 5292	                }
; 5293	                else
L_633:
.LINE 5293

; 5294	                {
; 5295	                    mtCOVERAGE_TEST_MARKER();
; 5296	                }
; 5297	            }
; 5298	        }
L_636:
.LINE 5298

; 5299	        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
; 5300	    }
.LINE 5300

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vTaskGenericNotifyGiveFromISR ***************************
;Name                         Addr/Register   Size   Type
;_xYieldPending                      STATIC      3   variable
;_pxCurrentTCB                       STATIC      3   variable
;_xPendingReadyList                  STATIC     16   variable
;_pxReadyTasksLists                  STATIC     80   variable
;_uxTopReadyPriority                 STATIC      3   variable
;_uxSchedulerSuspended               STATIC      3   variable
;uxSavedInterruptStatus               IX-16      3   variable
;ucOriginalNotifyState                IX-13      1   variable
;pxIndex                              IX-12      3   variable
;pxIndex                               IX-9      3   variable
;pxList                                IX-6      3   variable
;pxTCB                                 IX-3      3   variable
;pxHigherPriorityTaskWoken            IX+12      3   parameter
;uxIndexToNotify                       IX+9      3   parameter
;xTaskToNotify                         IX+6      3   parameter


; Stack Frame Size: 34 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vTaskGenericNotifyGiveFromISR",5300,"_vTaskGenericNotifyGiveFromISR"
; 5301	
; 5302	#endif /* configUSE_TASK_NOTIFICATIONS */
; 5303	/*-----------------------------------------------------------*/
; 5304	
; 5305	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
; 5306	
; 5307	    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
; 5308	                                             UBaseType_t uxIndexToClear )
; 5309	    {
_xTaskGenericNotifyStateClear:
.DEFINE "_xTaskGenericNotifyStateClear"

.VALUE _xTaskGenericNotifyStateClear

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "xTaskGenericNotifyStateClear",5309,"_xTaskGenericNotifyStateClear"

.LINE 5309

.DEFINE "xTask"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "uxIndexToClear"

.CLASS 65

.VALUE 9

.TYPE 14

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "xReturn"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
; 5310	        TCB_t * pxTCB;
; 5311	        BaseType_t xReturn;
; 5312	
; 5313	        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
; 5314	
; 5315	        /* If null is passed in here then it is the calling task that is having
; 5316	         * its notification state cleared. */
; 5317	        pxTCB = prvGetTCBFromHandle( xTask );
.LINE 5317

	LD	HL,(IX+%6)
	CALL	__icmpzero
	JR	NZ,L_640
	LD	BC,(_pxCurrentTCB)
	LD	(IX+%FFFFFFF7),BC
	JR	L_641
L_640:
	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFF7),BC
L_641:
	LD	BC,(IX+%FFFFFFF7)
	LD	(IX+%FFFFFFFD),BC
; 5318	
; 5319	        taskENTER_CRITICAL();
.LINE 5319

	 di
; 5320	        {
; 5321	            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
.LINE 5321

	LD	BC,(IX+%9)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%43
	ADD	HL,BC
	LD	IY,HL
	LD	A,(HL)
	CP	A,%2
	JR	NZ,L_643
; 5322	            {
; 5323	                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
.LINE 5323

	LD	BC,(IX+%9)
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%43
	ADD	HL,BC
	LD	IY,HL
	LD	(HL),%0
; 5324	                xReturn = pdPASS;
.LINE 5324

	LD	BC,1
	LD	(IX+%FFFFFFFA),BC
; 5325	            }
; 5326	            else
.LINE 5326

	JR	L_644
L_643:
; 5327	            {
; 5328	                xReturn = pdFAIL;
.LINE 5328

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
; 5329	            }
; 5330	        }
L_644:
.LINE 5330

; 5331	        taskEXIT_CRITICAL();
.LINE 5331

	 ei
; 5332	
; 5333	        return xReturn;
.LINE 5333

	LD	HL,(IX+%FFFFFFFA)
; 5334	    }
.LINE 5334

	LD	SP,IX
	POP	IX
	RET	


;**************************** _xTaskGenericNotifyStateClear ***************************
;Name                         Addr/Register   Size   Type
;_pxCurrentTCB                       STATIC      3   variable
;temp638                               IX-9      3   variable
;xReturn                               IX-6      3   variable
;pxTCB                                 IX-3      3   variable
;uxIndexToClear                        IX+9      3   parameter
;xTask                                 IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "xTaskGenericNotifyStateClear",5334,"_xTaskGenericNotifyStateClear"
; 5335	
; 5336	#endif /* configUSE_TASK_NOTIFICATIONS */
; 5337	/*-----------------------------------------------------------*/
; 5338	
; 5339	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
; 5340	
; 5341	    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
; 5342	                                            UBaseType_t uxIndexToClear,
; 5343	                                            uint32_t ulBitsToClear )
; 5344	    {
_ulTaskGenericNotifyValueClear:
.DEFINE "_ulTaskGenericNotifyValueClear"

.VALUE _ulTaskGenericNotifyValueClear

.CLASS 2

.TYPE 79

.ENDEF

.BEGFUNC "ulTaskGenericNotifyValueClear",5344,"_ulTaskGenericNotifyValueClear"

.LINE 5344

.DEFINE "xTask"

.CLASS 65

.VALUE 6

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "uxIndexToClear"

.CLASS 65

.VALUE 9

.TYPE 14

.ENDEF

.DEFINE "ulBitsToClear"

.CLASS 65

.VALUE 12

.TYPE 15

.ENDEF

.DEFINE "pxTCB"

.CLASS 65

.VALUE -3

.TAG "tskTaskControlBlock"

.TYPE 40

.ENDEF

.DEFINE "ulReturn"

.CLASS 65

.VALUE -10

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF0
	LD	SP,HL
; 5345	        TCB_t * pxTCB;
; 5346	        uint32_t ulReturn;
; 5347	
; 5348	        /* If null is passed in here then it is the calling task that is having
; 5349	         * its notification state cleared. */
; 5350	        pxTCB = prvGetTCBFromHandle( xTask );
.LINE 5350

	LD	HL,(IX+%6)
	CALL	__icmpzero
	JR	NZ,L_648
	LD	BC,(_pxCurrentTCB)
	LD	(IX+%FFFFFFFA),BC
	JR	L_649
L_648:
	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFA),BC
L_649:
	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFFD),BC
; 5351	
; 5352	        taskENTER_CRITICAL();
.LINE 5352

	 di
; 5353	        {
; 5354	            /* Return the notification as it was before the bits were cleared,
; 5355	             * then clear the bit mask. */
; 5356	            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
.LINE 5356

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	HL,IY+%3F
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFF6),BC
	LD	(IX+%FFFFFFF9),A
; 5357	            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
.LINE 5357

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3F
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%C)
	LD	E,(IX+%F)
	CALL	__lnot
	LD	A,E
	LD	BC,HL
	LD	HL,(IY)
	LD	E,(IY+%3)
	CALL	__land
	LD	(IX+%FFFFFFF3),HL	; spill
	LD	(IX+%FFFFFFF0),HL	; spill
	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	IY,(IX+%FFFFFFFD)
	LEA	BC,IY+%3F
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%FFFFFFF0)	; unspill
	LD	(IY),HL
	LD	A,E
	LD	(IY+%3),E
; 5358	        }
; 5359	        taskEXIT_CRITICAL();
.LINE 5359

	 ei
; 5360	
; 5361	        return ulReturn;
.LINE 5361

	LD	HL,(IX+%FFFFFFF6)
	LD	E,(IX+%FFFFFFF9)
; 5362	    }
.LINE 5362

	LD	SP,IX
	POP	IX
	RET	


;**************************** _ulTaskGenericNotifyValueClear ***************************
;Name                         Addr/Register   Size   Type
;_pxCurrentTCB                       STATIC      3   variable
;ulReturn                             IX-10      4   variable
;temp646                               IX-6      3   variable
;pxTCB                                 IX-3      3   variable
;ulBitsToClear                        IX+12      4   parameter
;uxIndexToClear                        IX+9      3   parameter
;xTask                                 IX+6      3   parameter


; Stack Frame Size: 34 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "ulTaskGenericNotifyValueClear",5362,"_ulTaskGenericNotifyValueClear"
; 5363	
; 5364	#endif /* configUSE_TASK_NOTIFICATIONS */
; 5365	/*-----------------------------------------------------------*/
; 5366	
; 5367	#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )
; 5368	
; 5369	    configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimeCounter( void )
; 5370	    {
; 5371	        return xIdleTaskHandle->ulRunTimeCounter;
; 5372	    }
; 5373	
; 5374	#endif
; 5375	/*-----------------------------------------------------------*/
; 5376	
; 5377	#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )
; 5378	
; 5379	    configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimePercent( void )
; 5380	    {
; 5381	        configRUN_TIME_COUNTER_TYPE ulTotalTime, ulReturn;
; 5382	
; 5383	        ulTotalTime = portGET_RUN_TIME_COUNTER_VALUE();
; 5384	
; 5385	        /* For percentage calculations. */
; 5386	        ulTotalTime /= ( configRUN_TIME_COUNTER_TYPE ) 100;
; 5387	
; 5388	        /* Avoid divide by zero errors. */
; 5389	        if( ulTotalTime > ( configRUN_TIME_COUNTER_TYPE ) 0 )
; 5390	        {
; 5391	            ulReturn = xIdleTaskHandle->ulRunTimeCounter / ulTotalTime;
; 5392	        }
; 5393	        else
; 5394	        {
; 5395	            ulReturn = 0;
; 5396	        }
; 5397	
; 5398	        return ulReturn;
; 5399	    }
; 5400	
; 5401	#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
; 5402	/*-----------------------------------------------------------*/
; 5403	
; 5404	static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
; 5405	                                            const BaseType_t xCanBlockIndefinitely )
; 5406	{
_prvAddCurrentTaskToDelayedList:
.DEFINE "_prvAddCurrentTaskToDelayedList"

.VALUE _prvAddCurrentTaskToDelayedList

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "prvAddCurrentTaskToDelayedList",5406,"_prvAddCurrentTaskToDelayedList"

.LINE 5406

.DEFINE "xTicksToWait"

.CLASS 65

.VALUE 6

.TYPE 15

.ENDEF

.DEFINE "xCanBlockIndefinitely"

.CLASS 65

.VALUE 12

.TYPE 4

.ENDEF

.DEFINE "pxIndex"

.CLASS 65

.VALUE -3

.TAG "xLIST_ITEM"

.TYPE 40

.ENDEF

.DEFINE "xTimeToWake"

.CLASS 65

.VALUE -7

.TYPE 15

.ENDEF

.DEFINE "xConstTickCount"

.CLASS 65

.VALUE -11

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF5
	LD	SP,HL
; 5407	    TickType_t xTimeToWake;
; 5408	    const TickType_t xConstTickCount = xTickCount;
.LINE 5408

	LD	BC,(_xTickCount)
	LD	A,(_xTickCount+3)
	LD	(IX+%FFFFFFF5),BC
	LD	(IX+%FFFFFFF8),A
; 5409	
; 5410	    #if ( INCLUDE_xTaskAbortDelay == 1 )
; 5411	    {
; 5412	        /* About to enter a delayed list, so ensure the ucDelayAborted flag is
; 5413	         * reset to pdFALSE so it can be detected as having been set to pdTRUE
; 5414	         * when the task leaves the Blocked state. */
; 5415	        pxCurrentTCB->ucDelayAborted = pdFALSE;
.LINE 5415

	LD	IY,(_pxCurrentTCB)
	LD	(IY+%44),%0
; 5416	    }
; 5417	    #endif
; 5418	
; 5419	    /* Remove the task from the ready list before adding it to the blocked list
; 5420	     * as the same list item is used for both lists. */
; 5421	    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
.LINE 5421

	LD	IY,(_pxCurrentTCB)
	PEA	IY+%3
	CALL	_uxListRemove
	POP	BC
	CALL	__icmpzero
; 5422	    {
; 5423	        /* The current task must be in a ready list, so there is no need to
; 5424	         * check, and the port reset macro can be called directly. */
; 5425	        portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
; 5426	    }
; 5427	    else
.LINE 5427

; 5428	    {
; 5429	        mtCOVERAGE_TEST_MARKER();
; 5430	    }
; 5431	
; 5432	    #if ( INCLUDE_vTaskSuspend == 1 )
; 5433	    {
; 5434	        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
.LINE 5434

	LD	HL,(IX+%6)
	LD	E,(IX+%9)
	LD	BC,16777215
	LD	A,%FF
	CALL	__lcmpu
	JR	NZ,L_660
	LD	HL,(IX+%C)
	CALL	__icmpzero
	JR	Z,L_660
; 5435	        {
; 5436	            /* Add the task to the suspended task list instead of a delayed task
; 5437	             * list to ensure it is not woken by a timing event.  It will block
; 5438	             * indefinitely. */
; 5439	            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
.LINE 5439

	LD	BC,(_xSuspendedTaskList+3)
	LD	(IX+%FFFFFFFD),BC
	LD	IY,(_pxCurrentTCB)
	LD	BC,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	DE,(_pxCurrentTCB)
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%7)
	LD	IY,DE
	LD	(IY+%A),BC
	LD	BC,(_pxCurrentTCB)
	LD	IY,(IX+%FFFFFFFD)
	LD	DE,(IY+%7)
	LD	IY,BC
	LEA	BC,IY+%3
	LD	IY,DE
	LD	(IY+%4),BC
	LD	IY,(_pxCurrentTCB)
	LEA	BC,IY+%3
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%7),BC
	LD	IY,(_pxCurrentTCB)
	LD	BC,_xSuspendedTaskList
	LD	(IY+%10),BC
	LD	BC,(_xSuspendedTaskList)
	LD	BC,(_xSuspendedTaskList)
	INC	BC
	LD	(_xSuspendedTaskList),BC
; 5440	        }
; 5441	        else
.LINE 5441

	JR	L_662
L_660:
; 5442	        {
; 5443	            /* Calculate the time at which the task should be woken if the event
; 5444	             * does not occur.  This may overflow but this doesn't matter, the
; 5445	             * kernel will manage it correctly. */
; 5446	            xTimeToWake = xConstTickCount + xTicksToWait;
.LINE 5446

	LD	HL,(IX+%FFFFFFF5)
	LD	E,(IX+%FFFFFFF8)
	LD	BC,(IX+%6)
	LD	A,(IX+%9)
	CALL	__ladd
	LD	(IX+%FFFFFFF9),HL
	LD	(IX+%FFFFFFFC),E
; 5447	
; 5448	            /* The list item will be inserted in wake time order. */
; 5449	            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
.LINE 5449

	LD	IY,(_pxCurrentTCB)
	LD	BC,(IX+%FFFFFFF9)
	LD	A,(IX+%FFFFFFFC)
	LD	(IY+%3),BC
	LD	(IY+%6),A
; 5450	
; 5451	            if( xTimeToWake < xConstTickCount )
.LINE 5451

	LD	HL,(IX+%FFFFFFF9)
	LD	E,(IX+%FFFFFFFC)
	LD	BC,(IX+%FFFFFFF5)
	LD	A,(IX+%FFFFFFF8)
	CALL	__lcmpu
	JR	NC,L_658
; 5452	            {
; 5453	                /* Wake time has overflowed.  Place this item in the overflow
; 5454	                 * list. */
; 5455	                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
.LINE 5455

	LD	IY,(_pxCurrentTCB)
	PEA	IY+%3
	LD	BC,(_pxOverflowDelayedTaskList)
	PUSH	BC
	CALL	_vListInsert
	POP	BC
	POP	BC
; 5456	            }
; 5457	            else
.LINE 5457

	JR	L_662
L_658:
; 5458	            {
; 5459	                /* The wake time has not overflowed, so the current block list
; 5460	                 * is used. */
; 5461	                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
.LINE 5461

	LD	IY,(_pxCurrentTCB)
	PEA	IY+%3
	LD	BC,(_pxDelayedTaskList)
	PUSH	BC
	CALL	_vListInsert
	POP	BC
	POP	BC
; 5462	
; 5463	                /* If the task entering the blocked state was placed at the
; 5464	                 * head of the list of blocked tasks then xNextTaskUnblockTime
; 5465	                 * needs to be updated too. */
; 5466	                if( xTimeToWake < xNextTaskUnblockTime )
.LINE 5466

	LD	HL,(IX+%FFFFFFF9)
	LD	E,(IX+%FFFFFFFC)
	LD	BC,(_xNextTaskUnblockTime)
	LD	A,(_xNextTaskUnblockTime+3)
	CALL	__lcmpu
	JR	NC,L_656
; 5467	                {
; 5468	                    xNextTaskUnblockTime = xTimeToWake;
.LINE 5468

	LD	BC,(IX+%FFFFFFF9)
	LD	(_xNextTaskUnblockTime),BC
	LD	A,(IX+%FFFFFFFC)
	LD	(_xNextTaskUnblockTime+3),A
; 5469	                }
; 5470	                else
L_656:
.LINE 5470

; 5471	                {
; 5472	                    mtCOVERAGE_TEST_MARKER();
; 5473	                }
; 5474	            }
; 5475	        }
; 5476	    }
; 5477	    #else /* INCLUDE_vTaskSuspend */
; 5478	    {
; 5479	        /* Calculate the time at which the task should be woken if the event
; 5480	         * does not occur.  This may overflow but this doesn't matter, the kernel
; 5481	         * will manage it correctly. */
; 5482	        xTimeToWake = xConstTickCount + xTicksToWait;
; 5483	
; 5484	        /* The list item will be inserted in wake time order. */
; 5485	        listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
; 5486	
; 5487	        if( xTimeToWake < xConstTickCount )
; 5488	        {
; 5489	            /* Wake time has overflowed.  Place this item in the overflow list. */
; 5490	            vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
; 5491	        }
; 5492	        else
; 5493	        {
; 5494	            /* The wake time has not overflowed, so the current block list is used. */
; 5495	            vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
; 5496	
; 5497	            /* If the task entering the blocked state was placed at the head of the
; 5498	             * list of blocked tasks then xNextTaskUnblockTime needs to be updated
; 5499	             * too. */
; 5500	            if( xTimeToWake < xNextTaskUnblockTime )
; 5501	            {
; 5502	                xNextTaskUnblockTime = xTimeToWake;
; 5503	            }
; 5504	            else
; 5505	            {
; 5506	                mtCOVERAGE_TEST_MARKER();
; 5507	            }
; 5508	        }
; 5509	
; 5510	        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
; 5511	        ( void ) xCanBlockIndefinitely;
; 5512	    }
; 5513	    #endif /* INCLUDE_vTaskSuspend */
; 5514	}
L_662:
.LINE 5514

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prvAddCurrentTaskToDelayedList ***************************
;Name                         Addr/Register   Size   Type
;_xNextTaskUnblockTime               STATIC      4   variable
;_pxDelayedTaskList                  STATIC      3   variable
;_pxOverflowDelayedTaskList          STATIC      3   variable
;_vListInsert                        IMPORT  -----   function
;_xSuspendedTaskList                 STATIC     16   variable
;_uxListRemove                       IMPORT  -----   function
;_pxCurrentTCB                       STATIC      3   variable
;_xTickCount                         STATIC      4   variable
;xConstTickCount                      IX-11      4   variable
;xTimeToWake                           IX-7      4   variable
;pxIndex                               IX-3      3   variable
;xCanBlockIndefinitely                IX+12      3   parameter
;xTicksToWait                          IX+6      4   parameter


; Stack Frame Size: 26 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "prvAddCurrentTaskToDelayedList",5514,"_prvAddCurrentTaskToDelayedList"
	XREF _vApplicationIdleHook:ROM
	XREF _uxListRemove:ROM
	XREF _vListInsertEnd:ROM
	XREF _vListInsert:ROM
	XREF _vListInitialiseItem:ROM
	XREF _vListInitialise:ROM
	XREF _vPortEndScheduler:ROM
	XREF _xPortStartScheduler:ROM
	XREF _vPortFree:ROM
	XREF _pvPortMalloc:ROM
	XREF _pxPortInitialiseStack:ROM
	XREF _vPortYield:ROM
	XREF _memset:ROM
	XREF __lcmpu:ROM
	XREF __ladd:ROM
	XREF __lsub:ROM
	XREF __ldivu:ROM
	XREF __lmulu:ROM
	XREF __lnot:ROM
	XREF __lor:ROM
	XREF __iand:ROM
	XREF __land:ROM
	XREF __itol:ROM
	XREF __setflag:ROM
	XREF __icmpzero:ROM
	XREF __lcmpzero:ROM
	XREF __seqcaseD:ROM
	XREF __ladd_b:ROM
	XDEF _prvAddCurrentTaskToDelayedList
	XDEF _ulTaskGenericNotifyValueClear
	XDEF _xTaskGenericNotifyStateClear
	XDEF _vTaskGenericNotifyGiveFromISR
	XDEF _xTaskGenericNotifyFromISR
	XDEF _xTaskGenericNotify
	XDEF _xTaskGenericNotifyWait
	XDEF _ulTaskGenericNotifyTake
	XDEF _pvTaskIncrementMutexHeldCount
	XDEF _uxTaskResetEventItemValue
	XDEF _vTaskPriorityDisinheritAfterTimeout
	XDEF _xTaskPriorityDisinherit
	XDEF _xTaskPriorityInherit
	XDEF _xTaskGetSchedulerState
	XDEF _xTaskGetCurrentTaskHandle
	XDEF _prvResetNextTaskUnblockTime
	XDEF _prvDeleteTCB
	XDEF _uxTaskGetStackHighWaterMark
	XDEF _uxTaskGetStackHighWaterMark2
	XDEF _prvTaskCheckFreeStackSpace
	XDEF _prvCheckTasksWaitingTermination
	XDEF _prvInitialiseTaskLists
	XDEF _prvIdleTask
	XDEF _vTaskMissedYield
	XDEF _xTaskCheckForTimeOut
	XDEF _vTaskInternalSetTimeOutState
	XDEF _vTaskSetTimeOutState
	XDEF _vTaskRemoveFromUnorderedEventList
	XDEF _xTaskRemoveFromEventList
	XDEF _vTaskPlaceOnUnorderedEventList
	XDEF _vTaskPlaceOnEventList
	XDEF _vTaskSwitchContext
	XDEF _xTaskIncrementTick
	XDEF _xTaskAbortDelay
	XDEF _xTaskCatchUpTicks
	XDEF _xTaskGetIdleTaskHandle
	XDEF _xTaskGetHandle
	XDEF _prvSearchForNameWithinSingleList
	XDEF _pcTaskGetName
	XDEF _uxTaskGetNumberOfTasks
	XDEF _xTaskGetTickCountFromISR
	XDEF _xTaskGetTickCount
	XDEF _xTaskResumeAll
	XDEF _vTaskSuspendAll
	XDEF _vTaskEndScheduler
	XDEF _vTaskStartScheduler
	XDEF _xTaskResumeFromISR
	XDEF _vTaskResume
	XDEF _prvTaskIsTaskSuspended
	XDEF _vTaskSuspend
	XDEF _vTaskPrioritySet
	XDEF _uxTaskPriorityGetFromISR
	XDEF _uxTaskPriorityGet
	XDEF _eTaskGetState
	XDEF _vTaskDelay
	XDEF _xTaskDelayUntil
	XDEF _vTaskDelete
	XDEF _prvAddNewTaskToReadyList
	XDEF _prvInitialiseNewTask
	XDEF _xTaskCreate
	XDEF _uxSchedulerSuspended
	XDEF _uxTopUsedPriority
	XDEF _xIdleTaskHandle
	XDEF _xNextTaskUnblockTime
	XDEF _uxTaskNumber
	XDEF _xNumOfOverflows
	XDEF _xYieldPending
	XDEF _xPendedTicks
	XDEF _xSchedulerRunning
	XDEF _uxTopReadyPriority
	XDEF _xTickCount
	XDEF _uxCurrentNumberOfTasks
	XDEF _xSuspendedTaskList
	XDEF _uxDeletedTasksWaitingCleanUp
	XDEF _xTasksWaitingTermination
	XDEF _xPendingReadyList
	XDEF _pxOverflowDelayedTaskList
	XDEF _pxDelayedTaskList
	XDEF _xDelayedTaskList2
	XDEF _xDelayedTaskList1
	XDEF _pxReadyTasksLists
	XDEF _pxCurrentTCB
	END
